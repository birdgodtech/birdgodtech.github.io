<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>LinkedTransferQueue - BirdGod 技术分享</title>
    <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="BirdGod" /><meta name="description" content="LinkedTransferQueue源码分析 简介 LinkedTransferQueue是TransferQueue接口的实现类，其定义为一" /><meta name="keywords" content="Java" />






<meta name="generator" content="Hugo 0.74.0-DEV with even 4.0.0" />


<link rel="canonical" href="https://birdgodtech.github.io/post/concurrent/collection/06.LinkedTransferQueue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" />
<link href="/post/concurrent/collection/06.LinkedTransferQueue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="alternate" type="application/rss+xml" title="BirdGod 技术分享" />
<link href="/post/concurrent/collection/06.LinkedTransferQueue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="feed" type="application/rss+xml" title="BirdGod 技术分享" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<link href="/dist/even.06658218.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">
<link rel="stylesheet" href="/css/reset-even.css">


<meta property="og:title" content="LinkedTransferQueue" />
<meta property="og:description" content="LinkedTransferQueue源码分析 简介 LinkedTransferQueue是TransferQueue接口的实现类，其定义为一" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://birdgodtech.github.io/post/concurrent/collection/06.LinkedTransferQueue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" />
<meta property="article:published_time" content="2017-06-25T21:08:08+00:00" />
<meta property="article:modified_time" content="2017-06-25T21:08:08+00:00" />
<meta itemprop="name" content="LinkedTransferQueue">
<meta itemprop="description" content="LinkedTransferQueue源码分析 简介 LinkedTransferQueue是TransferQueue接口的实现类，其定义为一">
<meta itemprop="datePublished" content="2017-06-25T21:08:08&#43;00:00" />
<meta itemprop="dateModified" content="2017-06-25T21:08:08&#43;00:00" />
<meta itemprop="wordCount" content="15298">



<meta itemprop="keywords" content="LinkedTransferQueue," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="LinkedTransferQueue"/>
<meta name="twitter:description" content="LinkedTransferQueue源码分析 简介 LinkedTransferQueue是TransferQueue接口的实现类，其定义为一"/>

</head>
<body>
<div id="mobile-navbar" class="mobile-navbar">
    <div class="mobile-header-logo">
        <a href="/" class="logo">BirdGod 技术分享</a>
    </div>
    <div class="mobile-navbar-icon">
        <span></span>
        <span></span>
        <span></span>
    </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
    <ul class="mobile-menu-list">
        <a href="/">
            <li class="mobile-menu-item" title="首页">首页</li>
        </a>
        <a href="/post/">
            <li class="mobile-menu-item" title="归档">归档</li>
        </a>
        <a href="/categories/">
            <li class="mobile-menu-item" title="分类">分类</li>
        </a>
        <a href="/tags/">
            <li class="mobile-menu-item" title="标签">标签</li>
        </a>
        <a href="/about/">
            <li class="mobile-menu-item" title="关于我">关于我</li>
        </a>
        
    </ul>
</nav>

<div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
    <a href="/" class="logo">BirdGod 技术分享</a>
</div>

<nav class="site-navbar">
    <ul id="menu" class="menu" data-sum="0">
        
        <li class="menu-item menu-item-home">
            <a class="menu-item-link" href="/" title="首页">首页</a>
        </li>
        
        <li class="menu-item menu-item-archives">
            <a class="menu-item-link" href="/post/" title="归档">归档</a>
        </li>
        
        <li class="menu-item menu-item-categories">
            <a class="menu-item-link" href="/categories/" title="分类">分类</a>
        </li>
        
        <li class="menu-item menu-item-tags">
            <a class="menu-item-link" href="/tags/" title="标签">标签</a>
        </li>
        
        <li class="menu-item menu-item-about">
            <a class="menu-item-link" href="/about/" title="关于我">关于我</a>
        </li>
        
    </ul>
</nav>

    </header>


    <main id="main" class="main">
        <div class="content-wrapper">
            <div id="content" class="content">
                <article class="post">
  
  <header class="post-header">
    <h1 class="post-title">LinkedTransferQueue</h1>

    <div class="post-meta">
      <span class="post-time"> 2017-06-25 21:08 </span>
      <div class="post-category">
        <a href="/categories/%E5%B9%B6%E5%8F%91/"> 并发 </a>
        </div>
      <span class="more-meta"> 约 15298 字 </span>
      <span class="more-meta"> 预计阅读 31 分钟 </span>
      <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次阅读 </span>
    </div>
  </header>

  <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#简介">简介</a></li>
    <li><a href="#一linkedtransferqueue数据结构实现">一、LinkedTransferQueue数据结构实现</a>
      <ul>
        <li><a href="#1-node-实现">1. Node 实现</a></li>
        <li><a href="#2-linkedtransferqueue-构造">2. LinkedTransferQueue 构造</a></li>
        <li><a href="#3-linkedtransferqueue实现transferqueue接口">3. LinkedTransferQueue实现TransferQueue接口</a></li>
      </ul>
    </li>
    <li><a href="#二xfer-linkedtransferqueue核心方法">二、xfer LinkedTransferQueue核心方法</a></li>
    <li><a href="#二入队">二、入队</a>
      <ul>
        <li><a href="#1-offer方法">1. offer方法</a></li>
        <li><a href="#2-add方法">2. add方法</a></li>
        <li><a href="#3-put方法">3. put方法</a></li>
      </ul>
    </li>
    <li><a href="#三出队">三、出队</a>
      <ul>
        <li><a href="#1-poll方法">1. poll方法</a></li>
        <li><a href="#2-take方法">2. take方法</a></li>
        <li><a href="#3-peek方法">3. peek方法</a></li>
      </ul>
    </li>
    <li><a href="#四移除队列">四、移除队列</a>
      <ul>
        <li><a href="#1-remove方法">1. remove方法</a></li>
        <li><a href="#2-clear方法">2. clear方法</a></li>
        <li><a href="#3-drainto方法">3. drainTo方法</a></li>
      </ul>
    </li>
    <li><a href="#五transferqueue-接口方法实现">五、TransferQueue 接口方法实现</a></li>
    <li><a href="#六iterator-迭代器实现">六、Iterator 迭代器实现</a></li>
  </ul>
</nav>
  </div>
</div>
  <div class="post-outdated">
    <div class="warn">
      <p>【注意】最后更新于 <span class="timeago" datetime="2017-06-25T21:08:08" title="June 25, 2017">June 25, 2017</span>，文中内容可能已过时，请谨慎使用。</p>
    </div>
  </div>
  <div class="post-content">
    <h1 id="linkedtransferqueue源码分析">LinkedTransferQueue源码分析</h1>
<h2 id="简介">简介</h2>
<p>　　LinkedTransferQueue是TransferQueue接口的实现类，其定义为一个无界的队列，具有先进先出(FIFO)的特性。</p>
<p>　　有人这样评价它：&ldquo;TransferQueue是是ConcurrentLinkedQueue、SynchronousQueue (公平模式下)、无界的LinkedBlockingQueues等的超集。&rdquo;</p>
<h2 id="一linkedtransferqueue数据结构实现">一、LinkedTransferQueue数据结构实现</h2>
<h3 id="1-node-实现">1. Node 实现</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">    <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="kt">boolean</span> <span class="n">isData</span><span class="o">;</span>   <span class="c1">// false if this is a request node 如果这是一个请求节点，则为false
</span><span class="c1"></span>        <span class="kd">volatile</span> <span class="n">Object</span> <span class="n">item</span><span class="o">;</span>   <span class="c1">// initially non-null if isData; CASed to match  isData为true时，item存放数据，后面匹配后置为null
</span><span class="c1"></span>        <span class="kd">volatile</span> <span class="n">Node</span> <span class="n">next</span><span class="o">;</span>
        <span class="kd">volatile</span> <span class="n">Thread</span> <span class="n">waiter</span><span class="o">;</span> <span class="c1">// null until waiting
</span><span class="c1"></span>
        <span class="c1">// CAS methods for fields
</span><span class="c1"></span>        <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">casNext</span><span class="o">(</span><span class="n">Node</span> <span class="n">cmp</span><span class="o">,</span> <span class="n">Node</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapObject</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">nextOffset</span><span class="o">,</span> <span class="n">cmp</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">casItem</span><span class="o">(</span><span class="n">Object</span> <span class="n">cmp</span><span class="o">,</span> <span class="n">Object</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// assert cmp == null || cmp.getClass() != Node.class;
</span><span class="c1"></span>            <span class="k">return</span> <span class="n">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapObject</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">itemOffset</span><span class="o">,</span> <span class="n">cmp</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="cm">/**
</span><span class="cm">         * Constructs a new node.  Uses relaxed write because item can
</span><span class="cm">         * only be seen after publication via casNext.
</span><span class="cm">         */</span>
        <span class="n">Node</span><span class="o">(</span><span class="n">Object</span> <span class="n">item</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">isData</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">UNSAFE</span><span class="o">.</span><span class="na">putObject</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">itemOffset</span><span class="o">,</span> <span class="n">item</span><span class="o">);</span> <span class="c1">// relaxed write
</span><span class="c1"></span>            <span class="k">this</span><span class="o">.</span><span class="na">isData</span> <span class="o">=</span> <span class="n">isData</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="cm">/**
</span><span class="cm">         * Links node to itself to avoid garbage retention.  Called
</span><span class="cm">         * only after CASing head field, so uses relaxed write.
</span><span class="cm">         * 将节点链接到自身以避免垃圾留存。只有在CAS 头节点之后调用，所以使用宽松的写法。
</span><span class="cm">         */</span>
        <span class="kd">final</span> <span class="kt">void</span> <span class="nf">forgetNext</span><span class="o">()</span> <span class="o">{</span>
            <span class="n">UNSAFE</span><span class="o">.</span><span class="na">putObject</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">nextOffset</span><span class="o">,</span> <span class="k">this</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="cm">/**
</span><span class="cm">         * Sets item to self and waiter to null, to avoid garbage
</span><span class="cm">         * retention after matching or cancelling. Uses relaxed writes
</span><span class="cm">         * because order is already constrained in the only calling
</span><span class="cm">         * contexts: item is forgotten only after volatile/atomic
</span><span class="cm">         * mechanics that extract items.  Similarly, clearing waiter
</span><span class="cm">         * follows either CAS or return from park (if ever parked;
</span><span class="cm">         * else we don&#39;t care).
</span><span class="cm">         * 将item 设置为自己并将waiter 设置为空，以避免匹配或取消后的垃圾留存。
</span><span class="cm">         * 使用轻松的写入，因为顺序已经被限制在唯一的调用上下文中：只有在提取item的 volatile/atomic 之后,item才被遗忘。同样，
</span><span class="cm">         * 清空 waiter 要么遵循CAS，要么从park 返回（如果 parked;，否则我们不在乎）。
</span><span class="cm">         */</span>
        <span class="kd">final</span> <span class="kt">void</span> <span class="nf">forgetContents</span><span class="o">()</span> <span class="o">{</span>
            <span class="n">UNSAFE</span><span class="o">.</span><span class="na">putObject</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">itemOffset</span><span class="o">,</span> <span class="k">this</span><span class="o">);</span>
            <span class="n">UNSAFE</span><span class="o">.</span><span class="na">putObject</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">waiterOffset</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="cm">/**
</span><span class="cm">         * Returns true if this node has been matched, including the
</span><span class="cm">         * case of artificial matches due to cancellation.
</span><span class="cm">         * 如果此节点已匹配，则返回true，包括由于取消而导致的人为匹配。
</span><span class="cm">         */</span>
        <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">isMatched</span><span class="o">()</span> <span class="o">{</span>
            <span class="n">Object</span> <span class="n">x</span> <span class="o">=</span> <span class="n">item</span><span class="o">;</span>
            <span class="k">return</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="k">this</span><span class="o">)</span> <span class="o">||</span> <span class="o">((</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">==</span> <span class="n">isData</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="cm">/**
</span><span class="cm">         * Returns true if this is an unmatched request node.
</span><span class="cm">         * 是否请求节点
</span><span class="cm">         */</span>
        <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">isUnmatchedRequest</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="o">!</span><span class="n">isData</span> <span class="o">&amp;&amp;</span> <span class="n">item</span> <span class="o">==</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="cm">/**
</span><span class="cm">         * Returns true if a node with the given mode cannot be
</span><span class="cm">         * appended to this node because this node is unmatched and
</span><span class="cm">         * has opposite data mode.
</span><span class="cm">         * 如果具有给定模式的节点不能附加到该节点，则返回true，因为此节点不匹配，并且具有相反的数据模式。
</span><span class="cm">         */</span>
        <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">cannotPrecede</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">haveData</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">boolean</span> <span class="n">d</span> <span class="o">=</span> <span class="n">isData</span><span class="o">;</span>
            <span class="n">Object</span> <span class="n">x</span><span class="o">;</span>
            <span class="k">return</span> <span class="n">d</span> <span class="o">!=</span> <span class="n">haveData</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">x</span> <span class="o">=</span> <span class="n">item</span><span class="o">)</span> <span class="o">!=</span> <span class="k">this</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">x</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">==</span> <span class="n">d</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="cm">/**
</span><span class="cm">         * Tries to artificially match a data node -- used by remove.
</span><span class="cm">         */</span>
        <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">tryMatchData</span><span class="o">()</span> <span class="o">{</span>
            <span class="c1">// assert isData;
</span><span class="c1"></span>            <span class="n">Object</span> <span class="n">x</span> <span class="o">=</span> <span class="n">item</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">!=</span> <span class="k">this</span> <span class="o">&amp;&amp;</span> <span class="n">casItem</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="kc">null</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">LockSupport</span><span class="o">.</span><span class="na">unpark</span><span class="o">(</span><span class="n">waiter</span><span class="o">);</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="o">-</span><span class="n">3375979862319811754L</span><span class="o">;</span>

        <span class="c1">// Unsafe mechanics
</span><span class="c1"></span>        <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">sun</span><span class="o">.</span><span class="na">misc</span><span class="o">.</span><span class="na">Unsafe</span> <span class="n">UNSAFE</span><span class="o">;</span>
        <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">itemOffset</span><span class="o">;</span>
        <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">nextOffset</span><span class="o">;</span>
        <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">waiterOffset</span><span class="o">;</span>
        <span class="kd">static</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">UNSAFE</span> <span class="o">=</span> <span class="n">sun</span><span class="o">.</span><span class="na">misc</span><span class="o">.</span><span class="na">Unsafe</span><span class="o">.</span><span class="na">getUnsafe</span><span class="o">();</span>
                <span class="n">Class</span> <span class="n">k</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
                <span class="n">itemOffset</span> <span class="o">=</span> <span class="n">UNSAFE</span><span class="o">.</span><span class="na">objectFieldOffset</span>
                    <span class="o">(</span><span class="n">k</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">&#34;item&#34;</span><span class="o">));</span>
                <span class="n">nextOffset</span> <span class="o">=</span> <span class="n">UNSAFE</span><span class="o">.</span><span class="na">objectFieldOffset</span>
                    <span class="o">(</span><span class="n">k</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">&#34;next&#34;</span><span class="o">));</span>
                <span class="n">waiterOffset</span> <span class="o">=</span> <span class="n">UNSAFE</span><span class="o">.</span><span class="na">objectFieldOffset</span>
                    <span class="o">(</span><span class="n">k</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">&#34;waiter&#34;</span><span class="o">));</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">Error</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="2-linkedtransferqueue-构造">2. LinkedTransferQueue 构造</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span><span class="lnt">233
</span><span class="lnt">234
</span><span class="lnt">235
</span><span class="lnt">236
</span><span class="lnt">237
</span><span class="lnt">238
</span><span class="lnt">239
</span><span class="lnt">240
</span><span class="lnt">241
</span><span class="lnt">242
</span><span class="lnt">243
</span><span class="lnt">244
</span><span class="lnt">245
</span><span class="lnt">246
</span><span class="lnt">247
</span><span class="lnt">248
</span><span class="lnt">249
</span><span class="lnt">250
</span><span class="lnt">251
</span><span class="lnt">252
</span><span class="lnt">253
</span><span class="lnt">254
</span><span class="lnt">255
</span><span class="lnt">256
</span><span class="lnt">257
</span><span class="lnt">258
</span><span class="lnt">259
</span><span class="lnt">260
</span><span class="lnt">261
</span><span class="lnt">262
</span><span class="lnt">263
</span><span class="lnt">264
</span><span class="lnt">265
</span><span class="lnt">266
</span><span class="lnt">267
</span><span class="lnt">268
</span><span class="lnt">269
</span><span class="lnt">270
</span><span class="lnt">271
</span><span class="lnt">272
</span><span class="lnt">273
</span><span class="lnt">274
</span><span class="lnt">275
</span><span class="lnt">276
</span><span class="lnt">277
</span><span class="lnt">278
</span><span class="lnt">279
</span><span class="lnt">280
</span><span class="lnt">281
</span><span class="lnt">282
</span><span class="lnt">283
</span><span class="lnt">284
</span><span class="lnt">285
</span><span class="lnt">286
</span><span class="lnt">287
</span><span class="lnt">288
</span><span class="lnt">289
</span><span class="lnt">290
</span><span class="lnt">291
</span><span class="lnt">292
</span><span class="lnt">293
</span><span class="lnt">294
</span><span class="lnt">295
</span><span class="lnt">296
</span><span class="lnt">297
</span><span class="lnt">298
</span><span class="lnt">299
</span><span class="lnt">300
</span><span class="lnt">301
</span><span class="lnt">302
</span><span class="lnt">303
</span><span class="lnt">304
</span><span class="lnt">305
</span><span class="lnt">306
</span><span class="lnt">307
</span><span class="lnt">308
</span><span class="lnt">309
</span><span class="lnt">310
</span><span class="lnt">311
</span><span class="lnt">312
</span><span class="lnt">313
</span><span class="lnt">314
</span><span class="lnt">315
</span><span class="lnt">316
</span><span class="lnt">317
</span><span class="lnt">318
</span><span class="lnt">319
</span><span class="lnt">320
</span><span class="lnt">321
</span><span class="lnt">322
</span><span class="lnt">323
</span><span class="lnt">324
</span><span class="lnt">325
</span><span class="lnt">326
</span><span class="lnt">327
</span><span class="lnt">328
</span><span class="lnt">329
</span><span class="lnt">330
</span><span class="lnt">331
</span><span class="lnt">332
</span><span class="lnt">333
</span><span class="lnt">334
</span><span class="lnt">335
</span><span class="lnt">336
</span><span class="lnt">337
</span><span class="lnt">338
</span><span class="lnt">339
</span><span class="lnt">340
</span><span class="lnt">341
</span><span class="lnt">342
</span><span class="lnt">343
</span><span class="lnt">344
</span><span class="lnt">345
</span><span class="lnt">346
</span><span class="lnt">347
</span><span class="lnt">348
</span><span class="lnt">349
</span><span class="lnt">350
</span><span class="lnt">351
</span><span class="lnt">352
</span><span class="lnt">353
</span><span class="lnt">354
</span><span class="lnt">355
</span><span class="lnt">356
</span><span class="lnt">357
</span><span class="lnt">358
</span><span class="lnt">359
</span><span class="lnt">360
</span><span class="lnt">361
</span><span class="lnt">362
</span><span class="lnt">363
</span><span class="lnt">364
</span><span class="lnt">365
</span><span class="lnt">366
</span><span class="lnt">367
</span><span class="lnt">368
</span><span class="lnt">369
</span><span class="lnt">370
</span><span class="lnt">371
</span><span class="lnt">372
</span><span class="lnt">373
</span><span class="lnt">374
</span><span class="lnt">375
</span><span class="lnt">376
</span><span class="lnt">377
</span><span class="lnt">378
</span><span class="lnt">379
</span><span class="lnt">380
</span><span class="lnt">381
</span><span class="lnt">382
</span><span class="lnt">383
</span><span class="lnt">384
</span><span class="lnt">385
</span><span class="lnt">386
</span><span class="lnt">387
</span><span class="lnt">388
</span><span class="lnt">389
</span><span class="lnt">390
</span><span class="lnt">391
</span><span class="lnt">392
</span><span class="lnt">393
</span><span class="lnt">394
</span><span class="lnt">395
</span><span class="lnt">396
</span><span class="lnt">397
</span><span class="lnt">398
</span><span class="lnt">399
</span><span class="lnt">400
</span><span class="lnt">401
</span><span class="lnt">402
</span><span class="lnt">403
</span><span class="lnt">404
</span><span class="lnt">405
</span><span class="lnt">406
</span><span class="lnt">407
</span><span class="lnt">408
</span><span class="lnt">409
</span><span class="lnt">410
</span><span class="lnt">411
</span><span class="lnt">412
</span><span class="lnt">413
</span><span class="lnt">414
</span><span class="lnt">415
</span><span class="lnt">416
</span><span class="lnt">417
</span><span class="lnt">418
</span><span class="lnt">419
</span><span class="lnt">420
</span><span class="lnt">421
</span><span class="lnt">422
</span><span class="lnt">423
</span><span class="lnt">424
</span><span class="lnt">425
</span><span class="lnt">426
</span><span class="lnt">427
</span><span class="lnt">428
</span><span class="lnt">429
</span><span class="lnt">430
</span><span class="lnt">431
</span><span class="lnt">432
</span><span class="lnt">433
</span><span class="lnt">434
</span><span class="lnt">435
</span><span class="lnt">436
</span><span class="lnt">437
</span><span class="lnt">438
</span><span class="lnt">439
</span><span class="lnt">440
</span><span class="lnt">441
</span><span class="lnt">442
</span><span class="lnt">443
</span><span class="lnt">444
</span><span class="lnt">445
</span><span class="lnt">446
</span><span class="lnt">447
</span><span class="lnt">448
</span><span class="lnt">449
</span><span class="lnt">450
</span><span class="lnt">451
</span><span class="lnt">452
</span><span class="lnt">453
</span><span class="lnt">454
</span><span class="lnt">455
</span><span class="lnt">456
</span><span class="lnt">457
</span><span class="lnt">458
</span><span class="lnt">459
</span><span class="lnt">460
</span><span class="lnt">461
</span><span class="lnt">462
</span><span class="lnt">463
</span><span class="lnt">464
</span><span class="lnt">465
</span><span class="lnt">466
</span><span class="lnt">467
</span><span class="lnt">468
</span><span class="lnt">469
</span><span class="lnt">470
</span><span class="lnt">471
</span><span class="lnt">472
</span><span class="lnt">473
</span><span class="lnt">474
</span><span class="lnt">475
</span><span class="lnt">476
</span><span class="lnt">477
</span><span class="lnt">478
</span><span class="lnt">479
</span><span class="lnt">480
</span><span class="lnt">481
</span><span class="lnt">482
</span><span class="lnt">483
</span><span class="lnt">484
</span><span class="lnt">485
</span><span class="lnt">486
</span><span class="lnt">487
</span><span class="lnt">488
</span><span class="lnt">489
</span><span class="lnt">490
</span><span class="lnt">491
</span><span class="lnt">492
</span><span class="lnt">493
</span><span class="lnt">494
</span><span class="lnt">495
</span><span class="lnt">496
</span><span class="lnt">497
</span><span class="lnt">498
</span><span class="lnt">499
</span><span class="lnt">500
</span><span class="lnt">501
</span><span class="lnt">502
</span><span class="lnt">503
</span><span class="lnt">504
</span><span class="lnt">505
</span><span class="lnt">506
</span><span class="lnt">507
</span><span class="lnt">508
</span><span class="lnt">509
</span><span class="lnt">510
</span><span class="lnt">511
</span><span class="lnt">512
</span><span class="lnt">513
</span><span class="lnt">514
</span><span class="lnt">515
</span><span class="lnt">516
</span><span class="lnt">517
</span><span class="lnt">518
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LinkedTransferQueue</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">AbstractQueue</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span>
    <span class="kd">implements</span> <span class="n">TransferQueue</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;,</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">Serializable</span> <span class="o">{</span>
 
 <span class="cm">/*
</span><span class="cm">  * *** Overview of Dual Queues with Slack *** 双重队列的概述
</span><span class="cm">  *
</span><span class="cm">  * Dual Queues, introduced by Scherer and Scott
</span><span class="cm">  * (http://www.cs.rice.edu/~wns1/papers/2004-DISC-DDS.pdf) are
</span><span class="cm">  * (linked) queues in which nodes may represent either data or
</span><span class="cm">  * requests.  When a thread tries to enqueue a data node, but
</span><span class="cm">  * encounters a request node, it instead &#34;matches&#34; and removes it;
</span><span class="cm">  * and vice versa for enqueuing requests. Blocking Dual Queues
</span><span class="cm">  * arrange that threads enqueuing unmatched requests block until
</span><span class="cm">  * other threads provide the match. Dual Synchronous Queues (see
</span><span class="cm">  * Scherer, Lea, &amp; Scott
</span><span class="cm">  * http://www.cs.rochester.edu/u/scott/papers/2009_Scherer_CACM_SSQ.pdf)
</span><span class="cm">  * additionally arrange that threads enqueuing unmatched data also
</span><span class="cm">  * block.  Dual Transfer Queues support all of these modes, as
</span><span class="cm">  * dictated by callers.
</span><span class="cm">  *
</span><span class="cm">  * A FIFO dual queue may be implemented using a variation of the
</span><span class="cm">  * Michael &amp; Scott (M&amp;S) lock-free queue algorithm
</span><span class="cm">  * (http://www.cs.rochester.edu/u/scott/papers/1996_PODC_queues.pdf).
</span><span class="cm">  * It maintains two pointer fields, &#34;head&#34;, pointing to a
</span><span class="cm">  * (matched) node that in turn points to the first actual
</span><span class="cm">  * (unmatched) queue node (or null if empty); and &#34;tail&#34; that
</span><span class="cm">  * points to the last node on the queue (or again null if
</span><span class="cm">  * empty). For example, here is a possible queue with four data
</span><span class="cm">  * elements:
</span><span class="cm">  * 使用Michael &amp; Scott(M &amp; S)无锁队列算法的变体，可以实现FIFO双队列.
</span><span class="cm">  * (http://www.cs.rochester.edu/u/scott/papers/1996_PODC_queues.pdf).
</span><span class="cm">  *  它维护两个指针字段“head”，指向一个(匹配的)节点，该节点指向第一个实际(未匹配的)队列节点(如果空);
</span><span class="cm">  *  以及指向队列上最后一个节点的“tail”(如果是空的，则返回null)。例如，这里有一个带有四个数据元素的队列:
</span><span class="cm">  *  head                tail
</span><span class="cm">  *    |                   |
</span><span class="cm">  *    v                   v
</span><span class="cm">  *    M -&gt; U -&gt; U -&gt; U -&gt; U
</span><span class="cm">  *
</span><span class="cm">  * The M&amp;S queue algorithm is known to be prone to scalability and
</span><span class="cm">  * overhead limitations when maintaining (via CAS) these head and
</span><span class="cm">  * tail pointers. This has led to the development of
</span><span class="cm">  * contention-reducing variants such as elimination arrays (see
</span><span class="cm">  * Moir et al http://portal.acm.org/citation.cfm?id=1074013) and
</span><span class="cm">  * optimistic back pointers (see Ladan-Mozes &amp; Shavit
</span><span class="cm">  * http://people.csail.mit.edu/edya/publications/OptimisticFIFOQueue-journal.pdf).
</span><span class="cm">  * However, the nature of dual queues enables a simpler tactic for
</span><span class="cm">  * improving M&amp;S-style implementations when dual-ness is needed.
</span><span class="cm">  * 已知M＆S队列算法在维护（通过CAS）这些头部和尾部指针时易于出现可扩展性和开销限制。
</span><span class="cm">  * 这导致了减少竞争的变体的开发，如消除数组和乐观的后退指针。然而，当双重队列需要时，
</span><span class="cm">  * 双重队列的本质使得更简单的策略可以改进M＆S风格的实现。
</span><span class="cm">  * 
</span><span class="cm">  *
</span><span class="cm">  * In a dual queue, each node must atomically maintain its match
</span><span class="cm">  * status. While there are other possible variants, we implement
</span><span class="cm">  * this here as: for a data-mode node, matching entails CASing an
</span><span class="cm">  * &#34;item&#34; field from a non-null data value to null upon match, and
</span><span class="cm">  * vice-versa for request nodes, CASing from null to a data
</span><span class="cm">  * value. (Note that the linearization properties of this style of
</span><span class="cm">  * queue are easy to verify -- elements are made available by
</span><span class="cm">  * linking, and unavailable by matching.) Compared to plain M&amp;S
</span><span class="cm">  * queues, this property of dual queues requires one additional
</span><span class="cm">  * successful atomic operation per enq/deq pair. But it also
</span><span class="cm">  * enables lower cost variants of queue maintenance mechanics. (A
</span><span class="cm">  * variation of this idea applies even for non-dual queues that
</span><span class="cm">  * support deletion of interior elements, such as
</span><span class="cm">  * j.u.c.ConcurrentLinkedQueue.)
</span><span class="cm">  * 在双队列中，每个节点必须自动维护其匹配状态。虽然还有其他可能的变体，但我们在这里实现：对于数据模式节点，
</span><span class="cm">  * 匹配需要将非空数据值中的&#34;item&#34;字段填充为匹配时为空，反之亦然，请求节点null为数据值。 
</span><span class="cm">  *（请注意，这种类型的队列的线性化属性很容易验证 - 元素通过链接提供，而不能通过匹配）。与普通的M＆S队列相比，双队列的这个属性需要每个enq / deq对。
</span><span class="cm">  * 但是它也可以实现队列维护机制的更低成本的变体。 （即使对支持删除内部元素的非双重队列，如j.u.c.ConcurrentLinkedQueue也适用这种思路的变体。）
</span><span class="cm">  *
</span><span class="cm">  * Once a node is matched, its match status can never again
</span><span class="cm">  * change.  We may thus arrange that the linked list of them
</span><span class="cm">  * contain a prefix of zero or more matched nodes, followed by a
</span><span class="cm">  * suffix of zero or more unmatched nodes. (Note that we allow
</span><span class="cm">  * both the prefix and suffix to be zero length, which in turn
</span><span class="cm">  * means that we do not use a dummy header.)  If we were not
</span><span class="cm">  * concerned with either time or space efficiency, we could
</span><span class="cm">  * correctly perform enqueue and dequeue operations by traversing
</span><span class="cm">  * from a pointer to the initial node; CASing the item of the
</span><span class="cm">  * first unmatched node on match and CASing the next field of the
</span><span class="cm">  * trailing node on appends. (Plus some special-casing when
</span><span class="cm">  * initially empty).  While this would be a terrible idea in
</span><span class="cm">  * itself, it does have the benefit of not requiring ANY atomic
</span><span class="cm">  * updates on head/tail fields.
</span><span class="cm">  * 一旦节点匹配，其匹配状态就不会再改变。因此，我们可以安排它们的链表包含零个或多个匹配节点的前缀，后跟零个或多个不匹配节点的后缀。 
</span><span class="cm">  * （请注意，我们允许前缀和后缀为零长度，这意味着我们不使用虚拟标头。）如果我们不关心时间或空间的效率，我们可以正确执行入队和出队操作从指针遍历到初始节点; 
</span><span class="cm">  * CASing 将匹配的第一个未匹配节点的item，并在追加的末尾处CASing下一个字段。。（加上一些特殊的外壳时，最初是空的）。虽然这本身就是一个可怕的想法，
</span><span class="cm">  * 但它的好处是不需要在头部/尾部字段上进行任何原子更新。
</span><span class="cm">  *
</span><span class="cm">  *
</span><span class="cm">  * We introduce here an approach that lies between the extremes of
</span><span class="cm">  * never versus always updating queue (head and tail) pointers.
</span><span class="cm">  * This offers a tradeoff between sometimes requiring extra
</span><span class="cm">  * traversal steps to locate the first and/or last unmatched
</span><span class="cm">  * nodes, versus the reduced overhead and contention of fewer
</span><span class="cm">  * updates to queue pointers. For example, a possible snapshot of
</span><span class="cm">  * a queue is:
</span><span class="cm">  * 我们在这里介绍一种位于从不与总是更新队列（头部和尾部）指针的极端之间的方法。
</span><span class="cm">  * 这提供了有时需要额外的遍历步骤来定位第一个和/或最后一个不匹配的节点与降低的开销和对队列指针的较少更新的争用之间的折衷。
</span><span class="cm">  * 例如，一个可能的队列快照是
</span><span class="cm">  *
</span><span class="cm">  *  head           tail
</span><span class="cm">  *    |              |
</span><span class="cm">  *    v              v
</span><span class="cm">  *    M -&gt; M -&gt; U -&gt; U -&gt; U -&gt; U
</span><span class="cm">  *
</span><span class="cm">  * The best value for this &#34;slack&#34; (the targeted maximum distance
</span><span class="cm">  * between the value of &#34;head&#34; and the first unmatched node, and
</span><span class="cm">  * similarly for &#34;tail&#34;) is an empirical matter. We have found
</span><span class="cm">  * that using very small constants in the range of 1-3 work best
</span><span class="cm">  * over a range of platforms. Larger values introduce increasing
</span><span class="cm">  * costs of cache misses and risks of long traversal chains, while
</span><span class="cm">  * smaller values increase CAS contention and overhead.
</span><span class="cm">  * 对于这种&#34;松弛&#34;（&#34;头&#34;的值和第一个不匹配的节点之间的目标最大距离，以及类似于&#34;尾巴&#34;）的最佳值是经验问题。
</span><span class="cm">  * 我们发现使用1-3范围内的非常小的常数在一系列平台上工作得最好。较大的值会导致缓存未命中的增加成本以及长遍历链的风险，而较小的值会增加CAS竞争和开销。
</span><span class="cm">  *
</span><span class="cm">  * Dual queues with slack differ from plain M&amp;S dual queues by
</span><span class="cm">  * virtue of only sometimes updating head or tail pointers when
</span><span class="cm">  * matching, appending, or even traversing nodes; in order to
</span><span class="cm">  * maintain a targeted slack.  The idea of &#34;sometimes&#34; may be
</span><span class="cm">  * operationalized in several ways. The simplest is to use a
</span><span class="cm">  * per-operation counter incremented on each traversal step, and
</span><span class="cm">  * to try (via CAS) to update the associated queue pointer
</span><span class="cm">  * whenever the count exceeds a threshold. Another, that requires
</span><span class="cm">  * more overhead, is to use random number generators to update
</span><span class="cm">  * with a given probability per traversal step.
</span><span class="cm">  * 由于在匹配，追加或遍历节点时只有时更新头部或尾部指针，所以具有松弛的双重队列不同于普通的M＆S双重队列;以维持目标松懈。 
</span><span class="cm">  * &#34;有时&#34;的想法可以通过几种方式来实施。最简单的方法是在每个遍历步骤中使用逐个计数的计数器，并在计数超过阈值时尝试（通过CAS）更新关联的队列指针。
</span><span class="cm">  * 另一个需要更多开销的方法是使用随机数生成器，以每个遍历步骤的给定概率进行更新。
</span><span class="cm">  *
</span><span class="cm">  * In any strategy along these lines, because CASes updating
</span><span class="cm">  * fields may fail, the actual slack may exceed targeted
</span><span class="cm">  * slack. However, they may be retried at any time to maintain
</span><span class="cm">  * targets.  Even when using very small slack values, this
</span><span class="cm">  * approach works well for dual queues because it allows all
</span><span class="cm">  * operations up to the point of matching or appending an item
</span><span class="cm">  * (hence potentially allowing progress by another thread) to be
</span><span class="cm">  * read-only, thus not introducing any further contention. As
</span><span class="cm">  * described below, we implement this by performing slack
</span><span class="cm">  * maintenance retries only after these points.
</span><span class="cm">  * 在沿着这些路线的任何策略中，因为CASes更新字段可能失败，所以实际的松弛可能超过目标松弛。
</span><span class="cm">  * 但是，他们可能会随时重试以维持目标。即使使用非常小的松弛值，这种方法也适用于双重队列，因为它允许所有的操作直到匹配或附加一个item（因此可能允许另一个线程的进度）
</span><span class="cm">  * 为只读的，因此不会引入任何进一步的争。如下所述，我们通过仅在这些点之后执行松弛维护重试来实现这一点。
</span><span class="cm">  *
</span><span class="cm">  * As an accompaniment to such techniques, traversal overhead can
</span><span class="cm">  * be further reduced without increasing contention of head
</span><span class="cm">  * pointer updates: Threads may sometimes shortcut the &#34;next&#34; link
</span><span class="cm">  * path from the current &#34;head&#34; node to be closer to the currently
</span><span class="cm">  * known first unmatched node, and similarly for tail. Again, this
</span><span class="cm">  * may be triggered with using thresholds or randomization.
</span><span class="cm">  * 作为这种技术的伴随，在不增加头指针更新争用的情况下，可以进一步减少遍历开销：线程有时可以使从当前&#34;头&#34;节点开始的&#34;下一个&#34;链接路径更接近当前已知的第一个不匹配节点，
</span><span class="cm">  * 类似的尾巴。再一次地，这可以通过使用阈值或随机化来触发。
</span><span class="cm">  *
</span><span class="cm">  * These ideas must be further extended to avoid unbounded amounts
</span><span class="cm">  * of costly-to-reclaim garbage caused by the sequential &#34;next&#34;
</span><span class="cm">  * links of nodes starting at old forgotten head nodes: As first
</span><span class="cm">  * described in detail by Boehm
</span><span class="cm">  * (http://portal.acm.org/citation.cfm?doid=503272.503282) if a GC
</span><span class="cm">  * delays noticing that any arbitrarily old node has become
</span><span class="cm">  * garbage, all newer dead nodes will also be unreclaimed.
</span><span class="cm">  * (Similar issues arise in non-GC environments.)  To cope with
</span><span class="cm">  * this in our implementation, upon CASing to advance the head
</span><span class="cm">  * pointer, we set the &#34;next&#34; link of the previous head to point
</span><span class="cm">  * only to itself; thus limiting the length of connected dead lists.
</span><span class="cm">  * (We also take similar care to wipe out possibly garbage
</span><span class="cm">  * retaining values held in other Node fields.)  However, doing so
</span><span class="cm">  * adds some further complexity to traversal: If any &#34;next&#34;
</span><span class="cm">  * pointer links to itself, it indicates that the current thread
</span><span class="cm">  * has lagged behind a head-update, and so the traversal must
</span><span class="cm">  * continue from the &#34;head&#34;.  Traversals trying to find the
</span><span class="cm">  * current tail starting from &#34;tail&#34; may also encounter
</span><span class="cm">  * self-links, in which case they also continue at &#34;head&#34;.
</span><span class="cm">  *这些想法必须进一步扩展，以避免从旧的被遗忘的头节点开始的连续的&#34;下一个&#34;节点链接造成的成本高昂的回收垃圾的无限量：
</span><span class="cm">  * 如Boehm（http：//portal.acm。 org / citation.cfm？doid = 503272.503282）如果GC延迟注意到任何旧的节点已经变成垃圾，所有更新的死节点也将被废弃。 
</span><span class="cm">  * （在非GC环境中也会出现类似的问题）在我们的实现中，为了应对这种情况，在CASing提高头指针时，我们设置前一个头的&#34;下一个&#34;链接指向它自己;从而限制连接的死亡列表的长度。
</span><span class="cm">  * （我们也采取类似的措施来消除其他节点字段中可能存在的垃圾保留值）。但是，这样做会增加一些进一步的复杂性：如果任何&#34;下一个&#34;指针链接到自身，则表示当前线程已经落后
</span><span class="cm">  *  头部更新，所以遍历必须从&#34;头部&#34;继续。遍历试图从&#34;尾巴&#34;开始寻找当前的尾巴也可能遇到自连接，在这种情况下，它们也继续在&#34;头部&#34;。
</span><span class="cm">  *  
</span><span class="cm">  * It is tempting in slack-based scheme to not even use CAS for
</span><span class="cm">  * updates (similarly to Ladan-Mozes &amp; Shavit). However, this
</span><span class="cm">  * cannot be done for head updates under the above link-forgetting
</span><span class="cm">  * mechanics because an update may leave head at a detached node.
</span><span class="cm">  * And while direct writes are possible for tail updates, they
</span><span class="cm">  * increase the risk of long retraversals, and hence long garbage
</span><span class="cm">  * chains, which can be much more costly than is worthwhile
</span><span class="cm">  * considering that the cost difference of performing a CAS vs
</span><span class="cm">  * write is smaller when they are not triggered on each operation
</span><span class="cm">  * (especially considering that writes and CASes equally require
</span><span class="cm">  * additional GC bookkeeping (&#34;write barriers&#34;) that are sometimes
</span><span class="cm">  * more costly than the writes themselves because of contention).
</span><span class="cm">  * 基于松弛的方案很诱人，甚至不使用CAS进行更新（类似于Ladan-Mozes＆Shavit）。
</span><span class="cm">  * 但是，在上述链接遗忘机制下，这不能用于头部更新，因为更新可能会使头部处于分离节点。
</span><span class="cm">  * 尽管直接写入对于尾部更新是可能的，但是它们增加了长时间回缩的风险，并且因此增加了长的垃圾链，
</span><span class="cm">  * 考虑到执行CAS与写入的成本差异当不是更小时，可能成本更高（尤其是考虑到写入和CASes同样需要额外的GC簿记（“写入障碍”），
</span><span class="cm">  * 由于争用的原因，有时比写入本身更昂贵）。
</span><span class="cm">  *
</span><span class="cm">  * *** Overview of implementation ***
</span><span class="cm">  *
</span><span class="cm">  * We use a threshold-based approach to updates, with a slack
</span><span class="cm">  * threshold of two -- that is, we update head/tail when the
</span><span class="cm">  * current pointer appears to be two or more steps away from the
</span><span class="cm">  * first/last node. The slack value is hard-wired: a path greater
</span><span class="cm">  * than one is naturally implemented by checking equality of
</span><span class="cm">  * traversal pointers except when the list has only one element,
</span><span class="cm">  * in which case we keep slack threshold at one. Avoiding tracking
</span><span class="cm">  * explicit counts across method calls slightly simplifies an
</span><span class="cm">  * already-messy implementation. Using randomization would
</span><span class="cm">  * probably work better if there were a low-quality dirt-cheap
</span><span class="cm">  * per-thread one available, but even ThreadLocalRandom is too
</span><span class="cm">  * heavy for these purposes.
</span><span class="cm">  * 我们使用基于阈值的方法进行更新，其中松弛阈值为2--
</span><span class="cm">  * 也就是说，当当前指针显示为离第一个/最后一个节点的两个或更多的步骤时，我们将更新head / tail。
</span><span class="cm">  * 他的松弛值是硬连线的：大于1的路径自然是通过检查遍历指针的相等性来实现的，除非列表只有一个元素，在这种情况下，我们保持松弛阈值为1。
</span><span class="cm">  * 避免跟踪方法调用中的显式计数会略微简化已经很混乱的实现.
</span><span class="cm">  * 使用随机化可能会更好，如果有一个低质量的廉价的每线程可用，但即使ThreadLocalRandom太重这些目的。
</span><span class="cm">  *
</span><span class="cm">  * With such a small slack threshold value, it is not worthwhile
</span><span class="cm">  * to augment this with path short-circuiting (i.e., unsplicing
</span><span class="cm">  * interior nodes) except in the case of cancellation/removal (see
</span><span class="cm">  * below).
</span><span class="cm">  * 有了这样一个小的松弛门限值，除了取消/删除（见下文）的情况之外，不值得用路径短的路径（即，非拼接的内部节点）来增加这个值 
</span><span class="cm">  *
</span><span class="cm">  * We allow both the head and tail fields to be null before any
</span><span class="cm">  * nodes are enqueued; initializing upon first append.  This
</span><span class="cm">  * simplifies some other logic, as well as providing more
</span><span class="cm">  * efficient explicit control paths instead of letting JVMs insert
</span><span class="cm">  * implicit NullPointerExceptions when they are null.  While not
</span><span class="cm">  * currently fully implemented, we also leave open the possibility
</span><span class="cm">  * of re-nulling these fields when empty (which is complicated to
</span><span class="cm">  * arrange, for little benefit.)
</span><span class="cm">  * 在任何节点入队之前，我们允许头字段和尾字段为空;初次追加。
</span><span class="cm">  * 这简化了一些其他的逻辑，并提供了更高效的显式控制路径，而不是让JVMs在其为空时插入隐式NullPointerExceptions 。
</span><span class="cm">  * 虽然目前还没有完全实施，但是我们也可以在空的时候重新确定这些领域的可能性（这很复杂，没有什么好处）。
</span><span class="cm">  *
</span><span class="cm">  * All enqueue/dequeue operations are handled by the single method
</span><span class="cm">  * &#34;xfer&#34; with parameters indicating whether to act as some form
</span><span class="cm">  * of offer, put, poll, take, or transfer (each possibly with
</span><span class="cm">  * timeout). The relative complexity of using one monolithic
</span><span class="cm">  * method outweighs the code bulk and maintenance problems of
</span><span class="cm">  * using separate methods for each case.
</span><span class="cm">  * 所有enqueue / dequeue操作都由单个方法“xfer”来处理，参数指示是否作为某种形式的offer、put、poll、take或transfer(每个可能有超时)。
</span><span class="cm">  * 使用单方法的相对复杂性超过了对每种情况使用单独方法的代码批量和维护问题。
</span><span class="cm">  * 
</span><span class="cm">  * Operation consists of up to three phases. The first is
</span><span class="cm">  * implemented within method xfer, the second in tryAppend, and
</span><span class="cm">  * the third in method awaitMatch.
</span><span class="cm">  * 操作包括三个阶段。第一个在方法xfer中实现，第二个在tryAppend，第三个在方法awaitMatch。
</span><span class="cm">  *
</span><span class="cm">  * 1. Try to match an existing node 尝试匹配现有节点
</span><span class="cm">  *
</span><span class="cm">  *    Starting at head, skip already-matched nodes until finding
</span><span class="cm">  *    an unmatched node of opposite mode, if one exists, in which
</span><span class="cm">  *    case matching it and returning, also if necessary updating
</span><span class="cm">  *    head to one past the matched node (or the node itself if the
</span><span class="cm">  *    list has no other unmatched nodes). If the CAS misses, then
</span><span class="cm">  *    a loop retries advancing head by two steps until either
</span><span class="cm">  *    success or the slack is at most two. By requiring that each
</span><span class="cm">  *    attempt advances head by two (if applicable), we ensure that
</span><span class="cm">  *    the slack does not grow without bound. Traversals also check
</span><span class="cm">  *    if the initial head is now off-list, in which case they
</span><span class="cm">  *    start at the new head.
</span><span class="cm">  *    从head开始，跳过已匹配的节点，直到找到与模式相反的未匹配节点，如果存在，在这种情况下，匹配它并返回，
</span><span class="cm">  *    如果需要更新头到一个经过匹配的节点（或者节点本身，如果列表具有没有其他不匹配的节点）。
</span><span class="cm">  *    如果CAS未命中，则循环重试前进两步，直到成功或松弛最多为两次。
</span><span class="cm">  *    通过要求每次尝试都提前两次（如果适用），我们确保松弛不会无限制地增长。遍历还会检查最初的头是否已经不在列表中，在这种情况下，他们从新的头开始。
</span><span class="cm">  *
</span><span class="cm">  *    If no candidates are found and the call was untimed 
</span><span class="cm">  *    poll/offer, (argument &#34;how&#34; is NOW) return.
</span><span class="cm">  *    如果没有找到候选人，并且该调用是不计时的poll/offer，（参数&#34;how&#34;是NOW）返回。
</span><span class="cm">  *
</span><span class="cm">  * 2. Try to append a new node (method tryAppend) 尝试添加一个新节点(方法tryAppend)
</span><span class="cm">  *
</span><span class="cm">  *    Starting at current tail pointer, find the actual last node
</span><span class="cm">  *    and try to append a new node (or if head was null, establish
</span><span class="cm">  *    the first node). Nodes can be appended only if their
</span><span class="cm">  *    predecessors are either already matched or are of the same
</span><span class="cm">  *    mode. If we detect otherwise, then a new node with opposite
</span><span class="cm">  *    mode must have been appended during traversal, so we must
</span><span class="cm">  *    restart at phase 1. The traversal and update steps are
</span><span class="cm">  *    otherwise similar to phase 1: Retrying upon CAS misses and
</span><span class="cm">  *    checking for staleness.  In particular, if a self-link is
</span><span class="cm">  *    encountered, then we can safely jump to a node on the list
</span><span class="cm">  *    by continuing the traversal at current head.
</span><span class="cm">  *    从当前的tail指针开始，找到实际的最后一个节点，并尝试添加一个新节点(或者如果head为null，则建立第一个节点)。
</span><span class="cm">  *    如果节点已经匹配或处于相同的模式，则可以添加节点。如果我们检测到其他情况，则必须在遍历过程中追加一个具有相反模式的新节点，因此我们必须在第1阶段重新启动。
</span><span class="cm">  *    遍历和更新步骤与第1阶段类似:对CAS的重试失败和检查过时。特别地，如果遇到一个自链接，那么我们可以通过在当前head上继续遍历来安全地跳转到列表中的节点。
</span><span class="cm">  *    
</span><span class="cm">  *    On successful append, if the call was ASYNC, return.
</span><span class="cm">  *    在成功追加的上，如果调用是ASYNC，则返回。
</span><span class="cm">  *
</span><span class="cm">  * 3. Await match or cancellation (method awaitMatch) 等待匹配或取消(方法awaitMatch)
</span><span class="cm">  *
</span><span class="cm">  *    Wait for another thread to match node; instead cancelling if
</span><span class="cm">  *    the current thread was interrupted or the wait timed out. On
</span><span class="cm">  *    multiprocessors, we use front-of-queue spinning: If a node
</span><span class="cm">  *    appears to be the first unmatched node in the queue, it
</span><span class="cm">  *    spins a bit before blocking. In either case, before blocking
</span><span class="cm">  *    it tries to unsplice any nodes between the current &#34;head&#34;
</span><span class="cm">  *    and the first unmatched node.
</span><span class="cm">  *    等待另一个线程匹配节点;如果当前线程被中断或等待超时，则取消。在多处理器上，我们使用front-of-queue旋转:
</span><span class="cm">  *    如果一个节点看起来是队列中第一个不匹配的节点，它将在阻塞之前旋转一点。在任何一种情况下，在阻塞之前，它都会试图在当前的&#34;头&#34;和第一个不匹配的节点之间的任何节点上解开。
</span><span class="cm">  *
</span><span class="cm">  *    Front-of-queue spinning vastly improves performance of
</span><span class="cm">  *    heavily contended queues. And so long as it is relatively
</span><span class="cm">  *    brief and &#34;quiet&#34;, spinning does not much impact performance
</span><span class="cm">  *    of less-contended queues.  During spins threads check their
</span><span class="cm">  *    interrupt status and generate a thread-local random number
</span><span class="cm">  *    to decide to occasionally perform a Thread.yield. While
</span><span class="cm">  *    yield has underdefined specs, we assume that might it help,
</span><span class="cm">  *    and will not hurt in limiting impact of spinning on busy
</span><span class="cm">  *    systems.  We also use smaller (1/2) spins for nodes that are
</span><span class="cm">  *    not known to be front but whose predecessors have not
</span><span class="cm">  *    blocked -- these &#34;chained&#34; spins avoid artifacts of
</span><span class="cm">  *    front-of-queue rules which otherwise lead to alternating
</span><span class="cm">  *    nodes spinning vs blocking. Further, front threads that
</span><span class="cm">  *    represent phase changes (from data to request node or vice
</span><span class="cm">  *    versa) compared to their predecessors receive additional
</span><span class="cm">  *    chained spins, reflecting longer paths typically required to
</span><span class="cm">  *    unblock threads during phase changes.
</span><span class="cm">  *    Front-of-queue队列旋转极大地提高了大量争用队列的性能。只要它比较简短和&#34;quiet&#34;，旋转对排队较少的队列的性能影响不大。
</span><span class="cm">  *    在旋转线程中检查他们的中断状态并生成一个thread-local随机数来决定偶尔执行一个Thread.yield。
</span><span class="cm">  *    虽然yield 有未定义的规格，但我们认为它可能会有所帮助，而且不会影响在繁忙的系统中旋转的影响。
</span><span class="cm">  *    我们也使用较小的(1/2)的自旋为节点，这些节点不知道是前面的，但其前身没有被阻塞——这些“链”自旋避免了front-of-queue规则的工件，否则会导致交错的节点旋转vs阻塞。
</span><span class="cm">  *    此外，与他们的前辈相比，代表阶段变化的前端线程(从数据到请求节点，或者反之亦然)，会得到额外的链接自旋，这反映了在阶段变化过程中通常需要打开线程的更长的路径。
</span><span class="cm">  *    此外，表示相位变化（从数据到请求节点或反之亦然）的前线程相比于其前身接收额外的链式自旋，反映了通常在相位变化期间解锁线程所需的较长路径。
</span><span class="cm">  *    
</span><span class="cm">  * ** Unlinking removed interior nodes ** 链接删除内部节点
</span><span class="cm">  *
</span><span class="cm">  * In addition to minimizing garbage retention via self-linking
</span><span class="cm">  * described above, we also unlink removed interior nodes. These
</span><span class="cm">  * may arise due to timed out or interrupted waits, or calls to
</span><span class="cm">  * remove(x) or Iterator.remove.  Normally, given a node that was
</span><span class="cm">  * at one time known to be the predecessor of some node s that is
</span><span class="cm">  * to be removed, we can unsplice s by CASing the next field of
</span><span class="cm">  * its predecessor if it still points to s (otherwise s must
</span><span class="cm">  * already have been removed or is now offlist). But there are two
</span><span class="cm">  * situations in which we cannot guarantee to make node s
</span><span class="cm">  * unreachable in this way: (1) If s is the trailing node of list
</span><span class="cm">  * (i.e., with null next), then it is pinned as the target node
</span><span class="cm">  * for appends, so can only be removed later after other nodes are
</span><span class="cm">  * appended. (2) We cannot necessarily unlink s given a
</span><span class="cm">  * predecessor node that is matched (including the case of being
</span><span class="cm">  * cancelled): the predecessor may already be unspliced, in which
</span><span class="cm">  * case some previous reachable node may still point to s.
</span><span class="cm">  * (For further explanation see Herlihy &amp; Shavit &#34;The Art of
</span><span class="cm">  * Multiprocessor Programming&#34; chapter 9).  Although, in both
</span><span class="cm">  * cases, we can rule out the need for further action if either s
</span><span class="cm">  * or its predecessor are (or can be made to be) at, or fall off
</span><span class="cm">  * from, the head of list.
</span><span class="cm">  * 
</span><span class="cm">  * 除了通过上述自链接最小化垃圾留存之外，我们还取消了删除的内部节点的链接。这些可能是由于超时或中断等待，或调用删除（x）或Iterator.remove而引起的。
</span><span class="cm">  * 通常情况下，如果一个节点曾经被认为是要删除的某个节点的前身，那么如果它的前一个字段仍然指向s，我们就可以通过加入它的下一个字段来取消修改
</span><span class="cm">  * （否则s必须已经被删除删除或现在是offlist）。
</span><span class="cm">  * 但有两种情况我们不能保证以这种方式使节点不可达：
</span><span class="cm">  *   （1）如果s是列表的尾节点（即下一个为空），那么它被固定为附加的目标节点，所以只能在其他节点附加后才能删除。 
</span><span class="cm">  *   （2）给定一个匹配的前驱节点（包 ），我们不一定解除链接：前驱可能已经是未被剪接的，在这种情况下，前一个可到达节点可能仍然指向s。 
</span><span class="cm">  *   
</span><span class="cm">  *   （进一步的解释见Herlihy＆Shavit&#34;多处理器编程的艺术&#34;第9章）。虽然在这两种情况下，如果任何一方或其前任（或可以被制造）处于或脱离名单的首位，
</span><span class="cm">  *   我们可以排除进一步采取行动的必要性。
</span><span class="cm">  * 
</span><span class="cm">  * Without taking these into account, it would be possible for an
</span><span class="cm">  * unbounded number of supposedly removed nodes to remain
</span><span class="cm">  * reachable.  Situations leading to such buildup are uncommon but
</span><span class="cm">  * can occur in practice; for example when a series of short timed
</span><span class="cm">  * calls to poll repeatedly time out but never otherwise fall off
</span><span class="cm">  * the list because of an untimed call to take at the front of the
</span><span class="cm">  * queue.
</span><span class="cm">  * 
</span><span class="cm">  * 如果不考虑这些因素，那么可能会有无数的假定被删除的节点保持可达状态。导致这种积聚的情况是不常见的，但可以在实践中发生;
</span><span class="cm">  * 例如，当一系列短时间调用重复轮询时间超时，但是由于在队列前面进行不计时的调用，从不会以其他方式脱离列表
</span><span class="cm">  *
</span><span class="cm">  * When these cases arise, rather than always retraversing the
</span><span class="cm">  * entire list to find an actual predecessor to unlink (which
</span><span class="cm">  * won&#39;t help for case (1) anyway), we record a conservative
</span><span class="cm">  * estimate of possible unsplice failures (in &#34;sweepVotes&#34;).
</span><span class="cm">  * We trigger a full sweep when the estimate exceeds a threshold
</span><span class="cm">  * (&#34;SWEEP_THRESHOLD&#34;) indicating the maximum number of estimated
</span><span class="cm">  * removal failures to tolerate before sweeping through, unlinking
</span><span class="cm">  * cancelled nodes that were not unlinked upon initial removal.
</span><span class="cm">  * We perform sweeps by the thread hitting threshold (rather than
</span><span class="cm">  * background threads or by spreading work to other threads)
</span><span class="cm">  * because in the main contexts in which removal occurs, the
</span><span class="cm">  * caller is already timed-out, cancelled, or performing a
</span><span class="cm">  * potentially O(n) operation (e.g. remove(x)), none of which are
</span><span class="cm">  * time-critical enough to warrant the overhead that alternatives
</span><span class="cm">  * would impose on other threads.
</span><span class="cm">  * 
</span><span class="cm">  * 当出现这些情况时，我们不是总是回顾整个列表以找到一个实际的前任解除联系（对于情况（1）无助于此），
</span><span class="cm">  * 我们记录保守估计的可能的失败失败（在&#34;sweepVotes&#34;中）。当估计值超过阈值（&#34;SWEEP_THRESHOLD&#34;）时，
</span><span class="cm">  * 我们会触发完全扫描，指示在扫描之前允许的最大移除失败次数的最大值，取消初始移除时取消关联的取消节点。
</span><span class="cm">  * 我们通过线程触发阈值（而不是后台线程或将工作分散到其他线程）执行扫描，因为在发生删除的主要上下文中，
</span><span class="cm">  * 调用者已经超时，取消或执行潜在的O（n）操作（例如remove（x）），其中没有一个对时间要求太高，不足以保证备选方案会对其他线程施加的开销。
</span><span class="cm">  *
</span><span class="cm">  * Because the sweepVotes estimate is conservative, and because
</span><span class="cm">  * nodes become unlinked &#34;naturally&#34; as they fall off the head of
</span><span class="cm">  * the queue, and because we allow votes to accumulate even while
</span><span class="cm">  * sweeps are in progress, there are typically significantly fewer
</span><span class="cm">  * such nodes than estimated.  Choice of a threshold value
</span><span class="cm">  * balances the likelihood of wasted effort and contention, versus
</span><span class="cm">  * providing a worst-case bound on retention of interior nodes in
</span><span class="cm">  * quiescent queues. The value defined below was chosen
</span><span class="cm">  * empirically to balance these under various timeout scenarios.
</span><span class="cm">  *  由于清除投票的估计是保守的，并且由于节点脱离队列头部而&#34;自然地&#34;断开连接，并且因为即使在扫描正在进行时我们也允许投票累计，所以通常显着少于估计的节点。
</span><span class="cm">  *  阈值的选择平衡了浪费的努力和争用的可能性，而不是在静止队列中保留内部节点的最坏情况。下面定义的值是根据经验选择的，以在各种超时情况下平衡这些值。
</span><span class="cm">  * 
</span><span class="cm">  *
</span><span class="cm">  * Note that we cannot self-link unlinked interior nodes during
</span><span class="cm">  * sweeps. However, the associated garbage chains terminate when
</span><span class="cm">  * some successor ultimately falls off the head of the list and is
</span><span class="cm">  * self-linked.
</span><span class="cm">  * 请注意，在扫描期间，我们不能自行链接未连接的内部节点。然而，当一些后继者最终脱离列表头并且是自联系的时，相关的垃圾链终止。
</span><span class="cm">  */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="o">-</span><span class="n">3223113410248163686L</span><span class="o">;</span>
    <span class="cm">/** True if on multiprocessor  如果在多处理器上，则为真*/</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="n">MP</span> <span class="o">=</span>
        <span class="n">Runtime</span><span class="o">.</span><span class="na">getRuntime</span><span class="o">().</span><span class="na">availableProcessors</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">1</span><span class="o">;</span>

    <span class="cm">/**
</span><span class="cm">     * The number of times to spin (with randomly interspersed calls
</span><span class="cm">     * to Thread.yield) on multiprocessor before blocking when a node
</span><span class="cm">     * is apparently the first waiter in the queue.  See above for
</span><span class="cm">     * explanation. Must be a power of two. The value is empirically
</span><span class="cm">     * derived -- it works pretty well across a variety of processors,
</span><span class="cm">     * numbers of CPUs, and OSes.
</span><span class="cm">     * 当一个节点显然是队列中的第一个waiter时，在阻塞之前对多处理器进行旋转的次数（对Thread.yield进行随机散布的调用）。请参阅上面的解释。必须是2的幂。
</span><span class="cm">     * 这个值是凭经验推导出来的 - 在各种处理器，CPU数量和操作系统上都能很好地工作。
</span><span class="cm">     * 
</span><span class="cm">     * 自旋次数
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">FRONT_SPINS</span>   <span class="o">=</span> <span class="n">1</span> <span class="o">&lt;&lt;</span> <span class="n">7</span><span class="o">;</span>

    <span class="cm">/**
</span><span class="cm">     * The number of times to spin before blocking when a node is
</span><span class="cm">     * preceded by another node that is apparently spinning.  Also
</span><span class="cm">     * serves as an increment to FRONT_SPINS on phase changes, and as
</span><span class="cm">     * base average frequency for yielding during spins. Must be a
</span><span class="cm">     * power of two.
</span><span class="cm">     * 当一个节点位于另一个明显旋转的节点的前面时，在阻塞之前旋转的次数。也用作相位变化的FRONT_SPINS增量，以及旋转期间的屈服平均频率。必须是2的幂。
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">CHAINED_SPINS</span> <span class="o">=</span> <span class="n">FRONT_SPINS</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">1</span><span class="o">;</span>

    <span class="cm">/**
</span><span class="cm">     * The maximum number of estimated removal failures (sweepVotes)
</span><span class="cm">     * to tolerate before sweeping through the queue unlinking
</span><span class="cm">     * cancelled nodes that were not unlinked upon initial
</span><span class="cm">     * removal. See above for explanation. The value must be at least
</span><span class="cm">     * two to avoid useless sweeps when removing trailing nodes.
</span><span class="cm">     * 在清除整个队列之前，可以容忍的最大清除失败次数（sweepVote）取消链接已取消的节点，这些节点在初始删除时并未解除链接。
</span><span class="cm">     * 请参阅上面的解释。删除尾随节点时，该值必须至少为2以避免无用的扫描。
</span><span class="cm">     */</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">SWEEP_THRESHOLD</span> <span class="o">=</span> <span class="n">32</span><span class="o">;</span>
    <span class="cm">/** head of the queue; null until first enqueue */</span>
    <span class="c1">//头节点
</span><span class="c1"></span>    <span class="kd">transient</span> <span class="kd">volatile</span> <span class="n">Node</span> <span class="n">head</span><span class="o">;</span>

    <span class="cm">/** tail of the queue; null until first append */</span>
    <span class="c1">//尾节点
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">transient</span> <span class="kd">volatile</span> <span class="n">Node</span> <span class="n">tail</span><span class="o">;</span>

    <span class="cm">/** The number of apparent failures to unsplice removed nodes */</span>
    <span class="c1">//清除删除节点的明显故障数
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">transient</span> <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">sweepVotes</span><span class="o">;</span>

    <span class="c1">// CAS methods for fields
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">casTail</span><span class="o">(</span><span class="n">Node</span> <span class="n">cmp</span><span class="o">,</span> <span class="n">Node</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapObject</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">tailOffset</span><span class="o">,</span> <span class="n">cmp</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">casHead</span><span class="o">(</span><span class="n">Node</span> <span class="n">cmp</span><span class="o">,</span> <span class="n">Node</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapObject</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">headOffset</span><span class="o">,</span> <span class="n">cmp</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">casSweepVotes</span><span class="o">(</span><span class="kt">int</span> <span class="n">cmp</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapInt</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">sweepVotesOffset</span><span class="o">,</span> <span class="n">cmp</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
</span><span class="cm">     * Creates an initially empty {@code LinkedTransferQueue}.
</span><span class="cm">     */</span>
    <span class="kd">public</span> <span class="nf">LinkedTransferQueue</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="cm">/**
</span><span class="cm">     * Creates a {@code LinkedTransferQueue}
</span><span class="cm">     * initially containing the elements of the given collection,
</span><span class="cm">     * added in traversal order of the collection&#39;s iterator.
</span><span class="cm">     *
</span><span class="cm">     * @param c the collection of elements to initially contain
</span><span class="cm">     * @throws NullPointerException if the specified collection or any
</span><span class="cm">     *         of its elements are null
</span><span class="cm">     */</span>
    <span class="kd">public</span> <span class="nf">LinkedTransferQueue</span><span class="o">(</span><span class="n">Collection</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">E</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">();</span>
        <span class="n">addAll</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
    <span class="o">}</span>

 <span class="c1">// Unsafe mechanics
</span><span class="c1"></span>
 <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">sun</span><span class="o">.</span><span class="na">misc</span><span class="o">.</span><span class="na">Unsafe</span> <span class="n">UNSAFE</span><span class="o">;</span>
 <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">headOffset</span><span class="o">;</span>
 <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">tailOffset</span><span class="o">;</span>
 <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">sweepVotesOffset</span><span class="o">;</span>
 <span class="kd">static</span> <span class="o">{</span>
     <span class="k">try</span> <span class="o">{</span>
         <span class="n">UNSAFE</span> <span class="o">=</span> <span class="n">sun</span><span class="o">.</span><span class="na">misc</span><span class="o">.</span><span class="na">Unsafe</span><span class="o">.</span><span class="na">getUnsafe</span><span class="o">();</span>
         <span class="n">Class</span> <span class="n">k</span> <span class="o">=</span> <span class="n">LinkedTransferQueue</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
         <span class="n">headOffset</span> <span class="o">=</span> <span class="n">UNSAFE</span><span class="o">.</span><span class="na">objectFieldOffset</span>
             <span class="o">(</span><span class="n">k</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">&#34;head&#34;</span><span class="o">));</span>
         <span class="n">tailOffset</span> <span class="o">=</span> <span class="n">UNSAFE</span><span class="o">.</span><span class="na">objectFieldOffset</span>
             <span class="o">(</span><span class="n">k</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">&#34;tail&#34;</span><span class="o">));</span>
         <span class="n">sweepVotesOffset</span> <span class="o">=</span> <span class="n">UNSAFE</span><span class="o">.</span><span class="na">objectFieldOffset</span>
             <span class="o">(</span><span class="n">k</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">&#34;sweepVotes&#34;</span><span class="o">));</span>
     <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
         <span class="k">throw</span> <span class="k">new</span> <span class="n">Error</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
     <span class="o">}</span>
 <span class="o">}</span>
 <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="3-linkedtransferqueue实现transferqueue接口">3. LinkedTransferQueue实现TransferQueue接口</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span><span class="lnt">95
</span><span class="lnt">96
</span><span class="lnt">97
</span><span class="lnt">98
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">TransferQueue</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">BlockingQueue</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="cm">/**
</span><span class="cm">     * Transfers the element to a waiting consumer immediately, if possible.
</span><span class="cm">     * 立即转交一个元素给消费者，如果此时队列没有消费者，那就false
</span><span class="cm">     * 
</span><span class="cm">     * &lt;p&gt;More precisely, transfers the specified element immediately
</span><span class="cm">     * if there exists a consumer already waiting to receive it (in
</span><span class="cm">     * {@link #take} or timed {@link #poll(long,TimeUnit) poll}),
</span><span class="cm">     * otherwise returning {@code false} without enqueuing the element.
</span><span class="cm">     *
</span><span class="cm">     * @param e the element to transfer
</span><span class="cm">     * @return {@code true} if the element was transferred, else
</span><span class="cm">     *         {@code false}
</span><span class="cm">     * @throws ClassCastException if the class of the specified element
</span><span class="cm">     *         prevents it from being added to this queue
</span><span class="cm">     * @throws NullPointerException if the specified element is null
</span><span class="cm">     * @throws IllegalArgumentException if some property of the specified
</span><span class="cm">     *         element prevents it from being added to this queue
</span><span class="cm">     */</span>
    <span class="kt">boolean</span> <span class="nf">tryTransfer</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">);</span>

    <span class="cm">/**
</span><span class="cm">     * Transfers the element to a consumer, waiting if necessary to do so.
</span><span class="cm">     * 转交一个元素给消费者，如果此时队列没有消费者，那就阻塞
</span><span class="cm">     *
</span><span class="cm">     * &lt;p&gt;More precisely, transfers the specified element immediately
</span><span class="cm">     * if there exists a consumer already waiting to receive it (in
</span><span class="cm">     * {@link #take} or timed {@link #poll(long,TimeUnit) poll}),
</span><span class="cm">     * else waits until the element is received by a consumer.
</span><span class="cm">     *
</span><span class="cm">     * @param e the element to transfer
</span><span class="cm">     * @throws InterruptedException if interrupted while waiting,
</span><span class="cm">     *         in which case the element is not left enqueued
</span><span class="cm">     * @throws ClassCastException if the class of the specified element
</span><span class="cm">     *         prevents it from being added to this queue
</span><span class="cm">     * @throws NullPointerException if the specified element is null
</span><span class="cm">     * @throws IllegalArgumentException if some property of the specified
</span><span class="cm">     *         element prevents it from being added to this queue
</span><span class="cm">     */</span>
    <span class="kt">void</span> <span class="nf">transfer</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span><span class="o">;</span>

    <span class="cm">/**
</span><span class="cm">     * Transfers the element to a consumer if it is possible to do so
</span><span class="cm">     * before the timeout elapses.
</span><span class="cm">     * 如果在超时之前可以这样做，将元素转移给消费者。
</span><span class="cm">     * &lt;p&gt;More precisely, transfers the specified element immediately
</span><span class="cm">     * if there exists a consumer already waiting to receive it (in
</span><span class="cm">     * {@link #take} or timed {@link #poll(long,TimeUnit) poll}),
</span><span class="cm">     * else waits until the element is received by a consumer,
</span><span class="cm">     * returning {@code false} if the specified wait time elapses
</span><span class="cm">     * before the element can be transferred.
</span><span class="cm">     *
</span><span class="cm">     * @param e the element to transfer
</span><span class="cm">     * @param timeout how long to wait before giving up, in units of
</span><span class="cm">     *        {@code unit}
</span><span class="cm">     * @param unit a {@code TimeUnit} determining how to interpret the
</span><span class="cm">     *        {@code timeout} parameter
</span><span class="cm">     * @return {@code true} if successful, or {@code false} if
</span><span class="cm">     *         the specified waiting time elapses before completion,
</span><span class="cm">     *         in which case the element is not left enqueued
</span><span class="cm">     * @throws InterruptedException if interrupted while waiting,
</span><span class="cm">     *         in which case the element is not left enqueued
</span><span class="cm">     * @throws ClassCastException if the class of the specified element
</span><span class="cm">     *         prevents it from being added to this queue
</span><span class="cm">     * @throws NullPointerException if the specified element is null
</span><span class="cm">     * @throws IllegalArgumentException if some property of the specified
</span><span class="cm">     *         element prevents it from being added to this queue
</span><span class="cm">     */</span>
    <span class="kt">boolean</span> <span class="nf">tryTransfer</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">,</span> <span class="kt">long</span> <span class="n">timeout</span><span class="o">,</span> <span class="n">TimeUnit</span> <span class="n">unit</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="n">InterruptedException</span><span class="o">;</span>

    <span class="cm">/**
</span><span class="cm">     * Returns {@code true} if there is at least one consumer waiting
</span><span class="cm">     * to receive an element via {@link #take} or
</span><span class="cm">     * timed {@link #poll(long,TimeUnit) poll}.
</span><span class="cm">     * The return value represents a momentary state of affairs.
</span><span class="cm">     * 是否有消费者等待接收数据，瞬时状态，不一定准
</span><span class="cm">     * @return {@code true} if there is at least one waiting consumer
</span><span class="cm">     */</span>
    <span class="kt">boolean</span> <span class="nf">hasWaitingConsumer</span><span class="o">();</span>

    <span class="cm">/**
</span><span class="cm">     * Returns an estimate of the number of consumers waiting to
</span><span class="cm">     * receive elements via {@link #take} or timed
</span><span class="cm">     * {@link #poll(long,TimeUnit) poll}.  The return value is an
</span><span class="cm">     * approximation of a momentary state of affairs, that may be
</span><span class="cm">     * inaccurate if consumers have completed or given up waiting.
</span><span class="cm">     * The value may be useful for monitoring and heuristics, but
</span><span class="cm">     * not for synchronization control.  Implementations of this
</span><span class="cm">     * method are likely to be noticeably slower than those for
</span><span class="cm">     * {@link #hasWaitingConsumer}.
</span><span class="cm">     *  返回还有多少个等待的消费者，跟上面那个一样，都是一种瞬时状态，不一定准
</span><span class="cm">     *
</span><span class="cm">     * @return the number of consumers waiting to receive elements
</span><span class="cm">     */</span>
    <span class="kt">int</span> <span class="nf">getWaitingConsumerCount</span><span class="o">();</span>
<span class="o">}</span>

</code></pre></td></tr></table>
</div>
</div><h2 id="二xfer-linkedtransferqueue核心方法">二、xfer LinkedTransferQueue核心方法</h2>
<p>put和take等都调用这个方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"> <span class="cm">/*
</span><span class="cm">     * Possible values for &#34;how&#34; argument in xfer method.
</span><span class="cm">     * xfer方法中的“how”参数的可能值。
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">NOW</span>   <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="c1">// for untimed poll, tryTransfer
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">ASYNC</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="c1">// for offer, put, add
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">SYNC</span>  <span class="o">=</span> <span class="n">2</span><span class="o">;</span> <span class="c1">// for transfer, take
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">TIMED</span> <span class="o">=</span> <span class="n">3</span><span class="o">;</span> <span class="c1">// for timed poll,timed tryTransfer
</span><span class="c1"></span>
    <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;unchecked&#34;</span><span class="o">)</span>
    <span class="kd">static</span> <span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">E</span> <span class="nf">cast</span><span class="o">(</span><span class="n">Object</span> <span class="n">item</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// assert item == null || item.getClass() != Node.class;
</span><span class="c1"></span>        <span class="k">return</span> <span class="o">(</span><span class="n">E</span><span class="o">)</span> <span class="n">item</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
</span><span class="cm">     * Implements all queuing methods. See above for explanation.
</span><span class="cm">     *
</span><span class="cm">     * @param e the item or null for take
</span><span class="cm">     * @param haveData true if this is a put, else a take
</span><span class="cm">     * @param how NOW, ASYNC, SYNC, or TIMED
</span><span class="cm">     * @param nanos timeout in nanosecs, used only if mode is TIMED
</span><span class="cm">     * @return an item if matched, else e
</span><span class="cm">     * @throws NullPointerException if haveData mode but e is null
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="n">E</span> <span class="nf">xfer</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">haveData</span><span class="o">,</span> <span class="kt">int</span> <span class="n">how</span><span class="o">,</span> <span class="kt">long</span> <span class="n">nanos</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">haveData</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">e</span> <span class="o">==</span> <span class="kc">null</span><span class="o">))</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">NullPointerException</span><span class="o">();</span>
        <span class="n">Node</span> <span class="n">s</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>                        <span class="c1">// the node to append, if needed
</span><span class="c1"></span><span class="nl">
</span><span class="nl">        retry:</span>
        <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>                            <span class="c1">// restart on append race
</span><span class="c1"></span>
            <span class="k">for</span> <span class="o">(</span><span class="n">Node</span> <span class="n">h</span> <span class="o">=</span> <span class="n">head</span><span class="o">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">h</span><span class="o">;</span> <span class="n">p</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;)</span> <span class="o">{</span> <span class="c1">// find &amp; match first node  查找&amp;匹配第一个节点
</span><span class="c1"></span>                <span class="kt">boolean</span> <span class="n">isData</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">isData</span><span class="o">;</span>
                <span class="n">Object</span> <span class="n">item</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">item</span> <span class="o">!=</span> <span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">item</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">==</span> <span class="n">isData</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// unmatched    不相配
</span><span class="c1"></span>                    <span class="k">if</span> <span class="o">(</span><span class="n">isData</span> <span class="o">==</span> <span class="n">haveData</span><span class="o">)</span>   <span class="c1">// can&#39;t match 不能匹配
</span><span class="c1"></span>                        <span class="k">break</span><span class="o">;</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">casItem</span><span class="o">(</span><span class="n">item</span><span class="o">,</span> <span class="n">e</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// match 匹配成功
</span><span class="c1"></span>                        <span class="k">for</span> <span class="o">(</span><span class="n">Node</span> <span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span> <span class="n">q</span> <span class="o">!=</span> <span class="n">h</span><span class="o">;)</span> <span class="o">{</span>   <span class="c1">// 松弛一次进行for 循环
</span><span class="c1"></span>                            <span class="n">Node</span> <span class="n">n</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>  <span class="c1">// update by 2 unless singleton
</span><span class="c1"></span>                            <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="n">h</span> <span class="o">&amp;&amp;</span> <span class="n">casHead</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">n</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">q</span> <span class="o">:</span> <span class="n">n</span><span class="o">))</span> <span class="o">{</span> <span class="c1">//如果CAS未命中，则循环重试前进两步，直到成功或松弛最多为两次。
</span><span class="c1"></span>                                <span class="n">h</span><span class="o">.</span><span class="na">forgetNext</span><span class="o">();</span>
                                <span class="k">break</span><span class="o">;</span>
                            <span class="o">}</span>                 <span class="c1">// advance and retry
</span><span class="c1"></span>                            <span class="k">if</span> <span class="o">((</span><span class="n">h</span> <span class="o">=</span> <span class="n">head</span><span class="o">)</span>   <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span>
                                <span class="o">(</span><span class="n">q</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">q</span><span class="o">.</span><span class="na">isMatched</span><span class="o">())</span>
                                <span class="k">break</span><span class="o">;</span>        <span class="c1">// unless slack &lt; 2   除非松弛小于2
</span><span class="c1"></span>                        <span class="o">}</span>
                        <span class="n">LockSupport</span><span class="o">.</span><span class="na">unpark</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">waiter</span><span class="o">);</span>
                        <span class="k">return</span> <span class="k">this</span><span class="o">.&lt;</span><span class="n">E</span><span class="o">&gt;</span><span class="n">cast</span><span class="o">(</span><span class="n">item</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="n">Node</span> <span class="n">n</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="n">p</span> <span class="o">=</span> <span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">n</span><span class="o">)</span> <span class="o">?</span> <span class="n">n</span> <span class="o">:</span> <span class="o">(</span><span class="n">h</span> <span class="o">=</span> <span class="n">head</span><span class="o">);</span> <span class="c1">// Use head if p offlist
</span><span class="c1"></span>            <span class="o">}</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">how</span> <span class="o">!=</span> <span class="n">NOW</span><span class="o">)</span> <span class="o">{</span>                 <span class="c1">// No matches available
</span><span class="c1"></span>                <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">haveData</span><span class="o">);</span>
                <span class="n">Node</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">tryAppend</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">haveData</span><span class="o">);</span>  <span class="c1">//尝试将节点s作为tail。
</span><span class="c1"></span>                <span class="k">if</span> <span class="o">(</span><span class="n">pred</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="k">continue</span> <span class="n">retry</span><span class="o">;</span>           <span class="c1">// lost race vs opposite mode
</span><span class="c1"></span>                <span class="k">if</span> <span class="o">(</span><span class="n">how</span> <span class="o">!=</span> <span class="n">ASYNC</span><span class="o">)</span>
                    <span class="k">return</span> <span class="n">awaitMatch</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">pred</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="o">(</span><span class="n">how</span> <span class="o">==</span> <span class="n">TIMED</span><span class="o">),</span> <span class="n">nanos</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">e</span><span class="o">;</span> <span class="c1">// not waiting
</span><span class="c1"></span>        <span class="o">}</span>
    <span class="o">}</span>
    <span class="cm">/**
</span><span class="cm">     * Tries to append node s as tail.
</span><span class="cm">     * 尝试将节点s作为tail。
</span><span class="cm">     * @param s the node to append
</span><span class="cm">     * @param haveData true if appending in data mode
</span><span class="cm">     * @return null on failure due to losing race with append in
</span><span class="cm">     * different mode, else s&#39;s predecessor, or s itself if no
</span><span class="cm">     * predecessor
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="n">Node</span> <span class="nf">tryAppend</span><span class="o">(</span><span class="n">Node</span> <span class="n">s</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">haveData</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Node</span> <span class="n">t</span> <span class="o">=</span> <span class="n">tail</span><span class="o">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">t</span><span class="o">;;)</span> <span class="o">{</span>        <span class="c1">// move p to last node and append  将p移动到最后一个节点并追加
</span><span class="c1"></span>            <span class="n">Node</span> <span class="n">n</span><span class="o">,</span> <span class="n">u</span><span class="o">;</span>                        <span class="c1">// temps for reads of next &amp; tail
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 第一次调用
</span><span class="c1"></span>                <span class="k">if</span> <span class="o">(</span><span class="n">casHead</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="n">s</span><span class="o">))</span>
                    <span class="k">return</span> <span class="n">s</span><span class="o">;</span>                 <span class="c1">// initialize 初始化
</span><span class="c1"></span>            <span class="o">}</span>
            <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">cannotPrecede</span><span class="o">(</span><span class="n">haveData</span><span class="o">))</span>    <span class="c1">//不匹配isData,这里匹配相反模式,重新遍历,
</span><span class="c1"></span>                <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>                  <span class="c1">// lost race vs opposite mode 
</span><span class="c1"></span>            <span class="k">else</span> <span class="k">if</span> <span class="o">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>    <span class="c1">// not last; keep traversing    tail没更新，松弛
</span><span class="c1"></span>                <span class="n">p</span> <span class="o">=</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">t</span> <span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">!=</span> <span class="o">(</span><span class="n">u</span> <span class="o">=</span> <span class="n">tail</span><span class="o">)</span> <span class="o">?</span> <span class="o">(</span><span class="n">t</span> <span class="o">=</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="c1">// stale tail       以前tail数据  p != t &amp;&amp; t != (u = tail) ？tail被其他线程修改过，这里重新赋值tail
</span><span class="c1"></span>                    <span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">n</span><span class="o">)</span> <span class="o">?</span> <span class="n">n</span> <span class="o">:</span> <span class="kc">null</span><span class="o">;</span>      <span class="c1">// restart if off list          p != n 判断该节点是否取消或者出队列
</span><span class="c1"></span>            <span class="k">else</span> <span class="k">if</span> <span class="o">(!</span><span class="n">p</span><span class="o">.</span><span class="na">casNext</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="n">s</span><span class="o">))</span>      <span class="c1">//更新next值
</span><span class="c1"></span>                <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>                   <span class="c1">// re-read on CAS failure       cas更新失败，重新read
</span><span class="c1"></span>            <span class="k">else</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>                 <span class="c1">// update if slack now &gt;= 2     松弛大于2
</span><span class="c1"></span>                    <span class="k">while</span> <span class="o">((</span><span class="n">tail</span> <span class="o">!=</span> <span class="n">t</span> <span class="o">||</span> <span class="o">!</span><span class="n">casTail</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">s</span><span class="o">))</span> <span class="o">&amp;&amp;</span>                   <span class="n">更新tail</span>
                           <span class="o">(</span><span class="n">t</span> <span class="o">=</span> <span class="n">tail</span><span class="o">)</span>   <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span>
                           <span class="o">(</span><span class="n">s</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="c1">// advance and retry
</span><span class="c1"></span>                           <span class="o">(</span><span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">t</span><span class="o">);</span>                  <span class="c1">//判断tail更新松弛在2里面
</span><span class="c1"></span>                <span class="o">}</span>
                <span class="k">return</span> <span class="n">p</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/**
</span><span class="cm">     * Spins/yields/blocks until node s is matched or caller gives up.
</span><span class="cm">     *
</span><span class="cm">     * @param s the waiting node
</span><span class="cm">     * @param pred the predecessor of s, or s itself if it has no
</span><span class="cm">     * predecessor, or null if unknown (the null case does not occur
</span><span class="cm">     * in any current calls but may in possible future extensions)
</span><span class="cm">     * @param e the comparison value for checking match
</span><span class="cm">     * @param timed if true, wait only until timeout elapses
</span><span class="cm">     * @param nanos timeout in nanosecs, used only if timed is true
</span><span class="cm">     * @return matched item, or e if unmatched on interrupt or timeout
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="n">E</span> <span class="nf">awaitMatch</span><span class="o">(</span><span class="n">Node</span> <span class="n">s</span><span class="o">,</span> <span class="n">Node</span> <span class="n">pred</span><span class="o">,</span> <span class="n">E</span> <span class="n">e</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">timed</span><span class="o">,</span> <span class="kt">long</span> <span class="n">nanos</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">lastTime</span> <span class="o">=</span> <span class="n">timed</span> <span class="o">?</span> <span class="n">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">()</span> <span class="o">:</span> <span class="n">0L</span><span class="o">;</span>
        <span class="n">Thread</span> <span class="n">w</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">spins</span> <span class="o">=</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span> <span class="c1">// initialized after first item and cancel checks
</span><span class="c1"></span>        <span class="n">ThreadLocalRandom</span> <span class="n">randomYields</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// bound if needed
</span><span class="c1"></span>
        <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
            <span class="n">Object</span> <span class="n">item</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">item</span> <span class="o">!=</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>                  <span class="c1">// matched
</span><span class="c1"></span>                <span class="c1">// assert item != s;
</span><span class="c1"></span>                <span class="n">s</span><span class="o">.</span><span class="na">forgetContents</span><span class="o">();</span>           <span class="c1">// avoid garbage
</span><span class="c1"></span>                <span class="k">return</span> <span class="k">this</span><span class="o">.&lt;</span><span class="n">E</span><span class="o">&gt;</span><span class="n">cast</span><span class="o">(</span><span class="n">item</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">w</span><span class="o">.</span><span class="na">isInterrupted</span><span class="o">()</span> <span class="o">||</span> <span class="o">(</span><span class="n">timed</span> <span class="o">&amp;&amp;</span> <span class="n">nanos</span> <span class="o">&lt;=</span> <span class="n">0</span><span class="o">))</span> <span class="o">&amp;&amp;</span>
                    <span class="n">s</span><span class="o">.</span><span class="na">casItem</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">s</span><span class="o">))</span> <span class="o">{</span>        <span class="c1">// cancel      取消操作
</span><span class="c1"></span>                <span class="n">unsplice</span><span class="o">(</span><span class="n">pred</span><span class="o">,</span> <span class="n">s</span><span class="o">);</span>
                <span class="k">return</span> <span class="n">e</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">spins</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>                  <span class="c1">// establish spins at/near front   自旋 
</span><span class="c1"></span>                <span class="k">if</span> <span class="o">((</span><span class="n">spins</span> <span class="o">=</span> <span class="n">spinsFor</span><span class="o">(</span><span class="n">pred</span><span class="o">,</span> <span class="n">s</span><span class="o">.</span><span class="na">isData</span><span class="o">))</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span>
                    <span class="n">randomYields</span> <span class="o">=</span> <span class="n">ThreadLocalRandom</span><span class="o">.</span><span class="na">current</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">spins</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>             <span class="c1">// spin
</span><span class="c1"></span>                <span class="o">--</span><span class="n">spins</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">randomYields</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="n">CHAINED_SPINS</span><span class="o">)</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span>
                    <span class="n">Thread</span><span class="o">.</span><span class="na">yield</span><span class="o">();</span>           <span class="c1">// occasionally yield
</span><span class="c1"></span>            <span class="o">}</span>
            <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">waiter</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">s</span><span class="o">.</span><span class="na">waiter</span> <span class="o">=</span> <span class="n">w</span><span class="o">;</span>                 <span class="c1">// request unpark then recheck
</span><span class="c1"></span>            <span class="o">}</span>
            <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">timed</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">();</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">nanos</span> <span class="o">-=</span> <span class="n">now</span> <span class="o">-</span> <span class="n">lastTime</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span>
                    <span class="n">LockSupport</span><span class="o">.</span><span class="na">parkNanos</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">nanos</span><span class="o">);</span>
                <span class="n">lastTime</span> <span class="o">=</span> <span class="n">now</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="n">LockSupport</span><span class="o">.</span><span class="na">park</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/**
</span><span class="cm">     * Returns spin/yield value for a node with given predecessor and
</span><span class="cm">     * data mode. See above for explanation.
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">spinsFor</span><span class="o">(</span><span class="n">Node</span> <span class="n">pred</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">haveData</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">MP</span> <span class="o">&amp;&amp;</span> <span class="n">pred</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>                                 <span class="c1">//前提多核cpu
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">pred</span><span class="o">.</span><span class="na">isData</span> <span class="o">!=</span> <span class="n">haveData</span><span class="o">)</span>      <span class="c1">// phase change      模式不相同
</span><span class="c1"></span>                <span class="k">return</span> <span class="n">FRONT_SPINS</span> <span class="o">+</span> <span class="n">CHAINED_SPINS</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">pred</span><span class="o">.</span><span class="na">isMatched</span><span class="o">())</span>             <span class="c1">// probably at front  
</span><span class="c1"></span>                <span class="k">return</span> <span class="n">FRONT_SPINS</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">pred</span><span class="o">.</span><span class="na">waiter</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>          <span class="c1">// pred apparently spinning
</span><span class="c1"></span>                <span class="k">return</span> <span class="n">CHAINED_SPINS</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">0</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="二入队">二、入队</h2>
<h3 id="1-offer方法">1. offer方法</h3>
<ul>
<li>offer(E e)</li>
<li>offer(E e, long timeout, TimeUnit unit) 跟offer(E e)实现一样，没有实现等待时间</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">    <span class="cm">/**
</span><span class="cm">     * Inserts the specified element at the tail of this queue.
</span><span class="cm">     * As the queue is unbounded, this method will never return {@code false}.
</span><span class="cm">     *
</span><span class="cm">     * @return {@code true} (as specified by {@link Queue#offer})
</span><span class="cm">     * @throws NullPointerException if the specified element is null
</span><span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">offer</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">xfer</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="n">ASYNC</span><span class="o">,</span> <span class="n">0</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="cm">/**
</span><span class="cm">     * Inserts the specified element at the tail of this queue.
</span><span class="cm">     * As the queue is unbounded, this method will never block or
</span><span class="cm">     * return {@code false}.
</span><span class="cm">     *
</span><span class="cm">     * @return {@code true} (as specified by
</span><span class="cm">     *  {@link BlockingQueue#offer(Object,long,TimeUnit) BlockingQueue.offer})
</span><span class="cm">     * @throws NullPointerException if the specified element is null
</span><span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">offer</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">,</span> <span class="kt">long</span> <span class="n">timeout</span><span class="o">,</span> <span class="n">TimeUnit</span> <span class="n">unit</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">xfer</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="n">ASYNC</span><span class="o">,</span> <span class="n">0</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>    
</code></pre></td></tr></table>
</div>
</div><h3 id="2-add方法">2. add方法</h3>
<p>add(E e) 无界堵塞队列 不支持throw IllegalStateException异常</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">    <span class="cm">/**
</span><span class="cm">     * Inserts the specified element at the tail of this queue.
</span><span class="cm">     * As the queue is unbounded, this method will never throw
</span><span class="cm">     * {@link IllegalStateException} or return {@code false}.
</span><span class="cm">     *
</span><span class="cm">     * @return {@code true} (as specified by {@link Collection#add})
</span><span class="cm">     * @throws NullPointerException if the specified element is null
</span><span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">xfer</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="n">ASYNC</span><span class="o">,</span> <span class="n">0</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="3-put方法">3. put方法</h3>
<ul>
<li>将指定的元素插入到这个延迟队列中。由于队列是无限的，此方法将永不阻塞。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">   <span class="cm">/**
</span><span class="cm">     * Inserts the specified element at the tail of this queue.
</span><span class="cm">     * As the queue is unbounded, this method will never block.
</span><span class="cm">     *
</span><span class="cm">     * @throws NullPointerException if the specified element is null
</span><span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">xfer</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="n">ASYNC</span><span class="o">,</span> <span class="n">0</span><span class="o">);</span>
    <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="三出队">三、出队</h2>
<h3 id="1-poll方法">1. poll方法</h3>
<ul>
<li>poll() 获取并移除此队列的头，如果此队列为空，则返回 null</li>
<li>E poll(long timeout, TimeUnit unit) 获取并移除此队列的头部，队列为空时，在指定的等待时间前等待可用的元素。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">    <span class="kd">public</span> <span class="n">E</span> <span class="nf">poll</span><span class="o">(</span><span class="kt">long</span> <span class="n">timeout</span><span class="o">,</span> <span class="n">TimeUnit</span> <span class="n">unit</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
        <span class="n">E</span> <span class="n">e</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="n">TIMED</span><span class="o">,</span> <span class="n">unit</span><span class="o">.</span><span class="na">toNanos</span><span class="o">(</span><span class="n">timeout</span><span class="o">));</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">())</span>
            <span class="k">return</span> <span class="n">e</span><span class="o">;</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">InterruptedException</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">E</span> <span class="nf">poll</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">xfer</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="n">NOW</span><span class="o">,</span> <span class="n">0</span><span class="o">);</span>
    <span class="o">}</span>

</code></pre></td></tr></table>
</div>
</div><h3 id="2-take方法">2. take方法</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">    <span class="kd">public</span> <span class="n">E</span> <span class="nf">take</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
        <span class="n">E</span> <span class="n">e</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="n">SYNC</span><span class="o">,</span> <span class="n">0</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">return</span> <span class="n">e</span><span class="o">;</span>
        <span class="n">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">();</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">InterruptedException</span><span class="o">();</span>
    <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="3-peek方法">3. peek方法</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">    <span class="kd">public</span> <span class="n">E</span> <span class="nf">peek</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">firstDataItem</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="cm">/**
</span><span class="cm">     * Returns the item in the first unmatched node with isData; or
</span><span class="cm">     * null if none.  Used by peek.
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="n">E</span> <span class="nf">firstDataItem</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Node</span> <span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span> <span class="n">p</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">succ</span><span class="o">(</span><span class="n">p</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">Object</span> <span class="n">item</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">isData</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">item</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">item</span> <span class="o">!=</span> <span class="n">p</span><span class="o">)</span>
                    <span class="k">return</span> <span class="k">this</span><span class="o">.&lt;</span><span class="n">E</span><span class="o">&gt;</span><span class="n">cast</span><span class="o">(</span><span class="n">item</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">item</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>    
</code></pre></td></tr></table>
</div>
</div><h2 id="四移除队列">四、移除队列</h2>
<h3 id="1-remove方法">1. remove方法</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">    <span class="cm">/**
</span><span class="cm">     * Removes a single instance of the specified element from this queue,
</span><span class="cm">     * if it is present.  More formally, removes an element {@code e} such
</span><span class="cm">     * that {@code o.equals(e)}, if this queue contains one or more such
</span><span class="cm">     * elements.
</span><span class="cm">     * Returns {@code true} if this queue contained the specified element
</span><span class="cm">     * (or equivalently, if this queue changed as a result of the call).
</span><span class="cm">     *
</span><span class="cm">     * @param o element to be removed from this queue, if present
</span><span class="cm">     * @return {@code true} if this queue changed as a result of the call
</span><span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">remove</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">findAndRemove</span><span class="o">(</span><span class="n">o</span><span class="o">);</span>
    <span class="o">}</span>
 <span class="cm">/**
</span><span class="cm">     * Main implementation of remove(Object)
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">findAndRemove</span><span class="o">(</span><span class="n">Object</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="n">Node</span> <span class="n">pred</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span> <span class="n">p</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="o">)</span> <span class="o">{</span>
                <span class="n">Object</span> <span class="n">item</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">isData</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">item</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">item</span> <span class="o">!=</span> <span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">e</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">item</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
                        <span class="n">p</span><span class="o">.</span><span class="na">tryMatchData</span><span class="o">())</span> <span class="o">{</span>
                        <span class="n">unsplice</span><span class="o">(</span><span class="n">pred</span><span class="o">,</span> <span class="n">p</span><span class="o">);</span>
                        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">item</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="n">pred</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">==</span> <span class="n">pred</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// stale
</span><span class="c1"></span>                    <span class="n">pred</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>  
  <span class="cm">/**
</span><span class="cm">     * Unsplices (now or later) the given deleted/cancelled node with
</span><span class="cm">     * the given predecessor.
</span><span class="cm">     *
</span><span class="cm">     * @param pred a node that was at one time known to be the
</span><span class="cm">     * predecessor of s, or null or s itself if s is/was at head
</span><span class="cm">     * @param s the node to be unspliced
</span><span class="cm">     */</span>
    <span class="kd">final</span> <span class="kt">void</span> <span class="nf">unsplice</span><span class="o">(</span><span class="n">Node</span> <span class="n">pred</span><span class="o">,</span> <span class="n">Node</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">s</span><span class="o">.</span><span class="na">forgetContents</span><span class="o">();</span> <span class="c1">// forget unneeded fields
</span><span class="c1"></span>        <span class="cm">/*
</span><span class="cm">         * See above for rationale. Briefly: if pred still points to
</span><span class="cm">         * s, try to unlink s.  If s cannot be unlinked, because it is
</span><span class="cm">         * trailing node or pred might be unlinked, and neither pred
</span><span class="cm">         * nor s are head or offlist, add to sweepVotes, and if enough
</span><span class="cm">         * votes have accumulated, sweep.
</span><span class="cm">         */</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">pred</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">pred</span> <span class="o">!=</span> <span class="n">s</span> <span class="o">&amp;&amp;</span> <span class="n">pred</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">Node</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span>
                <span class="o">(</span><span class="n">n</span> <span class="o">!=</span> <span class="n">s</span> <span class="o">&amp;&amp;</span> <span class="n">pred</span><span class="o">.</span><span class="na">casNext</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">pred</span><span class="o">.</span><span class="na">isMatched</span><span class="o">()))</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>               <span class="c1">// check if at, or could be, head  检查一下，或者可能是头部。
</span><span class="c1"></span>                    <span class="n">Node</span> <span class="n">h</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">h</span> <span class="o">==</span> <span class="n">pred</span> <span class="o">||</span> <span class="n">h</span> <span class="o">==</span> <span class="n">s</span> <span class="o">||</span> <span class="n">h</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                        <span class="k">return</span><span class="o">;</span>          <span class="c1">// at head or list empty
</span><span class="c1"></span>                    <span class="k">if</span> <span class="o">(!</span><span class="n">h</span><span class="o">.</span><span class="na">isMatched</span><span class="o">())</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="n">Node</span> <span class="n">hn</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">hn</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                        <span class="k">return</span><span class="o">;</span>          <span class="c1">// now empty
</span><span class="c1"></span>                    <span class="k">if</span> <span class="o">(</span><span class="n">hn</span> <span class="o">!=</span> <span class="n">h</span> <span class="o">&amp;&amp;</span> <span class="n">casHead</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">hn</span><span class="o">))</span>  
                        <span class="n">h</span><span class="o">.</span><span class="na">forgetNext</span><span class="o">();</span>  <span class="c1">// advance head
</span><span class="c1"></span>                <span class="o">}</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">pred</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="n">pred</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// recheck if offlist
</span><span class="c1"></span>                    <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>           <span class="c1">// sweep now if enough votes
</span><span class="c1"></span>                        <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">sweepVotes</span><span class="o">;</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">v</span> <span class="o">&lt;</span> <span class="n">SWEEP_THRESHOLD</span><span class="o">)</span> <span class="o">{</span>
                            <span class="k">if</span> <span class="o">(</span><span class="n">casSweepVotes</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">v</span> <span class="o">+</span> <span class="n">1</span><span class="o">))</span>
                                <span class="k">break</span><span class="o">;</span>
                        <span class="o">}</span>
                        <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">casSweepVotes</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">0</span><span class="o">))</span> <span class="o">{</span>
                            <span class="n">sweep</span><span class="o">();</span>
                            <span class="k">break</span><span class="o">;</span>
                        <span class="o">}</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/**
</span><span class="cm">     * Unlinks matched (typically cancelled) nodes encountered in a
</span><span class="cm">     * traversal from head.
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">sweep</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Node</span> <span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">n</span><span class="o">;</span> <span class="n">p</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">s</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">s</span><span class="o">.</span><span class="na">isMatched</span><span class="o">())</span>
                <span class="c1">// Unmatched nodes are never self-linked
</span><span class="c1"></span>                <span class="n">p</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
            <span class="k">else</span> <span class="k">if</span> <span class="o">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="c1">// trailing node is pinned
</span><span class="c1"></span>                <span class="k">break</span><span class="o">;</span>
            <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">n</span><span class="o">)</span>    <span class="c1">// stale
</span><span class="c1"></span>                <span class="c1">// No need to also check for p == s, since that implies s == n
</span><span class="c1"></span>                <span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
            <span class="k">else</span>
                <span class="n">p</span><span class="o">.</span><span class="na">casNext</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>    
</code></pre></td></tr></table>
</div>
</div><h3 id="2-clear方法">2. clear方法</h3>
<p>//AbstractQueue抽象类</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">    <span class="cm">/**
</span><span class="cm">     * Removes all of the elements from this queue.
</span><span class="cm">     * The queue will be empty after this call returns.
</span><span class="cm">     *
</span><span class="cm">     * &lt;p&gt;This implementation repeatedly invokes {@link #poll poll} until it
</span><span class="cm">     * returns &lt;tt&gt;null&lt;/tt&gt;.
</span><span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">clear</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">poll</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
            <span class="o">;</span>
    <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="3-drainto方法">3. drainTo方法</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">  <span class="cm">/**
</span><span class="cm">     * @throws NullPointerException     {@inheritDoc}
</span><span class="cm">     * @throws IllegalArgumentException {@inheritDoc}
</span><span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">drainTo</span><span class="o">(</span><span class="n">Collection</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">E</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">NullPointerException</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="k">this</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="n">E</span> <span class="n">e</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span> <span class="o">(</span><span class="n">e</span> <span class="o">=</span> <span class="n">poll</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">c</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
            <span class="o">++</span><span class="n">n</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">n</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
</span><span class="cm">     * @throws NullPointerException     {@inheritDoc}
</span><span class="cm">     * @throws IllegalArgumentException {@inheritDoc}
</span><span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">drainTo</span><span class="o">(</span><span class="n">Collection</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">E</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">,</span> <span class="kt">int</span> <span class="n">maxElements</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">NullPointerException</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="k">this</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="n">E</span> <span class="n">e</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">maxElements</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">e</span> <span class="o">=</span> <span class="n">poll</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">c</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
            <span class="o">++</span><span class="n">n</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">n</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="五transferqueue-接口方法实现">五、TransferQueue 接口方法实现</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span><span class="lnt">95
</span><span class="lnt">96
</span><span class="lnt">97
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">
 <span class="cm">/**
</span><span class="cm">  * Transfers the element to a waiting consumer immediately, if possible.
</span><span class="cm">  *
</span><span class="cm">  * &lt;p&gt;More precisely, transfers the specified element immediately
</span><span class="cm">  * if there exists a consumer already waiting to receive it (in
</span><span class="cm">  * {@link #take} or timed {@link #poll(long,TimeUnit) poll}),
</span><span class="cm">  * otherwise returning {@code false} without enqueuing the element.
</span><span class="cm">  *
</span><span class="cm">  * @throws NullPointerException if the specified element is null
</span><span class="cm">  */</span>
 <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">tryTransfer</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
     <span class="k">return</span> <span class="n">xfer</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="n">NOW</span><span class="o">,</span> <span class="n">0</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">;</span>
 <span class="o">}</span>

 <span class="cm">/**
</span><span class="cm">  * Transfers the element to a consumer, waiting if necessary to do so.
</span><span class="cm">  *
</span><span class="cm">  * &lt;p&gt;More precisely, transfers the specified element immediately
</span><span class="cm">  * if there exists a consumer already waiting to receive it (in
</span><span class="cm">  * {@link #take} or timed {@link #poll(long,TimeUnit) poll}),
</span><span class="cm">  * else inserts the specified element at the tail of this queue
</span><span class="cm">  * and waits until the element is received by a consumer.
</span><span class="cm">  *
</span><span class="cm">  * @throws NullPointerException if the specified element is null
</span><span class="cm">  */</span>
 <span class="kd">public</span> <span class="kt">void</span> <span class="nf">transfer</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
     <span class="k">if</span> <span class="o">(</span><span class="n">xfer</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="n">SYNC</span><span class="o">,</span> <span class="n">0</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
         <span class="n">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">();</span> <span class="c1">// failure possible only due to interrupt
</span><span class="c1"></span>         <span class="k">throw</span> <span class="k">new</span> <span class="n">InterruptedException</span><span class="o">();</span>
     <span class="o">}</span>
 <span class="o">}</span>

 <span class="cm">/**
</span><span class="cm">  * Transfers the element to a consumer if it is possible to do so
</span><span class="cm">  * before the timeout elapses.
</span><span class="cm">  *
</span><span class="cm">  * &lt;p&gt;More precisely, transfers the specified element immediately
</span><span class="cm">  * if there exists a consumer already waiting to receive it (in
</span><span class="cm">  * {@link #take} or timed {@link #poll(long,TimeUnit) poll}),
</span><span class="cm">  * else inserts the specified element at the tail of this queue
</span><span class="cm">  * and waits until the element is received by a consumer,
</span><span class="cm">  * returning {@code false} if the specified wait time elapses
</span><span class="cm">  * before the element can be transferred.
</span><span class="cm">  *
</span><span class="cm">  * @throws NullPointerException if the specified element is null
</span><span class="cm">  */</span>
 <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">tryTransfer</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">,</span> <span class="kt">long</span> <span class="n">timeout</span><span class="o">,</span> <span class="n">TimeUnit</span> <span class="n">unit</span><span class="o">)</span>
     <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
     <span class="k">if</span> <span class="o">(</span><span class="n">xfer</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="n">TIMED</span><span class="o">,</span> <span class="n">unit</span><span class="o">.</span><span class="na">toNanos</span><span class="o">(</span><span class="n">timeout</span><span class="o">))</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
         <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
     <span class="k">if</span> <span class="o">(!</span><span class="n">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">())</span>
         <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
     <span class="k">throw</span> <span class="k">new</span> <span class="n">InterruptedException</span><span class="o">();</span>
 <span class="o">}</span>
  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasWaitingConsumer</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">firstOfMode</span><span class="o">(</span><span class="kc">false</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span> 
  
      <span class="cm">/**
</span><span class="cm">       * Returns the first unmatched node of the given mode, or null if
</span><span class="cm">       * none.  Used by methods isEmpty, hasWaitingConsumer.
</span><span class="cm">       */</span>
      <span class="kd">private</span> <span class="n">Node</span> <span class="nf">firstOfMode</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">isData</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">for</span> <span class="o">(</span><span class="n">Node</span> <span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span> <span class="n">p</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">succ</span><span class="o">(</span><span class="n">p</span><span class="o">))</span> <span class="o">{</span>
              <span class="k">if</span> <span class="o">(!</span><span class="n">p</span><span class="o">.</span><span class="na">isMatched</span><span class="o">())</span>
                  <span class="k">return</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">isData</span> <span class="o">==</span> <span class="n">isData</span><span class="o">)</span> <span class="o">?</span> <span class="n">p</span> <span class="o">:</span> <span class="kc">null</span><span class="o">;</span>
          <span class="o">}</span>
          <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
      <span class="o">}</span>
      
   <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getWaitingConsumerCount</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">countOfMode</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="cm">/**
</span><span class="cm">     * Traverses and counts unmatched nodes of the given mode.
</span><span class="cm">     * Used by methods size and getWaitingConsumerCount.
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">countOfMode</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Node</span> <span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span> <span class="n">p</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">p</span><span class="o">.</span><span class="na">isMatched</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">isData</span> <span class="o">!=</span> <span class="n">data</span><span class="o">)</span>
                    <span class="k">return</span> <span class="n">0</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(++</span><span class="n">count</span> <span class="o">==</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">)</span> <span class="c1">// saturated
</span><span class="c1"></span>                    <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">Node</span> <span class="n">n</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">!=</span> <span class="n">p</span><span class="o">)</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="n">count</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>    
</code></pre></td></tr></table>
</div>
</div><h2 id="六iterator-迭代器实现">六、Iterator 迭代器实现</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">  <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Itr</span> <span class="kd">implements</span> <span class="n">Iterator</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="n">Node</span> <span class="n">nextNode</span><span class="o">;</span>   <span class="c1">// next node to return item for
</span><span class="c1"></span>        <span class="kd">private</span> <span class="n">E</span> <span class="n">nextItem</span><span class="o">;</span>      <span class="c1">// the corresponding item
</span><span class="c1"></span>        <span class="kd">private</span> <span class="n">Node</span> <span class="n">lastRet</span><span class="o">;</span>    <span class="c1">// last returned node, to support remove
</span><span class="c1"></span>        <span class="kd">private</span> <span class="n">Node</span> <span class="n">lastPred</span><span class="o">;</span>   <span class="c1">// predecessor to unlink lastRet
</span><span class="c1"></span>
        <span class="cm">/**
</span><span class="cm">         * Moves to next node after prev, or first node if prev null.
</span><span class="cm">         */</span>
        <span class="kd">private</span> <span class="kt">void</span> <span class="nf">advance</span><span class="o">(</span><span class="n">Node</span> <span class="n">prev</span><span class="o">)</span> <span class="o">{</span>
            <span class="cm">/*
</span><span class="cm">             * To track and avoid buildup of deleted nodes in the face
</span><span class="cm">             * of calls to both Queue.remove and Itr.remove, we must
</span><span class="cm">             * include variants of unsplice and sweep upon each
</span><span class="cm">             * advance: Upon Itr.remove, we may need to catch up links
</span><span class="cm">             * from lastPred, and upon other removes, we might need to
</span><span class="cm">             * skip ahead from stale nodes and unsplice deleted ones
</span><span class="cm">             * found while advancing.
</span><span class="cm">             */</span>

            <span class="n">Node</span> <span class="n">r</span><span class="o">,</span> <span class="n">b</span><span class="o">;</span> <span class="c1">// reset lastPred upon possible deletion of lastRet
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">((</span><span class="n">r</span> <span class="o">=</span> <span class="n">lastRet</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">r</span><span class="o">.</span><span class="na">isMatched</span><span class="o">())</span>
                <span class="n">lastPred</span> <span class="o">=</span> <span class="n">r</span><span class="o">;</span>    <span class="c1">// next lastPred is old lastRet
</span><span class="c1"></span>            <span class="k">else</span> <span class="k">if</span> <span class="o">((</span><span class="n">b</span> <span class="o">=</span> <span class="n">lastPred</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">b</span><span class="o">.</span><span class="na">isMatched</span><span class="o">())</span>
                <span class="n">lastPred</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// at start of list
</span><span class="c1"></span>            <span class="k">else</span> <span class="o">{</span>
                <span class="n">Node</span> <span class="n">s</span><span class="o">,</span> <span class="n">n</span><span class="o">;</span>       <span class="c1">// help with removal of lastPred.next
</span><span class="c1"></span>                <span class="k">while</span> <span class="o">((</span><span class="n">s</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span>
                       <span class="n">s</span> <span class="o">!=</span> <span class="n">b</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">isMatched</span><span class="o">()</span> <span class="o">&amp;&amp;</span>
                       <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">s</span><span class="o">)</span>
                    <span class="n">b</span><span class="o">.</span><span class="na">casNext</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="k">this</span><span class="o">.</span><span class="na">lastRet</span> <span class="o">=</span> <span class="n">prev</span><span class="o">;</span>

            <span class="k">for</span> <span class="o">(</span><span class="n">Node</span> <span class="n">p</span> <span class="o">=</span> <span class="n">prev</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">n</span><span class="o">;;)</span> <span class="o">{</span>
                <span class="n">s</span> <span class="o">=</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">head</span> <span class="o">:</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                    <span class="k">continue</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">Object</span> <span class="n">item</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">isData</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">item</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">item</span> <span class="o">!=</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">nextItem</span> <span class="o">=</span> <span class="n">LinkedTransferQueue</span><span class="o">.&lt;</span><span class="n">E</span><span class="o">&gt;</span><span class="n">cast</span><span class="o">(</span><span class="n">item</span><span class="o">);</span>
                        <span class="n">nextNode</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
                        <span class="k">return</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">item</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="c1">// assert s.isMatched();
</span><span class="c1"></span>                <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
                <span class="k">else</span> <span class="k">if</span> <span class="o">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">n</span><span class="o">)</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="k">else</span>
                    <span class="n">p</span><span class="o">.</span><span class="na">casNext</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">nextNode</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="n">nextItem</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="n">Itr</span><span class="o">()</span> <span class="o">{</span>
            <span class="n">advance</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">hasNext</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">nextNode</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kd">final</span> <span class="n">E</span> <span class="nf">next</span><span class="o">()</span> <span class="o">{</span>
            <span class="n">Node</span> <span class="n">p</span> <span class="o">=</span> <span class="n">nextNode</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">NoSuchElementException</span><span class="o">();</span>
            <span class="n">E</span> <span class="n">e</span> <span class="o">=</span> <span class="n">nextItem</span><span class="o">;</span>
            <span class="n">advance</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">e</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">remove</span><span class="o">()</span> <span class="o">{</span>
            <span class="kd">final</span> <span class="n">Node</span> <span class="n">lastRet</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">lastRet</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">lastRet</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="o">();</span>
            <span class="k">this</span><span class="o">.</span><span class="na">lastRet</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">lastRet</span><span class="o">.</span><span class="na">tryMatchData</span><span class="o">())</span>
                <span class="n">unsplice</span><span class="o">(</span><span class="n">lastPred</span><span class="o">,</span> <span class="n">lastRet</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div>
  </div>

  <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">BirdGod</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2017-06-25 21:08
        
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a target="_blank" rel="license noopener" href="https://github.com/birdgodtech/blog/master/LICENSE">MIT</a></span>
  </p>
</div>
<footer class="post-footer">
    <div class="post-tags">
      <a href="/tags/LinkedTransferQueue/">LinkedTransferQueue</a>
      </div>
    <nav class="post-nav" style="height: 27px">
      <a class="prev" href="/post/concurrent/collection/07.LinkedBlockingDeque%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">LinkedBlockingDeque</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
      <a class="next" href="/post/concurrent/collection/05.SynchronousQueue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">
        <span class="next-text nav-default">SynchronousQueue</span>
        <span class="next-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav>
  </footer>
  <script src="https://utteranc.es/client.js"
          repo="birdgodtech/birdgodtech.github.io"
          issue-term="pathname"
          theme="github-light"
          crossorigin="anonymous"
          async>
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterance.</a></noscript>
</article>
            </div>
            

        </div>
    </main>

    <footer id="footer" class="footer">
        <div class="social-links">
  <a href="mailto:birdgodtech@163.com" class="iconfont icon-email" title="email" rel="noopener" target="_blank" data-title="email"> </a>
  <a href="https://github.com/birdgodtech" class="iconfont icon-github" title="github" rel="noopener" target="_blank" data-title="github"> </a>
  <a href="https://birdgodtech.github.io/index.xml" type="application/rss+xml" rel="noopener" target="_blank" class="iconfont icon-rss" title="rss"></a>


</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 -
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> 本站总访问量 <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次 </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> 本站总访客数 <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 人 </span>
  </div>

  <span class="copyright-year">
    &copy;
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">BirdGod</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
    </div>
</div>

  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.min.js" integrity="sha256-jwCP0NAdCBloaIWTWHmW4i3snUNMHUNO+jr9rYd2iOI=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.locales.min.js" integrity="sha256-ZwofwC1Lf/faQCzN7nZtfijVV6hSwxjQMwXL4gn9qU8=" crossorigin="anonymous"></script>
  <script><!-- NOTE: timeago.js uses the language code format like "zh_CN" (underscore and case sensitive) -->
    var languageCode = "zh-CN".replace(/-/g, '_').replace(/_(.*)/, function ($0, $1) {return $0.replace($1, $1.toUpperCase());});
    timeago().render(document.querySelectorAll('.timeago'), languageCode);
    timeago.cancel();  
  </script>
<script type="text/javascript" src="/dist/even.47f727f4.min.js"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-84813914-2', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>







</body>
</html>
