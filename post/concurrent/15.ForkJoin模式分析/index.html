<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>ForkJoin - BirdGod 技术分享</title>
    <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="BirdGod" /><meta name="description" content="ForkJoin模式分析 简介 Fork/Join框架介绍不错博客，阿里方腾飞写 Fork/Join使用两个类来完成以上两件事情： ForkJoin" /><meta name="keywords" content="Java" />






<meta name="generator" content="Hugo 0.74.0-DEV with even 4.0.0" />


<link rel="canonical" href="https://birdgodtech.github.io/post/concurrent/15.ForkJoin%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90/" />
<link href="/post/concurrent/15.ForkJoin%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90/" rel="alternate" type="application/rss+xml" title="BirdGod 技术分享" />
<link href="/post/concurrent/15.ForkJoin%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90/" rel="feed" type="application/rss+xml" title="BirdGod 技术分享" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<link href="/dist/even.06658218.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">
<link rel="stylesheet" href="/css/reset-even.css">


<meta property="og:title" content="ForkJoin" />
<meta property="og:description" content="ForkJoin模式分析 简介 Fork/Join框架介绍不错博客，阿里方腾飞写 Fork/Join使用两个类来完成以上两件事情： ForkJoin" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://birdgodtech.github.io/post/concurrent/15.ForkJoin%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90/" />
<meta property="article:published_time" content="2017-05-03T19:11:08+00:00" />
<meta property="article:modified_time" content="2017-05-03T19:11:08+00:00" />
<meta itemprop="name" content="ForkJoin">
<meta itemprop="description" content="ForkJoin模式分析 简介 Fork/Join框架介绍不错博客，阿里方腾飞写 Fork/Join使用两个类来完成以上两件事情： ForkJoin">
<meta itemprop="datePublished" content="2017-05-03T19:11:08&#43;00:00" />
<meta itemprop="dateModified" content="2017-05-03T19:11:08&#43;00:00" />
<meta itemprop="wordCount" content="27732">



<meta itemprop="keywords" content="ForkJoin," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="ForkJoin"/>
<meta name="twitter:description" content="ForkJoin模式分析 简介 Fork/Join框架介绍不错博客，阿里方腾飞写 Fork/Join使用两个类来完成以上两件事情： ForkJoin"/>

</head>
<body>
<div id="mobile-navbar" class="mobile-navbar">
    <div class="mobile-header-logo">
        <a href="/" class="logo">BirdGod 技术分享</a>
    </div>
    <div class="mobile-navbar-icon">
        <span></span>
        <span></span>
        <span></span>
    </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
    <ul class="mobile-menu-list">
        <a href="/">
            <li class="mobile-menu-item" title="首页">首页</li>
        </a>
        <a href="/post/">
            <li class="mobile-menu-item" title="归档">归档</li>
        </a>
        <a href="/categories/">
            <li class="mobile-menu-item" title="分类">分类</li>
        </a>
        <a href="/tags/">
            <li class="mobile-menu-item" title="标签">标签</li>
        </a>
        <a href="/about/">
            <li class="mobile-menu-item" title="关于我">关于我</li>
        </a>
        
    </ul>
</nav>

<div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
    <a href="/" class="logo">BirdGod 技术分享</a>
</div>

<nav class="site-navbar">
    <ul id="menu" class="menu" data-sum="0">
        
        <li class="menu-item menu-item-home">
            <a class="menu-item-link" href="/" title="首页">首页</a>
        </li>
        
        <li class="menu-item menu-item-archives">
            <a class="menu-item-link" href="/post/" title="归档">归档</a>
        </li>
        
        <li class="menu-item menu-item-categories">
            <a class="menu-item-link" href="/categories/" title="分类">分类</a>
        </li>
        
        <li class="menu-item menu-item-tags">
            <a class="menu-item-link" href="/tags/" title="标签">标签</a>
        </li>
        
        <li class="menu-item menu-item-about">
            <a class="menu-item-link" href="/about/" title="关于我">关于我</a>
        </li>
        
    </ul>
</nav>

    </header>


    <main id="main" class="main">
        <div class="content-wrapper">
            <div id="content" class="content">
                <article class="post">
  
  <header class="post-header">
    <h1 class="post-title">ForkJoin</h1>

    <div class="post-meta">
      <span class="post-time"> 2017-05-03 19:11 </span>
      <div class="post-category">
        <a href="/categories/%E5%B9%B6%E5%8F%91/"> 并发 </a>
        </div>
      <span class="more-meta"> 约 27732 字 </span>
      <span class="more-meta"> 预计阅读 56 分钟 </span>
      <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次阅读 </span>
    </div>
  </header>

  <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#简介">简介</a></li>
    <li><a href="#一forkjoinpool源码分析">一、ForkJoinPool源码分析</a>
      <ul>
        <li><a href="#1forkjoinpool实现概述">1.ForkJoinPool实现概述</a></li>
        <li><a href="#2forkjoinpool实现-forkjoinworkerthreadfactory">2.ForkJoinPool实现 ForkJoinWorkerThreadFactory</a></li>
        <li><a href="#3forkjoinworkerthread-工作线程">3.ForkJoinWorkerThread 工作线程</a></li>
        <li><a href="#4forkjoinpool-构造">4.ForkJoinPool 构造</a></li>
        <li><a href="#5forkjoinpoolexecute-执行任务">5.ForkJoinPool.execute 执行任务</a></li>
      </ul>
    </li>
    <li><a href="#一forkjointask源码分析">一、ForkJoinTask源码分析</a>
      <ul>
        <li><a href="#1forkjointask构造">1.ForkJoinTask构造</a></li>
        <li><a href="#2-exceptionnode-异常节点">2. ExceptionNode 异常节点</a></li>
        <li><a href="#3-doexec-执行">3. doExec 执行</a></li>
        <li><a href="#4-fork-执行">4. fork 执行</a></li>
        <li><a href="#5-join-执行">5. join 执行</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
  <div class="post-outdated">
    <div class="warn">
      <p>【注意】最后更新于 <span class="timeago" datetime="2017-05-03T19:11:08" title="May 3, 2017">May 3, 2017</span>，文中内容可能已过时，请谨慎使用。</p>
    </div>
  </div>
  <div class="post-content">
    <h1 id="forkjoin模式分析">ForkJoin模式分析</h1>
<h2 id="简介">简介</h2>
<p><a href="http://www.infoq.com/cn/articles/fork-join-introduction">Fork/Join框架介绍</a>不错博客，阿里<strong>方腾飞</strong>写</p>
<p>Fork/Join使用两个类来完成以上两件事情：</p>
<ul>
<li>
<p>ForkJoinTask：我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务中执行fork()和join()操作的机制，
通常情况下我们不需要直接继承ForkJoinTask类，而只需要继承它的子类，Fork/Join框架提供了以下两个子类：</p>
<ul>
<li>RecursiveAction：用于没有返回结果的任务。</li>
<li>RecursiveTask ：用于有返回结果的任务。</li>
</ul>
</li>
<li>
<p>ForkJoinPool ：ForkJoinTask需要通过ForkJoinPool来执行，任务分割出的子任务会添加到当前工作线程所维护的双端队列中，
进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。</p>
</li>
</ul>
<h2 id="一forkjoinpool源码分析">一、ForkJoinPool源码分析</h2>
<p>ForkJoinPool继承AbstractExecutorService抽象类</p>
<h3 id="1forkjoinpool实现概述">1.ForkJoinPool实现概述</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span><span class="lnt">233
</span><span class="lnt">234
</span><span class="lnt">235
</span><span class="lnt">236
</span><span class="lnt">237
</span><span class="lnt">238
</span><span class="lnt">239
</span><span class="lnt">240
</span><span class="lnt">241
</span><span class="lnt">242
</span><span class="lnt">243
</span><span class="lnt">244
</span><span class="lnt">245
</span><span class="lnt">246
</span><span class="lnt">247
</span><span class="lnt">248
</span><span class="lnt">249
</span><span class="lnt">250
</span><span class="lnt">251
</span><span class="lnt">252
</span><span class="lnt">253
</span><span class="lnt">254
</span><span class="lnt">255
</span><span class="lnt">256
</span><span class="lnt">257
</span><span class="lnt">258
</span><span class="lnt">259
</span><span class="lnt">260
</span><span class="lnt">261
</span><span class="lnt">262
</span><span class="lnt">263
</span><span class="lnt">264
</span><span class="lnt">265
</span><span class="lnt">266
</span><span class="lnt">267
</span><span class="lnt">268
</span><span class="lnt">269
</span><span class="lnt">270
</span><span class="lnt">271
</span><span class="lnt">272
</span><span class="lnt">273
</span><span class="lnt">274
</span><span class="lnt">275
</span><span class="lnt">276
</span><span class="lnt">277
</span><span class="lnt">278
</span><span class="lnt">279
</span><span class="lnt">280
</span><span class="lnt">281
</span><span class="lnt">282
</span><span class="lnt">283
</span><span class="lnt">284
</span><span class="lnt">285
</span><span class="lnt">286
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"> <span class="cm">/*
</span><span class="cm">     * Implementation Overview
</span><span class="cm">     *
</span><span class="cm">     * This class provides the central bookkeeping and control for a
</span><span class="cm">     * set of worker threads: Submissions from non-FJ threads enter
</span><span class="cm">     * into a submission queue. Workers take these tasks and typically
</span><span class="cm">     * split them into subtasks that may be stolen by other workers.
</span><span class="cm">     * Preference rules give first priority to processing tasks from
</span><span class="cm">     * their own queues (LIFO or FIFO, depending on mode), then to
</span><span class="cm">     * randomized FIFO steals of tasks in other worker queues, and
</span><span class="cm">     * lastly to new submissions.
</span><span class="cm">     * 该类为一组工作线程提供中央记帐和控制：来自非FJ线程的提交输入到提交队列中。
</span><span class="cm">     * 工人们承担这些任务，通常将他们分解成可能被其他工人窃取的子任务。优先规则优先处理来自其自己的队列（LIFO或FIFO，取决于模式）的任务，
</span><span class="cm">     * 然后是其他工作队列中的任务的随机FIFO窃取，并且最后是新的提交。
</span><span class="cm">     *
</span><span class="cm">     * The main throughput advantages of work-stealing stem from
</span><span class="cm">     * decentralized control -- workers mostly take tasks from
</span><span class="cm">     * themselves or each other. We cannot negate this in the
</span><span class="cm">     * implementation of other management responsibilities. The main
</span><span class="cm">     * tactic for avoiding bottlenecks is packing nearly all
</span><span class="cm">     * essentially atomic control state into a single 64bit volatile
</span><span class="cm">     * variable (&#34;ctl&#34;). This variable is read on the order of 10-100
</span><span class="cm">     * times as often as it is modified (always via CAS). (There is
</span><span class="cm">     * some additional control state, for example variable &#34;shutdown&#34;
</span><span class="cm">     * for which we can cope with uncoordinated updates.)  This
</span><span class="cm">     * streamlines synchronization and control at the expense of messy
</span><span class="cm">     * constructions needed to repack status bits upon updates.
</span><span class="cm">     * Updates tend not to contend with each other except during
</span><span class="cm">     * bursts while submitted tasks begin or end.  In some cases when
</span><span class="cm">     * they do contend, threads can instead do something else
</span><span class="cm">     * (usually, scan for tasks) until contention subsides.
</span><span class="cm">     * 
</span><span class="cm">     * 窃取工作的主要优势在于分散控制 - 工人大多是从他们自己或其他人那里获得工作。
</span><span class="cm">     * 在履行其他管理责任方面，我们不能否定这一点。避免瓶颈的主要策略是将几乎所有的基本原子控制状态都打包成一个64位的volatile变量（&#34;ctl&#34;）。
</span><span class="cm">     * 这个变量的读取次数是它修改的时间的10-100倍（总是通过CAS）。 （有一些额外的控制状态，例如变量&#34;关机&#34;，我们可以应付不协调的更新。）
</span><span class="cm">     * 这简化了同步和控制，代价是在更新时重新包装状态位所需的混乱构造。除了在提交的任务开始或结束时爆发期间，更新往往不会相互竞争。
</span><span class="cm">     * 在某些情况下，线程可以做其他事情（通常是扫描任务），直到争用消退。
</span><span class="cm">     *
</span><span class="cm">     * To enable packing, we restrict maximum parallelism to (1&lt;&lt;15)-1
</span><span class="cm">     * (which is far in excess of normal operating range) to allow
</span><span class="cm">     * ids, counts, and their negations (used for thresholding) to fit
</span><span class="cm">     * into 16bit fields.
</span><span class="cm">     * 为了实现打包，我们限制最大平行度为（1 &lt;&lt; 15）-1 *（远远超过正常的操作范围），以允许* id，计数和它们的否定（用于阈值处理）适合16位字段。
</span><span class="cm">     *
</span><span class="cm">     * Recording Workers.  Workers are recorded in the &#34;workers&#34; array
</span><span class="cm">     * that is created upon pool construction and expanded if (rarely)
</span><span class="cm">     * necessary.  This is an array as opposed to some other data
</span><span class="cm">     * structure to support index-based random steals by workers.
</span><span class="cm">     * Updates to the array recording new workers and unrecording
</span><span class="cm">     * terminated ones are protected from each other by a seqLock
</span><span class="cm">     * (scanGuard) but the array is otherwise concurrently readable,
</span><span class="cm">     * and accessed directly by workers. To simplify index-based
</span><span class="cm">     * operations, the array size is always a power of two, and all
</span><span class="cm">     * readers must tolerate null slots. To avoid flailing during
</span><span class="cm">     * start-up, the array is presized to hold twice #parallelism
</span><span class="cm">     * workers (which is unlikely to need further resizing during
</span><span class="cm">     * execution). But to avoid dealing with so many null slots,
</span><span class="cm">     * variable scanGuard includes a mask for the nearest power of two
</span><span class="cm">     * that contains all current workers.  All worker thread creation
</span><span class="cm">     * is on-demand, triggered by task submissions, replacement of
</span><span class="cm">     * terminated workers, and/or compensation for blocked
</span><span class="cm">     * workers. However, all other support code is set up to work with
</span><span class="cm">     * other policies.  To ensure that we do not hold on to worker
</span><span class="cm">     * references that would prevent GC, ALL accesses to workers are
</span><span class="cm">     * via indices into the workers array (which is one source of some
</span><span class="cm">     * of the messy code constructions here). In essence, the workers
</span><span class="cm">     * array serves as a weak reference mechanism. Thus for example
</span><span class="cm">     * the wait queue field of ctl stores worker indices, not worker
</span><span class="cm">     * references.  Access to the workers in associated methods (for
</span><span class="cm">     * example signalWork) must both index-check and null-check the
</span><span class="cm">     * IDs. All such accesses ignore bad IDs by returning out early
</span><span class="cm">     * from what they are doing, since this can only be associated
</span><span class="cm">     * with termination, in which case it is OK to give up.
</span><span class="cm">     * 
</span><span class="cm">     * 记录工作者。工人被记录在游泳池建造时创建的&#34;工人&#34;数组中，并且在（很少）必要时扩展。这是一个数组，而不是其他一些数据结构来支
</span><span class="cm">     * 持工人的基于索引的随机窃取。对录制新工作者和未录制终止录音的阵列的更新通过seqLock（scanGuard）彼此保护，但该阵列可以同时读取，
</span><span class="cm">     * 并且可以由工作人员直接访问。为了简化基于索引的操作，数组大小始终是2的乘方，所有读者都必须容忍空位。为了避免在启动过程中出现混乱，
</span><span class="cm">     * 阵列被预先保存两次＃并行工作者（这在执行期间不太可能需要进一步调整大小）。但是为了避免处理这么多的空位，变量scanGuard包含了一个
</span><span class="cm">     * 包含所有当前工作人员的最近权力的掩码。所有工作线程的创建都是按需提供的，由提交任务，更换终止的工作人员和/或对被阻止的工作人员进
</span><span class="cm">     * 行补偿。但是，所有其他支持代码都已设置为与其他策略配合使用。为了确保我们不拘泥于可能阻止GC的工作者引用，对worker的所有访问都是通
</span><span class="cm">     * 过指向workers数组（这是这里一些混乱的代码构造的一个来源）的索引。从本质上讲，工人阵列是一个薄弱的参照机制。因此，例如ctl的等待队
</span><span class="cm">     * 列字段存储工人索引，而不是工作者引用。在关联的方法（例如signalWork）中访问工作人员必须对这些ID进行索引检查和空值检查。所有这样的
</span><span class="cm">     * 访问都会忽略坏ID，因为它们只能与终止相关联，在这种情况下，放弃是可以的。
</span><span class="cm">     *
</span><span class="cm">     * All uses of the workers array, as well as queue arrays, check
</span><span class="cm">     * that the array is non-null (even if previously non-null). This
</span><span class="cm">     * allows nulling during termination, which is currently not
</span><span class="cm">     * necessary, but remains an option for resource-revocation-based
</span><span class="cm">     * shutdown schemes.
</span><span class="cm">     * workers数组的所有用法以及队列数组都检查数组是否为非null（即使之前为非null）。这允许在终止期间归零，这当前不是必需的，
</span><span class="cm">     * 但仍然是用于基于资源撤销的关闭方案的选项。
</span><span class="cm">     *
</span><span class="cm">     * Wait Queuing. Unlike HPC work-stealing frameworks, we cannot
</span><span class="cm">     * let workers spin indefinitely scanning for tasks when none can
</span><span class="cm">     * be found immediately, and we cannot start/resume workers unless
</span><span class="cm">     * there appear to be tasks available.  On the other hand, we must
</span><span class="cm">     * quickly prod them into action when new tasks are submitted or
</span><span class="cm">     * generated.  We park/unpark workers after placing in an event
</span><span class="cm">     * wait queue when they cannot find work. This &#34;queue&#34; is actually
</span><span class="cm">     * a simple Treiber stack, headed by the &#34;id&#34; field of ctl, plus a
</span><span class="cm">     * 15bit counter value to both wake up waiters (by advancing their
</span><span class="cm">     * count) and avoid ABA effects. Successors are held in worker
</span><span class="cm">     * field &#34;nextWait&#34;.  Queuing deals with several intrinsic races,
</span><span class="cm">     * mainly that a task-producing thread can miss seeing (and
</span><span class="cm">     * signalling) another thread that gave up looking for work but
</span><span class="cm">     * has not yet entered the wait queue. We solve this by requiring
</span><span class="cm">     * a full sweep of all workers both before (in scan()) and after
</span><span class="cm">     * (in tryAwaitWork()) a newly waiting worker is added to the wait
</span><span class="cm">     * queue. During a rescan, the worker might release some other
</span><span class="cm">     * queued worker rather than itself, which has the same net
</span><span class="cm">     * effect. Because enqueued workers may actually be rescanning
</span><span class="cm">     * rather than waiting, we set and clear the &#34;parked&#34; field of
</span><span class="cm">     * ForkJoinWorkerThread to reduce unnecessary calls to unpark.
</span><span class="cm">     * (Use of the parked field requires a secondary recheck to avoid
</span><span class="cm">     * missed signals.)
</span><span class="cm">     * 
</span><span class="cm">     * 等待排队。不像高性能计算机窃取工作的框架，我们不能让工作人员无限期地扫描任务，而不能马上找到任何工作，除非看起来有任务可用，
</span><span class="cm">     * 否则我们不能启动/恢复工人。另一方面，当新的任务提交或产生时，我们必须迅速采取行动。在找不到工作的时候，我们把工作人员放在一个
</span><span class="cm">     * 事件等待队列里。这个&#34;队列&#34;实际上是一个简单的Treiber堆栈，由ctl的&#34;id&#34;字段加上一个15bit的计数器值来唤醒等待者（通过提前计数）并避免ABA效应。
</span><span class="cm">     * 接班人在工作场所&#34;nextWait&#34;举行。排队处理几个内在的种族，主要是一个任务生成线程可能会错过看到（和信号）另一个线程，放弃寻找工作，
</span><span class="cm">     * 但还没有进入等待队列。我们通过在（在scan（）中）和after（在tryAwaitWork（））之前全部扫描所有的工人来解决这个问题，一个新等待的工人被
</span><span class="cm">     * 添加到等待队列中。在重新扫描期间，工人可能会释放一些其他排队的工人，而不是自己，这具有相同的净效果。因为排队的工人可能实际上是在重新扫描，
</span><span class="cm">     * 而不是等待，所以我们设置并清除ForkJoinWorkerThread的&#34;停放&#34;字段，以减少不必要的停靠。 （使用停放区域需要进行二次重新检查以避免错过信号。）
</span><span class="cm">     *
</span><span class="cm">     * Signalling.  We create or wake up workers only when there
</span><span class="cm">     * appears to be at least one task they might be able to find and
</span><span class="cm">     * execute.  When a submission is added or another worker adds a
</span><span class="cm">     * task to a queue that previously had two or fewer tasks, they
</span><span class="cm">     * signal waiting workers (or trigger creation of new ones if
</span><span class="cm">     * fewer than the given parallelism level -- see signalWork).
</span><span class="cm">     * These primary signals are buttressed by signals during rescans
</span><span class="cm">     * as well as those performed when a worker steals a task and
</span><span class="cm">     * notices that there are more tasks too; together these cover the
</span><span class="cm">     * signals needed in cases when more than two tasks are pushed
</span><span class="cm">     * but untaken.
</span><span class="cm">     * 信号。只有在看起来至少有一项任务可以找到并执行时，我们才会创造或唤醒员工。当一个提交被添加或另一个工作人员添加一个任务到以前有两个或更少
</span><span class="cm">     * 的任务的队列，他们信号等待工作人员（或触发创建新的，如果少于给定的并行水平 - 见signalWork）。这些主要信号在重新扫描期间受到信号的支持，
</span><span class="cm">     * 以及在工作人员窃取任务时执行的信号，并注意到还有更多的任务。它们一起涵盖了当两个以上的任务被推动但未被采取的情况下所需要的信号。
</span><span class="cm">     *
</span><span class="cm">     * Trimming workers. To release resources after periods of lack of
</span><span class="cm">     * use, a worker starting to wait when the pool is quiescent will
</span><span class="cm">     * time out and terminate if the pool has remained quiescent for
</span><span class="cm">     * SHRINK_RATE nanosecs. This will slowly propagate, eventually
</span><span class="cm">     * terminating all workers after long periods of non-use.
</span><span class="cm">     * 整理工人。要在缺乏使用期间释放资源，当池暂停时，开始等待的工作人员将超时并终止，如果池的剩余容量为SHRINK_RATE nanosecs。这将慢慢地传播，
</span><span class="cm">     * 最终在所有工人长时间不使用后终止。
</span><span class="cm">     * 
</span><span class="cm">     * Submissions. External submissions are maintained in an
</span><span class="cm">     * array-based queue that is structured identically to
</span><span class="cm">     * ForkJoinWorkerThread queues except for the use of
</span><span class="cm">     * submissionLock in method addSubmission. Unlike the case for
</span><span class="cm">     * worker queues, multiple external threads can add new
</span><span class="cm">     * submissions, so adding requires a lock.
</span><span class="cm">     * 
</span><span class="cm">     * 提交。外部提交在基于数组的队列中维护，其结构与ForkJoinWorkerThread队列的结构相同，除了在方法addSubmission中使用submissionLock。
</span><span class="cm">     * 与工作队列的情况不同，多个外部线程可以添加新的提交，因此添加需要锁定。
</span><span class="cm">     *
</span><span class="cm">     * Compensation. Beyond work-stealing support and lifecycle
</span><span class="cm">     * control, the main responsibility of this framework is to take
</span><span class="cm">     * actions when one worker is waiting to join a task stolen (or
</span><span class="cm">     * always held by) another.  Because we are multiplexing many
</span><span class="cm">     * tasks on to a pool of workers, we can&#39;t just let them block (as
</span><span class="cm">     * in Thread.join).  We also cannot just reassign the joiner&#39;s
</span><span class="cm">     * run-time stack with another and replace it later, which would
</span><span class="cm">     * be a form of &#34;continuation&#34;, that even if possible is not
</span><span class="cm">     * necessarily a good idea since we sometimes need both an
</span><span class="cm">     * unblocked task and its continuation to progress. Instead we
</span><span class="cm">     * combine two tactics:
</span><span class="cm">     * 补偿。除了工作窃取支持和生命周期控制之外，这个框架的主要职责是当一个工作人员等待加入一个被他人窃取（或总是被他人占有）的任务时采取行动。
</span><span class="cm">     * 因为我们将许多任务复用到工作池中，所以我们不能让它们阻塞（如在Thread.join中）。我们也不能仅仅把joiner的运行时间栈重新分配给另一个栈，
</span><span class="cm">     * 并且稍后将其替换，这将是一种&#34;延续&#34;形式，即使可能也不一定是一个好主意，因为我们有时需要一个畅通无阻的任务和它的延续进展。
</span><span class="cm">     * 相反，我们结合了两种策略：
</span><span class="cm">     *
</span><span class="cm">     *   Helping: Arranging for the joiner to execute some task that it
</span><span class="cm">     *      would be running if the steal had not occurred.  Method
</span><span class="cm">     *      ForkJoinWorkerThread.joinTask tracks joining-&gt;stealing
</span><span class="cm">     *      links to try to find such a task.
</span><span class="cm">     *      帮助：安排joiner执行一些任务，如果偷窃没有发生，它将会运行。方法Fork连接工作线程。连接任务跟踪连接- &gt;窃取链接试图找到这样的任务。
</span><span class="cm">     *
</span><span class="cm">     *   Compensating: Unless there are already enough live threads,
</span><span class="cm">     *      method tryPreBlock() may create or re-activate a spare
</span><span class="cm">     *      thread to compensate for blocked joiners until they
</span><span class="cm">     *      unblock.
</span><span class="cm">     *      补偿：除非已经有足够的活动线程，方法tryPreBlock（）可能会创建或重新激活一个备用线程来补偿被阻止的参与者，直到它们被解除阻塞。
</span><span class="cm">     *
</span><span class="cm">     * The ManagedBlocker extension API can&#39;t use helping so relies
</span><span class="cm">     * only on compensation in method awaitBlocker.
</span><span class="cm">     * 管理的拦截器扩展API不能使用帮助，因此只依赖于方法中的补偿等待拦截器。
</span><span class="cm">     *
</span><span class="cm">     * It is impossible to keep exactly the target parallelism number
</span><span class="cm">     * of threads running at any given time.  Determining the
</span><span class="cm">     * existence of conservatively safe helping targets, the
</span><span class="cm">     * availability of already-created spares, and the apparent need
</span><span class="cm">     * to create new spares are all racy and require heuristic
</span><span class="cm">     * guidance, so we rely on multiple retries of each.  Currently,
</span><span class="cm">     * in keeping with on-demand signalling policy, we compensate only
</span><span class="cm">     * if blocking would leave less than one active (non-waiting,
</span><span class="cm">     * non-blocked) worker. Additionally, to avoid some false alarms
</span><span class="cm">     * due to GC, lagging counters, system activity, etc, compensated
</span><span class="cm">     * blocking for joins is only attempted after rechecks stabilize
</span><span class="cm">     * (retries are interspersed with Thread.yield, for good
</span><span class="cm">     * citizenship).  The variable blockedCount, incremented before
</span><span class="cm">     * blocking and decremented after, is sometimes needed to
</span><span class="cm">     * distinguish cases of waiting for work vs blocking on joins or
</span><span class="cm">     * other managed sync. Both cases are equivalent for most pool
</span><span class="cm">     * control, so we can update non-atomically. (Additionally,
</span><span class="cm">     * contention on blockedCount alleviates some contention on ctl).
</span><span class="cm">     * 
</span><span class="cm">     * 在任何给定的时间都不可能精确地保持运行的线程的目标并行数。确定保守安全帮助目标的存在，
</span><span class="cm">     * 已经创建的备件的可用性以及创建新备件的明显需求都非常活跃，并且需要启发式的指导，所以我们依靠每个备份的多次重试。
</span><span class="cm">     * 目前，按照按需信令政策，我们只有在阻塞情况下才会补偿少于一个活跃（非等待，非阻塞）的工作人员。
</span><span class="cm">     * 另外，为了避免由于GC，滞后计数器，系统活动等引起的一些虚假警报，只有在重新检查稳定（重试与Thread.yield交织，为了良好的公民权）
</span><span class="cm">     * 之后才尝试补偿联接的阻塞。变量blockedCount在阻塞之前递增，之后递减，有时需要区分等待工作与阻塞连接或其他受管同步的情况。
</span><span class="cm">     * 这两种情况对于大多数池控制都是相同的，所以我们可以非自动更新。 （此外，blockingCount上的争用减轻了对ctl的一些争议）。
</span><span class="cm">     * 
</span><span class="cm">     *
</span><span class="cm">     * Shutdown and Termination. A call to shutdownNow atomically sets
</span><span class="cm">     * the ctl stop bit and then (non-atomically) sets each workers
</span><span class="cm">     * &#34;terminate&#34; status, cancels all unprocessed tasks, and wakes up
</span><span class="cm">     * all waiting workers.  Detecting whether termination should
</span><span class="cm">     * commence after a non-abrupt shutdown() call requires more work
</span><span class="cm">     * and bookkeeping. We need consensus about quiesence (i.e., that
</span><span class="cm">     * there is no more work) which is reflected in active counts so
</span><span class="cm">     * long as there are no current blockers, as well as possible
</span><span class="cm">     * re-evaluations during independent changes in blocking or
</span><span class="cm">     * quiescing workers.
</span><span class="cm">     * 
</span><span class="cm">     * 关机和终止。调用shutdownNow自动设置CTL停止位，然后（非原子）设置每个工人&#34;终止&#34;状态，取消所有未处理的任务，
</span><span class="cm">     * 并唤醒所有等待工作人员。在非突然关机（）调用之后检测终止是否应该开始需要更多的工作和簿记。我们需要关于安静（即没有更多的工作）的共识，
</span><span class="cm">     * 只要没有当前的阻断者，反映在积极的计数中，以及在阻止或停顿工人的独立变化期间可能重新评估
</span><span class="cm">     *
</span><span class="cm">     * Style notes: There is a lot of representation-level coupling
</span><span class="cm">     * among classes ForkJoinPool, ForkJoinWorkerThread, and
</span><span class="cm">     * ForkJoinTask.  Most fields of ForkJoinWorkerThread maintain
</span><span class="cm">     * data structures managed by ForkJoinPool, so are directly
</span><span class="cm">     * accessed.  Conversely we allow access to &#34;workers&#34; array by
</span><span class="cm">     * workers, and direct access to ForkJoinTask.status by both
</span><span class="cm">     * ForkJoinPool and ForkJoinWorkerThread.  There is little point
</span><span class="cm">     * trying to reduce this, since any associated future changes in
</span><span class="cm">     * representations will need to be accompanied by algorithmic
</span><span class="cm">     * changes anyway. All together, these low-level implementation
</span><span class="cm">     * choices produce as much as a factor of 4 performance
</span><span class="cm">     * improvement compared to naive implementations, and enable the
</span><span class="cm">     * processing of billions of tasks per second, at the expense of
</span><span class="cm">     * some ugliness.
</span><span class="cm">     * 
</span><span class="cm">     * 样式说明：在类ForkJoinPool，ForkJoinWorkerThread和ForkJoinTask中有很多表示级的耦合。
</span><span class="cm">      * ForkJoinWorkerThread的大部分字段都维护由ForkJoinPool管理的数据结构，因此可以直接访问。相反，
</span><span class="cm">      * 我们允许工作人员访问&#34;workers&#34;数组，并通过ForkJoinPool和ForkJoinWorkerThread直接访问ForkJoinTask.status。试图减少这一点是没有意义的，
</span><span class="cm">      * 因为任何关联的未来表示变化都需要伴随着算法变化。总而言之，这些低级的实现选择与原始实现相比，性能提高了4倍，
</span><span class="cm">      * 并且能够以每秒处理数十亿个任务为代价，而不惜牺牲一些丑陋。
</span><span class="cm">     *
</span><span class="cm">     * Methods signalWork() and scan() are the main bottlenecks so are
</span><span class="cm">     * especially heavily micro-optimized/mangled.  There are lots of
</span><span class="cm">     * inline assignments (of form &#34;while ((local = field) != 0)&#34;)
</span><span class="cm">     * which are usually the simplest way to ensure the required read
</span><span class="cm">     * orderings (which are sometimes critical). This leads to a
</span><span class="cm">     * &#34;C&#34;-like style of listing declarations of these locals at the
</span><span class="cm">     * heads of methods or blocks.  There are several occurrences of
</span><span class="cm">     * the unusual &#34;do {} while (!cas...)&#34;  which is the simplest way
</span><span class="cm">     * to force an update of a CAS&#39;ed variable. There are also other
</span><span class="cm">     * coding oddities that help some methods perform reasonably even
</span><span class="cm">     * when interpreted (not compiled).
</span><span class="cm">     * 
</span><span class="cm">     * 方法signalWork（）和scan（）是主要的瓶颈，所以特别严重的是微优化/损坏。 （&#34;（local = field）！= 0）&#34;中有很多内联赋值，
</span><span class="cm">     * 它们通常是确保所需的读取顺序（有时很重要）的最简单的方法。这导致了这些当地人在方法或块的头上的&#34;C&#34;式的列名声明。
</span><span class="cm">     * 有一些不寻常的&#34;do {} while（！cas ...）&#34;出现，这是强制更新CAS&#39;ed变量的最简单的方法。还有其他的编码古怪，即使解释（不编译），
</span><span class="cm">     * 帮助一些方法合理地执行。
</span><span class="cm">     *
</span><span class="cm">     * The order of declarations in this file is: (1) declarations of
</span><span class="cm">     * statics (2) fields (along with constants used when unpacking
</span><span class="cm">     * some of them), listed in an order that tends to reduce
</span><span class="cm">     * contention among them a bit under most JVMs.  (3) internal
</span><span class="cm">     * control methods (4) callbacks and other support for
</span><span class="cm">     * ForkJoinTask and ForkJoinWorkerThread classes, (5) exported
</span><span class="cm">     * methods (plus a few little helpers). (6) static block
</span><span class="cm">     * initializing all statics in a minimally dependent order.
</span><span class="cm">     * 
</span><span class="cm">     * 在这个文件中声明的顺序是：
</span><span class="cm">     * （1）静态
</span><span class="cm">     * （2）字段的声明（以及解包其中的一些时使用的常量），按大多数JVM下的顺序排列。 
</span><span class="cm">     * （3）内部控制方法
</span><span class="cm">     * （4）回调和其他支持ForkJoinTask和ForkJoinWorkerThread类，
</span><span class="cm">     * （5）导出方法（加上一些小助手）。 
</span><span class="cm">     * （6）静态块以最小依赖的顺序初始化所有静态。
</span><span class="cm">     */</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="2forkjoinpool实现-forkjoinworkerthreadfactory">2.ForkJoinPool实现 ForkJoinWorkerThreadFactory</h3>
<p>创建新的ForkJoinWorkerThread的工厂</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">    <span class="cm">/**
</span><span class="cm">     * Factory for creating new {@link ForkJoinWorkerThread}s.
</span><span class="cm">     * A {@code ForkJoinWorkerThreadFactory} must be defined and used
</span><span class="cm">     * for {@code ForkJoinWorkerThread} subclasses that extend base
</span><span class="cm">     * functionality or initialize threads with different contexts.
</span><span class="cm">     * 用于创建新的ForkJoinWorkerThread的工厂。必须定义一个ForkJoinWorkerThreadFactory，
</span><span class="cm">     * 并将其用于扩展基本功能或使用不同上下文初始化线程的ForkJoinWorkerThread子类。
</span><span class="cm">     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">interface</span> <span class="nc">ForkJoinWorkerThreadFactory</span> <span class="o">{</span>
        <span class="cm">/**
</span><span class="cm">         * Returns a new worker thread operating in the given pool.
</span><span class="cm">         *
</span><span class="cm">         * @param pool the pool this thread works in
</span><span class="cm">         * @throws NullPointerException if the pool is null
</span><span class="cm">         */</span>
        <span class="kd">public</span> <span class="n">ForkJoinWorkerThread</span> <span class="nf">newThread</span><span class="o">(</span><span class="n">ForkJoinPool</span> <span class="n">pool</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
</span><span class="cm">     * Default ForkJoinWorkerThreadFactory implementation; creates a
</span><span class="cm">     * new ForkJoinWorkerThread.
</span><span class="cm">     * 默认的ForkJoinWorkerThreadFactory实现;创建一个新的ForkJoinWorkerThread。
</span><span class="cm">     */</span>
    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">DefaultForkJoinWorkerThreadFactory</span>
        <span class="kd">implements</span> <span class="n">ForkJoinWorkerThreadFactory</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="n">ForkJoinWorkerThread</span> <span class="nf">newThread</span><span class="o">(</span><span class="n">ForkJoinPool</span> <span class="n">pool</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="n">ForkJoinWorkerThread</span><span class="o">(</span><span class="n">pool</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="3forkjoinworkerthread-工作线程">3.ForkJoinWorkerThread 工作线程</h3>
<pre><code>ForkJoinWorkerThread继承Thread
</code></pre>
<h4 id="1forkjoinworkerthread构造">(1).ForkJoinWorkerThread构造</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span><span class="lnt">233
</span><span class="lnt">234
</span><span class="lnt">235
</span><span class="lnt">236
</span><span class="lnt">237
</span><span class="lnt">238
</span><span class="lnt">239
</span><span class="lnt">240
</span><span class="lnt">241
</span><span class="lnt">242
</span><span class="lnt">243
</span><span class="lnt">244
</span><span class="lnt">245
</span><span class="lnt">246
</span><span class="lnt">247
</span><span class="lnt">248
</span><span class="lnt">249
</span><span class="lnt">250
</span><span class="lnt">251
</span><span class="lnt">252
</span><span class="lnt">253
</span><span class="lnt">254
</span><span class="lnt">255
</span><span class="lnt">256
</span><span class="lnt">257
</span><span class="lnt">258
</span><span class="lnt">259
</span><span class="lnt">260
</span><span class="lnt">261
</span><span class="lnt">262
</span><span class="lnt">263
</span><span class="lnt">264
</span><span class="lnt">265
</span><span class="lnt">266
</span><span class="lnt">267
</span><span class="lnt">268
</span><span class="lnt">269
</span><span class="lnt">270
</span><span class="lnt">271
</span><span class="lnt">272
</span><span class="lnt">273
</span><span class="lnt">274
</span><span class="lnt">275
</span><span class="lnt">276
</span><span class="lnt">277
</span><span class="lnt">278
</span><span class="lnt">279
</span><span class="lnt">280
</span><span class="lnt">281
</span><span class="lnt">282
</span><span class="lnt">283
</span><span class="lnt">284
</span><span class="lnt">285
</span><span class="lnt">286
</span><span class="lnt">287
</span><span class="lnt">288
</span><span class="lnt">289
</span><span class="lnt">290
</span><span class="lnt">291
</span><span class="lnt">292
</span><span class="lnt">293
</span><span class="lnt">294
</span><span class="lnt">295
</span><span class="lnt">296
</span><span class="lnt">297
</span><span class="lnt">298
</span><span class="lnt">299
</span><span class="lnt">300
</span><span class="lnt">301
</span><span class="lnt">302
</span><span class="lnt">303
</span><span class="lnt">304
</span><span class="lnt">305
</span><span class="lnt">306
</span><span class="lnt">307
</span><span class="lnt">308
</span><span class="lnt">309
</span><span class="lnt">310
</span><span class="lnt">311
</span><span class="lnt">312
</span><span class="lnt">313
</span><span class="lnt">314
</span><span class="lnt">315
</span><span class="lnt">316
</span><span class="lnt">317
</span><span class="lnt">318
</span><span class="lnt">319
</span><span class="lnt">320
</span><span class="lnt">321
</span><span class="lnt">322
</span><span class="lnt">323
</span><span class="lnt">324
</span><span class="lnt">325
</span><span class="lnt">326
</span><span class="lnt">327
</span><span class="lnt">328
</span><span class="lnt">329
</span><span class="lnt">330
</span><span class="lnt">331
</span><span class="lnt">332
</span><span class="lnt">333
</span><span class="lnt">334
</span><span class="lnt">335
</span><span class="lnt">336
</span><span class="lnt">337
</span><span class="lnt">338
</span><span class="lnt">339
</span><span class="lnt">340
</span><span class="lnt">341
</span><span class="lnt">342
</span><span class="lnt">343
</span><span class="lnt">344
</span><span class="lnt">345
</span><span class="lnt">346
</span><span class="lnt">347
</span><span class="lnt">348
</span><span class="lnt">349
</span><span class="lnt">350
</span><span class="lnt">351
</span><span class="lnt">352
</span><span class="lnt">353
</span><span class="lnt">354
</span><span class="lnt">355
</span><span class="lnt">356
</span><span class="lnt">357
</span><span class="lnt">358
</span><span class="lnt">359
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ForkJoinWorkerThread</span> <span class="kd">extends</span> <span class="n">Thread</span> <span class="o">{</span>
    <span class="cm">/*
</span><span class="cm">     * Overview:
</span><span class="cm">     *
</span><span class="cm">     * ForkJoinWorkerThreads are managed by ForkJoinPools and perform
</span><span class="cm">     * ForkJoinTasks. This class includes bookkeeping in support of
</span><span class="cm">     * worker activation, suspension, and lifecycle control described
</span><span class="cm">     * in more detail in the internal documentation of class
</span><span class="cm">     * ForkJoinPool. And as described further below, this class also
</span><span class="cm">     * includes special-cased support for some ForkJoinTask
</span><span class="cm">     * methods. But the main mechanics involve work-stealing:
</span><span class="cm">     * 
</span><span class="cm">     * ForkJoinWorkerThreads由ForkJoinPools管理并执行ForkJoinTasks。本课程包括记录，以支持工作人员激活，暂停和生命周期控制，
</span><span class="cm">     * 在ForkJoinPool类的内部文档中有更详细的描述。如下所述，这个类还包括对某些ForkJoinTask方法的特殊支持。但主要的机制涉及盗窃工作：
</span><span class="cm">     *
</span><span class="cm">     * Work-stealing queues are special forms of Deques that support
</span><span class="cm">     * only three of the four possible end-operations -- push, pop,
</span><span class="cm">     * and deq (aka steal), under the further constraints that push
</span><span class="cm">     * and pop are called only from the owning thread, while deq may
</span><span class="cm">     * be called from other threads.  (If you are unfamiliar with
</span><span class="cm">     * them, you probably want to read Herlihy and Shavit&#39;s book &#34;The
</span><span class="cm">     * Art of Multiprocessor programming&#34;, chapter 16 describing these
</span><span class="cm">     * in more detail before proceeding.)  The main work-stealing
</span><span class="cm">     * queue design is roughly similar to those in the papers &#34;Dynamic
</span><span class="cm">     * Circular Work-Stealing Deque&#34; by Chase and Lev, SPAA 2005
</span><span class="cm">     * (http://research.sun.com/scalable/pubs/index.html) and
</span><span class="cm">     * &#34;Idempotent work stealing&#34; by Michael, Saraswat, and Vechev,
</span><span class="cm">     * PPoPP 2009 (http://portal.acm.org/citation.cfm?id=1504186).
</span><span class="cm">     * The main differences ultimately stem from gc requirements that
</span><span class="cm">     * we null out taken slots as soon as we can, to maintain as small
</span><span class="cm">     * a footprint as possible even in programs generating huge
</span><span class="cm">     * numbers of tasks. To accomplish this, we shift the CAS
</span><span class="cm">     * arbitrating pop vs deq (steal) from being on the indices
</span><span class="cm">     * (&#34;queueBase&#34; and &#34;queueTop&#34;) to the slots themselves (mainly
</span><span class="cm">     * via method &#34;casSlotNull()&#34;). So, both a successful pop and deq
</span><span class="cm">     * mainly entail a CAS of a slot from non-null to null.  Because
</span><span class="cm">     * we rely on CASes of references, we do not need tag bits on
</span><span class="cm">     * queueBase or queueTop.  They are simple ints as used in any
</span><span class="cm">     * circular array-based queue (see for example ArrayDeque).
</span><span class="cm">     * Updates to the indices must still be ordered in a way that
</span><span class="cm">     * guarantees that queueTop == queueBase means the queue is empty,
</span><span class="cm">     * but otherwise may err on the side of possibly making the queue
</span><span class="cm">     * appear nonempty when a push, pop, or deq have not fully
</span><span class="cm">     * committed. Note that this means that the deq operation,
</span><span class="cm">     * considered individually, is not wait-free. One thief cannot
</span><span class="cm">     * successfully continue until another in-progress one (or, if
</span><span class="cm">     * previously empty, a push) completes.  However, in the
</span><span class="cm">     * aggregate, we ensure at least probabilistic non-blockingness.
</span><span class="cm">     * If an attempted steal fails, a thief always chooses a different
</span><span class="cm">     * random victim target to try next. So, in order for one thief to
</span><span class="cm">     * progress, it suffices for any in-progress deq or new push on
</span><span class="cm">     * any empty queue to complete.
</span><span class="cm">     * 
</span><span class="cm">     * 窃取队列是Deques的特殊形式，它只支持四种可能的最终操作中的三种 - push，pop和deq（aka steal），
</span><span class="cm">     * 在push和pop只能从拥有的线程中被调用的同时， deq可能会被其他线程调用。 
</span><span class="cm">     * （如果您不熟悉这些内容，您可能需要阅读Herlihy和Shavit的书&#34;多处理器编程的艺术&#34;，第16章在继续之前详细描述了这些内容）。
</span><span class="cm">     * 主要的工作队列设计大致类似于Chase和Lev撰写的&#34;Dynamic Circular Work-Stealing Deque&#34;，SPAA 2005（http://research.sun.com/scalable/pubs/index.html）
</span><span class="cm">     * 和Michael，Saraswat和Vechev的&#34;幂等工作窃取&#34;PPoPP 2009（http://portal.acm.org/citation.cfm?id=1504186）。主要的差异最终来源于gc的要求，
</span><span class="cm">     * 我们尽可能地尽快地将空位排除在外，即使在产生大量任务的程序中，也尽可能地保持足够小的空间。
</span><span class="cm">     * 为了实现这一点，我们将CAS仲裁pop和deq（steal）从指标（&#34;queueBase&#34;和&#34;queueTop&#34;）转移到槽本身（主要通过方法&#34;casSlotNull（）&#34;）。
</span><span class="cm">     * 所以，一个成功的pop和deq主要包含一个从非null到null的时隙的CAS。因为我们依赖于引用的CASes，
</span><span class="cm">     * 所以我们不需要queueBase或queueTop上的标签位。它们是用于任何基于循环数组的队列中的简单整数（参见例如ArrayDeque）。
</span><span class="cm">     * 对索引的更新仍然必须以保证queueTop == queueBase意味着队列为空的方式排序，否则在push，pop或deq未完全提交时可能使队列显示为非空。
</span><span class="cm">     * 请注意，这意味着单独考虑deq操作并非等待。一个小偷不能成功地继续下去，直到另一个小偷（或者，如果先前是空的，推）完成。
</span><span class="cm">     * 但总的来说，我们至少保证概率性的非阻塞性。如果一次偷窃失败，一个小偷总是选择一个不同的随机受害者目标来尝试下一个。
</span><span class="cm">     * 所以，为了让一个小偷进步，只要任何空队列中的任何正在进行的排队或新推进就足以完成。
</span><span class="cm">     *
</span><span class="cm">     * This approach also enables support for &#34;async mode&#34; where local
</span><span class="cm">     * task processing is in FIFO, not LIFO order; simply by using a
</span><span class="cm">     * version of deq rather than pop when locallyFifo is true (as set
</span><span class="cm">     * by the ForkJoinPool).  This allows use in message-passing
</span><span class="cm">     * frameworks in which tasks are never joined.  However neither
</span><span class="cm">     * mode considers affinities, loads, cache localities, etc, so
</span><span class="cm">     * rarely provide the best possible performance on a given
</span><span class="cm">     * machine, but portably provide good throughput by averaging over
</span><span class="cm">     * these factors.  (Further, even if we did try to use such
</span><span class="cm">     * information, we do not usually have a basis for exploiting
</span><span class="cm">     * it. For example, some sets of tasks profit from cache
</span><span class="cm">     * affinities, but others are harmed by cache pollution effects.)
</span><span class="cm">     * 
</span><span class="cm">     * 这种方法还支持&#34;异步模式&#34;，其中本地任务处理处于FIFO中，而不是LIFO命令;当localFifo为true时（通过ForkJoinPool设置），
</span><span class="cm">     * 只需使用deq版本而不是pop。这允许在消息传递框架中使用，其中任务从未被加入。然而，这两种模式都不考虑亲和性，负载，缓存区域等，
</span><span class="cm">     * 因此很少在给定的机器上提供最好的性能，但是通过对这些因素进行平均，可移植性提供了良好的吞吐量。 
</span><span class="cm">     * （另外，即使我们试图使用这些信息，通常也没有开发它的依据，例如，某些任务从缓存关系中获益，而另外一些则受到缓存污染的影响。
</span><span class="cm">     *
</span><span class="cm">     * When a worker would otherwise be blocked waiting to join a
</span><span class="cm">     * task, it first tries a form of linear helping: Each worker
</span><span class="cm">     * records (in field currentSteal) the most recent task it stole
</span><span class="cm">     * from some other worker. Plus, it records (in field currentJoin)
</span><span class="cm">     * the task it is currently actively joining. Method joinTask uses
</span><span class="cm">     * these markers to try to find a worker to help (i.e., steal back
</span><span class="cm">     * a task from and execute it) that could hasten completion of the
</span><span class="cm">     * actively joined task. In essence, the joiner executes a task
</span><span class="cm">     * that would be on its own local deque had the to-be-joined task
</span><span class="cm">     * not been stolen. This may be seen as a conservative variant of
</span><span class="cm">     * the approach in Wagner &amp; Calder &#34;Leapfrogging: a portable
</span><span class="cm">     * technique for implementing efficient futures&#34; SIGPLAN Notices,
</span><span class="cm">     * 1993 (http://portal.acm.org/citation.cfm?id=155354). It differs
</span><span class="cm">     * in that: (1) We only maintain dependency links across workers
</span><span class="cm">     * upon steals, rather than use per-task bookkeeping.  This may
</span><span class="cm">     * require a linear scan of workers array to locate stealers, but
</span><span class="cm">     * usually doesn&#39;t because stealers leave hints (that may become
</span><span class="cm">     * stale/wrong) of where to locate them. This isolates cost to
</span><span class="cm">     * when it is needed, rather than adding to per-task overhead.
</span><span class="cm">     * (2) It is &#34;shallow&#34;, ignoring nesting and potentially cyclic
</span><span class="cm">     * mutual steals.  (3) It is intentionally racy: field currentJoin
</span><span class="cm">     * is updated only while actively joining, which means that we
</span><span class="cm">     * miss links in the chain during long-lived tasks, GC stalls etc
</span><span class="cm">     * (which is OK since blocking in such cases is usually a good
</span><span class="cm">     * idea).  (4) We bound the number of attempts to find work (see
</span><span class="cm">     * MAX_HELP) and fall back to suspending the worker and if
</span><span class="cm">     * necessary replacing it with another.
</span><span class="cm">     * 
</span><span class="cm">     * 当一个工人被阻止等待加入任务时，它首先尝试一种线性帮助的形式：每个工人记录（在currentSteal字段中）它从其他工人偷走的最近的任务。
</span><span class="cm">     * 另外，它记录（在field currentJoin中）当前正在加入的任务。方法joinTask使用这些标记来试图找到一个工作者来帮助（即从任务中偷取并执行它），
</span><span class="cm">     * 这可以加快主动连接的任务的完成。从本质上来说，木匠执行一项任务，如果没有被盗的话，那么这个任务就可以在自己的本地装备上。
</span><span class="cm">     * 这可能被看作是Wagner和Calder&#34;跳跃：一种实现有效期货的便携式技术&#34;的SIGPLAN公告1993年版（http://portal.acm.org/citation.cfm?id=155354）
</span><span class="cm">     * 的一种保守的变体形式。
</span><span class="cm">     * 它的不同之处在于：
</span><span class="cm">     * （1）我们只保留偷工作中的工人之间的依赖关系，而不是使用按任务记账。这可能需要对工人阵列进行线性扫描以确定盗贼的位置，但通常不会因为
</span><span class="cm">     * 偷窃者留下提示（可能会变得陈旧/错误）来确定他们的位置。这将成本与需求分离，而不是增加每个任务的开销。
</span><span class="cm">      * （2）&#34;浅&#34;，忽略嵌套和潜在的循环互抢。 
</span><span class="cm">      * （3）故意激活：字段currentJoin只在主动加入时更新，这意味着我们在长期任务，GC停顿等期间错过了链中的链接（这是可以的，
</span><span class="cm">      * 因为在这种情况下阻塞通常是个好主意） 。 
</span><span class="cm">      * （4）我们限制尝试找工作的次数（见MAX_HELP），然后回退到暂停工作，必要时替换成另一个。
</span><span class="cm">     *
</span><span class="cm">     * Efficient implementation of these algorithms currently relies
</span><span class="cm">     * on an uncomfortable amount of &#34;Unsafe&#34; mechanics. To maintain
</span><span class="cm">     * correct orderings, reads and writes of variable queueBase
</span><span class="cm">     * require volatile ordering.  Variable queueTop need not be
</span><span class="cm">     * volatile because non-local reads always follow those of
</span><span class="cm">     * queueBase.  Similarly, because they are protected by volatile
</span><span class="cm">     * queueBase reads, reads of the queue array and its slots by
</span><span class="cm">     * other threads do not need volatile load semantics, but writes
</span><span class="cm">     * (in push) require store order and CASes (in pop and deq)
</span><span class="cm">     * require (volatile) CAS semantics.  (Michael, Saraswat, and
</span><span class="cm">     * Vechev&#39;s algorithm has similar properties, but without support
</span><span class="cm">     * for nulling slots.)  Since these combinations aren&#39;t supported
</span><span class="cm">     * using ordinary volatiles, the only way to accomplish these
</span><span class="cm">     * efficiently is to use direct Unsafe calls. (Using external
</span><span class="cm">     * AtomicIntegers and AtomicReferenceArrays for the indices and
</span><span class="cm">     * array is significantly slower because of memory locality and
</span><span class="cm">     * indirection effects.)
</span><span class="cm">     * 
</span><span class="cm">     * 这些算法的高效实现目前依赖于不安全的&#34;不安全&#34;机制。为了保持正确的排序，读取和写入变量queueBase需要不稳定的顺序。
</span><span class="cm">     * 变量queueTop不必是易失性的，因为非本地读取总是遵循queueBase的读取。同样，由于它们受volatile QueueBase读取的保护，
</span><span class="cm">     * 因此其他线程对队列数组及其插槽的读取不需要易变的加载语义，但写入（推送）需要存储顺序，而CAS（pop和deq）需要（volatile） CAS语义。 
</span><span class="cm">     * （Michael，Saraswat和Vechev的算法具有相似的性质，但是不支持置零时隙）。由于这些组合不支持使用普通的挥发性物质，
</span><span class="cm">     * 唯一有效完成这些组合的方法是使用直接的不安全调用。 （对于索引和数组，使用外部AtomicIntegers和AtomicReferenceArrays要慢得多，
</span><span class="cm">     * 因为内存局部性和间接效应。）
</span><span class="cm">     *
</span><span class="cm">     * Further, performance on most platforms is very sensitive to
</span><span class="cm">     * placement and sizing of the (resizable) queue array.  Even
</span><span class="cm">     * though these queues don&#39;t usually become all that big, the
</span><span class="cm">     * initial size must be large enough to counteract cache
</span><span class="cm">     * contention effects across multiple queues (especially in the
</span><span class="cm">     * presence of GC cardmarking). Also, to improve thread-locality,
</span><span class="cm">     * queues are initialized after starting.
</span><span class="cm">     * 此外，大多数平台上的性能对（可调整大小）队列阵列的放置和大小非常敏感。即使这些队列通常不会变得那么大，但是初始大小必须足够大以抵消多
</span><span class="cm">     * 个队列中的缓存争用效应（特别是在GC卡标记的情况下）。而且，为了改善线程局部性，队列在启动之后被初始化。
</span><span class="cm">     */</span>

    <span class="cm">/**
</span><span class="cm">     * Mask for pool indices encoded as shorts
</span><span class="cm">     * 用于将池索引编码为“空”的掩码
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span>  <span class="n">SMASK</span>  <span class="o">=</span> <span class="n">0xffff</span><span class="o">;</span>

    <span class="cm">/**
</span><span class="cm">     * Capacity of work-stealing queue array upon initialization.
</span><span class="cm">     * Must be a power of two. Initial size must be at least 4, but is
</span><span class="cm">     * padded to minimize cache effects.
</span><span class="cm">     * 初始化时的工作窃取队列数组的容量。必须是两幂次方。初始大小必须至少为4，但被填充以最小化缓存效果。
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">INITIAL_QUEUE_CAPACITY</span> <span class="o">=</span> <span class="n">1</span> <span class="o">&lt;&lt;</span> <span class="n">13</span><span class="o">;</span> <span class="c1">//4096
</span><span class="c1"></span>
    <span class="cm">/**
</span><span class="cm">     * Maximum size for queue array. Must be a power of two
</span><span class="cm">     * less than or equal to 1 &lt;&lt; (31 - width of array entry) to
</span><span class="cm">     * ensure lack of index wraparound, but is capped at a lower
</span><span class="cm">     * value to help users trap runaway computations.
</span><span class="cm">     * 队列数组的最大大小。必须是小于或等于1 &lt; &lt;(31 -宽度的数组条目)的幂，以确保缺少索引wraparound，但要以较低的值限制，以帮助用户捕获失控的计算。
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MAXIMUM_QUEUE_CAPACITY</span> <span class="o">=</span> <span class="n">1</span> <span class="o">&lt;&lt;</span> <span class="n">24</span><span class="o">;</span> <span class="c1">// 16M
</span><span class="c1"></span>
    <span class="cm">/**
</span><span class="cm">     * The work-stealing queue array. Size must be a power of two.
</span><span class="cm">     * Initialized when started (as oposed to when constructed), to
</span><span class="cm">     * improve memory locality.
</span><span class="cm">     * 工作-窃取队列数组。大小必须是2的幂。初始化时(作为构建时的oposed)，用于改善内存位置。
</span><span class="cm">     */</span>
    <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;[]</span> <span class="n">queue</span><span class="o">;</span>

    <span class="cm">/**
</span><span class="cm">     * The pool this thread works in. Accessed directly by ForkJoinTask.
</span><span class="cm">     * 此线程工作的池。直接由ForkJoinTask访问。
</span><span class="cm">     */</span>
    <span class="kd">final</span> <span class="n">ForkJoinPool</span> <span class="n">pool</span><span class="o">;</span>

    <span class="cm">/**
</span><span class="cm">     * Index (mod queue.length) of next queue slot to push to or pop
</span><span class="cm">     * from. It is written only by owner thread, and accessed by other
</span><span class="cm">     * threads only after reading (volatile) queueBase.  Both queueTop
</span><span class="cm">     * and queueBase are allowed to wrap around on overflow, but
</span><span class="cm">     * (queueTop - queueBase) still estimates size.
</span><span class="cm">     * 下一个队列插槽的索引（取模 队列长度）push或pop。它仅由所有者线程写入，并且只有在读取（volatile）queueBase之后才被其他线程访问。 
</span><span class="cm">     * queueTop和queueBase都允许环绕溢出，但（queueTop - queueBase）仍然估计大小。
</span><span class="cm">     */</span>
    <span class="kt">int</span> <span class="n">queueTop</span><span class="o">;</span>

    <span class="cm">/**
</span><span class="cm">     * Index (mod queue.length) of least valid queue slot, which is
</span><span class="cm">     * always the next position to steal from if nonempty.
</span><span class="cm">     * 索引（取模 队列长度）最小有效队列时隙，它总是下一个从非空位置开始的位置。
</span><span class="cm">     */</span>
    <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">queueBase</span><span class="o">;</span>

    <span class="cm">/**
</span><span class="cm">     * The index of most recent stealer, used as a hint to avoid
</span><span class="cm">     * traversal in method helpJoinTask. This is only a hint because a
</span><span class="cm">     * worker might have had multiple steals and this only holds one
</span><span class="cm">     * of them (usually the most current). Declared non-volatile,
</span><span class="cm">     * relying on other prevailing sync to keep reasonably current.
</span><span class="cm">     * 
</span><span class="cm">     * 最近的stealer的索引，用作避免在方法helpJoinTask中遍历的提示。这只是一个暗示，因为一个工作人员可能有多次抢断，
</span><span class="cm">     * 而这只能保留其中一个（通常是最新的）。声明非易失性，依靠其他流行的同步保持合理的最新。
</span><span class="cm">     */</span>
    <span class="kt">int</span> <span class="n">stealHint</span><span class="o">;</span>

    <span class="cm">/**
</span><span class="cm">     * Index of this worker in pool array. Set once by pool before
</span><span class="cm">     * running, and accessed directly by pool to locate this worker in
</span><span class="cm">     * its workers array.
</span><span class="cm">     * 这个worker在pool数组中的索引。在运行前通过池设置一次，并通过池直接访问，以便在其工作人员数组中找到该worker。
</span><span class="cm">     */</span>
    <span class="kd">final</span> <span class="kt">int</span> <span class="n">poolIndex</span><span class="o">;</span>

    <span class="cm">/**
</span><span class="cm">     * Encoded record for pool task waits. Usages are always
</span><span class="cm">     * surrounded by volatile reads/writes
</span><span class="cm">     * 编码记录池任务等待。用法volatile读/写
</span><span class="cm">     */</span>
    <span class="kt">int</span> <span class="n">nextWait</span><span class="o">;</span>

    <span class="cm">/**
</span><span class="cm">     * Complement of poolIndex, offset by count of entries of task
</span><span class="cm">     * waits. Accessed by ForkJoinPool to manage event waiters.
</span><span class="cm">     * 补充的池索引，通过任务的条目计数来抵消。通过Fork连接池访问以管理事件服务员。
</span><span class="cm">     */</span>
    <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">eventCount</span><span class="o">;</span>

    <span class="cm">/**
</span><span class="cm">     * Seed for random number generator for choosing steal victims.
</span><span class="cm">     * Uses Marsaglia xorshift. Must be initialized as nonzero.
</span><span class="cm">     * 随机数发生器的种子选择窃取受害者。 使用Marsaglia xorshift。必须初始化为非零。
</span><span class="cm">     */</span>
    <span class="kt">int</span> <span class="n">seed</span><span class="o">;</span>

    <span class="cm">/**
</span><span class="cm">     * Number of steals. Directly accessed (and reset) by pool when
</span><span class="cm">     * idle.
</span><span class="cm">     * 抢断次数，空闲时由池直接访问(和重置)。
</span><span class="cm">     */</span>
    <span class="kt">int</span> <span class="n">stealCount</span><span class="o">;</span>

    <span class="cm">/**
</span><span class="cm">     * True if this worker should or did terminate
</span><span class="cm">     * 如果这个工人应该或确实终止了
</span><span class="cm">     */</span>
    <span class="kd">volatile</span> <span class="kt">boolean</span> <span class="n">terminate</span><span class="o">;</span>

    <span class="cm">/**
</span><span class="cm">     * Set to true before LockSupport.park; false on return
</span><span class="cm">     * 在LockSupport.park之前设置为true;假 return
</span><span class="cm">     */</span>
    <span class="kd">volatile</span> <span class="kt">boolean</span> <span class="n">parked</span><span class="o">;</span>

    <span class="cm">/**
</span><span class="cm">     * True if use local fifo, not default lifo, for local polling.
</span><span class="cm">     * Shadows value from ForkJoinPool.
</span><span class="cm">     * 如果使用本地的fifo，而不是默认的lifo，则为真正的本地轮询。来自ForkJoinPool的阴影值。
</span><span class="cm">     */</span>
    <span class="kd">final</span> <span class="kt">boolean</span> <span class="n">locallyFifo</span><span class="o">;</span>

    <span class="cm">/**
</span><span class="cm">     * The task most recently stolen from another worker (or
</span><span class="cm">     * submission queue).  All uses are surrounded by enough volatile
</span><span class="cm">     * reads/writes to maintain as non-volatile.
</span><span class="cm">     * 最近从另一个工作人员（或提交队列）中窃取的任务。所有用途都被足够的volatile读/写所包围，以保持non-volatile。
</span><span class="cm">     */</span>
    <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;</span> <span class="n">currentSteal</span><span class="o">;</span>

    <span class="cm">/**
</span><span class="cm">     * The task currently being joined, set only when actively trying
</span><span class="cm">     * to help other stealers in helpJoinTask. All uses are surrounded
</span><span class="cm">     * by enough volatile reads/writes to maintain as non-volatile.
</span><span class="cm">     * 目前正在加入的任务，只有在主动尝试帮助其他盗取helpJoinTask时才设置。所有的使用都被足够的volatile读/写所包围，以保持非易失性。
</span><span class="cm">     */</span>
    <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;</span> <span class="n">currentJoin</span><span class="o">;</span>

    <span class="cm">/**
</span><span class="cm">     * Creates a ForkJoinWorkerThread operating in the given pool.
</span><span class="cm">     * 创建在给定池中操作的Fork连接工作线程。
</span><span class="cm">     * @param pool the pool this thread works in
</span><span class="cm">     * @throws NullPointerException if pool is null
</span><span class="cm">     */</span>
    <span class="kd">protected</span> <span class="nf">ForkJoinWorkerThread</span><span class="o">(</span><span class="n">ForkJoinPool</span> <span class="n">pool</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">pool</span><span class="o">.</span><span class="na">nextWorkerName</span><span class="o">());</span>
        <span class="k">this</span><span class="o">.</span><span class="na">pool</span> <span class="o">=</span> <span class="n">pool</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="na">registerWorker</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
        <span class="n">poolIndex</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span>
        <span class="n">eventCount</span> <span class="o">=</span> <span class="o">~</span><span class="n">k</span> <span class="o">&amp;</span> <span class="n">SMASK</span><span class="o">;</span> <span class="c1">// clear wait count 
</span><span class="c1"></span>        <span class="n">locallyFifo</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="na">locallyFifo</span><span class="o">;</span>
        <span class="n">Thread</span><span class="o">.</span><span class="na">UncaughtExceptionHandler</span> <span class="n">ueh</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="na">ueh</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">ueh</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">setUncaughtExceptionHandler</span><span class="o">(</span><span class="n">ueh</span><span class="o">);</span>
        <span class="n">setDaemon</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="cm">/**
</span><span class="cm">      * CASes slot i of array q from t to null. Caller must ensure q is
</span><span class="cm">      * non-null and index is in range.
</span><span class="cm">      * 从t到null的数组q的槽i。调用者必须确保q是非空的，并且索引在范围内。
</span><span class="cm">      */</span>
     <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">casSlotNull</span><span class="o">(</span><span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;[]</span> <span class="n">q</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span>
                                              <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
         <span class="k">return</span> <span class="n">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapObject</span><span class="o">(</span><span class="n">q</span><span class="o">,</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">ASHIFT</span><span class="o">)</span> <span class="o">+</span> <span class="n">ABASE</span><span class="o">,</span> <span class="n">t</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
     <span class="o">}</span>
 
     <span class="cm">/**
</span><span class="cm">      * Performs a volatile write of the given task at given slot of
</span><span class="cm">      * array q.  Caller must ensure q is non-null and index is in
</span><span class="cm">      * range. This method is used only during resets and backouts.
</span><span class="cm">      * 在给定的数组q的位置上执行给定任务的不稳定的写入。调用者必须确保q是非空的，并且索引在范围内。此方法仅在重新设置和退出时使用。
</span><span class="cm">      */</span>
     <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">writeSlot</span><span class="o">(</span><span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;[]</span> <span class="n">q</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span>
                                         <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
         <span class="n">UNSAFE</span><span class="o">.</span><span class="na">putObjectVolatile</span><span class="o">(</span><span class="n">q</span><span class="o">,</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">ASHIFT</span><span class="o">)</span> <span class="o">+</span> <span class="n">ABASE</span><span class="o">,</span> <span class="n">t</span><span class="o">);</span>
     <span class="o">}</span>   
 <span class="c1">// Unsafe mechanics
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">sun</span><span class="o">.</span><span class="na">misc</span><span class="o">.</span><span class="na">Unsafe</span> <span class="n">UNSAFE</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">ABASE</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">ASHIFT</span><span class="o">;</span>

    <span class="kd">static</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">s</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">UNSAFE</span> <span class="o">=</span> <span class="n">sun</span><span class="o">.</span><span class="na">misc</span><span class="o">.</span><span class="na">Unsafe</span><span class="o">.</span><span class="na">getUnsafe</span><span class="o">();</span>
            <span class="n">Class</span> <span class="n">a</span> <span class="o">=</span> <span class="n">ForkJoinTask</span><span class="o">[].</span><span class="na">class</span><span class="o">;</span>
            <span class="n">ABASE</span> <span class="o">=</span> <span class="n">UNSAFE</span><span class="o">.</span><span class="na">arrayBaseOffset</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">UNSAFE</span><span class="o">.</span><span class="na">arrayIndexScale</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">Error</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">s</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">s</span><span class="o">-</span><span class="n">1</span><span class="o">))</span> <span class="o">!=</span> <span class="n">0</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">Error</span><span class="o">(</span><span class="s">&#34;data type scale not a power of two&#34;</span><span class="o">);</span>
        <span class="n">ASHIFT</span> <span class="o">=</span> <span class="n">31</span> <span class="o">-</span> <span class="n">Integer</span><span class="o">.</span><span class="na">numberOfLeadingZeros</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>    
<span class="o">}</span>    
</code></pre></td></tr></table>
</div>
</div><h4 id="2run-线程执行方法">(2).run 线程执行方法</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">    <span class="cm">/**
</span><span class="cm">     * This method is required to be public, but should never be
</span><span class="cm">     * called explicitly. It performs the main run loop to execute
</span><span class="cm">     * {@link ForkJoinTask}s.
</span><span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">Throwable</span> <span class="n">exception</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">onStart</span><span class="o">();</span>
            <span class="n">pool</span><span class="o">.</span><span class="na">work</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Throwable</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">exception</span> <span class="o">=</span> <span class="n">ex</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">onTermination</span><span class="o">(</span><span class="n">exception</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="cm">/**
</span><span class="cm">     * Initializes internal state after construction but before
</span><span class="cm">     * processing any tasks. If you override this method, you must
</span><span class="cm">     * invoke {@code super.onStart()} at the beginning of the method.
</span><span class="cm">     * Initialization requires care: Most fields must have legal
</span><span class="cm">     * default values, to ensure that attempted accesses from other
</span><span class="cm">     * threads work correctly even before this thread starts
</span><span class="cm">     * processing tasks.
</span><span class="cm">     */</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onStart</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;[</span><span class="n">INITIAL_QUEUE_CAPACITY</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="na">workerSeedGenerator</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
        <span class="n">seed</span> <span class="o">=</span> <span class="o">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">?</span> <span class="n">1</span> <span class="o">:</span> <span class="n">r</span><span class="o">;</span> <span class="c1">//  must be nonzero
</span><span class="c1"></span>    <span class="o">}</span>
    
    <span class="cm">/**
</span><span class="cm">     * Performs cleanup associated with termination of this worker
</span><span class="cm">     * thread.  If you override this method, you must invoke
</span><span class="cm">     * {@code super.onTermination} at the end of the overridden method.
</span><span class="cm">     *
</span><span class="cm">     * @param exception the exception causing this thread to abort due
</span><span class="cm">     * to an unrecoverable error, or {@code null} if completed normally
</span><span class="cm">     */</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onTermination</span><span class="o">(</span><span class="n">Throwable</span> <span class="n">exception</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">terminate</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="n">cancelTasks</span><span class="o">();</span>
            <span class="n">pool</span><span class="o">.</span><span class="na">deregisterWorker</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">exception</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Throwable</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>        <span class="c1">// Shouldn&#39;t ever happen
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">exception</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>      <span class="c1">// but if so, at least rethrown
</span><span class="c1"></span>                <span class="n">exception</span> <span class="o">=</span> <span class="n">ex</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">exception</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">UNSAFE</span><span class="o">.</span><span class="na">throwException</span><span class="o">(</span><span class="n">exception</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>    
</code></pre></td></tr></table>
</div>
</div><h4 id="3pushtask-添加任务">(3).pushTask 添加任务</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">  <span class="cm">/**
</span><span class="cm">     * Pushes a task. Call only from this thread.
</span><span class="cm">     *
</span><span class="cm">     * @param t the task. Caller must ensure non-null.
</span><span class="cm">     */</span>
    <span class="kd">final</span> <span class="kt">void</span> <span class="nf">pushTask</span><span class="o">(</span><span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;[]</span> <span class="n">q</span><span class="o">;</span> <span class="kt">int</span> <span class="n">s</span><span class="o">,</span> <span class="n">m</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">q</span> <span class="o">=</span> <span class="n">queue</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>    <span class="c1">// ignore if queue removed
</span><span class="c1"></span>            <span class="kt">long</span> <span class="n">u</span> <span class="o">=</span> <span class="o">(((</span><span class="n">s</span> <span class="o">=</span> <span class="n">queueTop</span><span class="o">)</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">m</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">))</span> <span class="o">&lt;&lt;</span> <span class="n">ASHIFT</span><span class="o">)</span> <span class="o">+</span> <span class="n">ABASE</span><span class="o">;</span>
            <span class="n">UNSAFE</span><span class="o">.</span><span class="na">putOrderedObject</span><span class="o">(</span><span class="n">q</span><span class="o">,</span> <span class="n">u</span><span class="o">,</span> <span class="n">t</span><span class="o">);</span>
            <span class="n">queueTop</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>         <span class="c1">// or use putOrderedInt
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">((</span><span class="n">s</span> <span class="o">-=</span> <span class="n">queueBase</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="n">2</span><span class="o">)</span>
                <span class="n">pool</span><span class="o">.</span><span class="na">signalWork</span><span class="o">();</span>
            <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">m</span><span class="o">)</span>
                <span class="n">growQueue</span><span class="o">();</span>  <span class="c1">//扩容
</span><span class="c1"></span>        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>扩容</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">    <span class="cm">/**
</span><span class="cm">     * Creates or doubles queue array.  Transfers elements by
</span><span class="cm">     * emulating steals (deqs) from old array and placing, oldest
</span><span class="cm">     * first, into new array.
</span><span class="cm">     * 创建或加倍队列数组。通过模拟从旧的数组和放置，最老的第一个，到新数组中的窃取(deqs)来传输元素。
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">growQueue</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;[]</span> <span class="n">oldQ</span> <span class="o">=</span> <span class="n">queue</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">oldQ</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">oldQ</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;&lt;</span> <span class="n">1</span> <span class="o">:</span> <span class="n">INITIAL_QUEUE_CAPACITY</span><span class="o">;</span><span class="c1">// 2倍扩容
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">MAXIMUM_QUEUE_CAPACITY</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">RejectedExecutionException</span><span class="o">(</span><span class="s">&#34;Queue capacity exceeded&#34;</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">INITIAL_QUEUE_CAPACITY</span><span class="o">)</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">INITIAL_QUEUE_CAPACITY</span><span class="o">;</span>
        <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;[]</span> <span class="n">q</span> <span class="o">=</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;[</span><span class="n">size</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">top</span> <span class="o">=</span> <span class="n">queueTop</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">oldMask</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">oldQ</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">oldMask</span> <span class="o">=</span> <span class="n">oldQ</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">queueBase</span><span class="o">;</span> <span class="n">b</span> <span class="o">!=</span> <span class="n">top</span><span class="o">;</span> <span class="o">++</span><span class="n">b</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">long</span> <span class="n">u</span> <span class="o">=</span> <span class="o">((</span><span class="n">b</span> <span class="o">&amp;</span> <span class="n">oldMask</span><span class="o">)</span> <span class="o">&lt;&lt;</span> <span class="n">ASHIFT</span><span class="o">)</span> <span class="o">+</span> <span class="n">ABASE</span><span class="o">;</span>
                <span class="n">Object</span> <span class="n">x</span> <span class="o">=</span> <span class="n">UNSAFE</span><span class="o">.</span><span class="na">getObjectVolatile</span><span class="o">(</span><span class="n">oldQ</span><span class="o">,</span> <span class="n">u</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapObject</span><span class="o">(</span><span class="n">oldQ</span><span class="o">,</span> <span class="n">u</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="kc">null</span><span class="o">))</span>
                    <span class="n">UNSAFE</span><span class="o">.</span><span class="na">putObjectVolatile</span>
                        <span class="o">(</span><span class="n">q</span><span class="o">,</span> <span class="o">((</span><span class="n">b</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="o">)</span> <span class="o">&lt;&lt;</span> <span class="n">ASHIFT</span><span class="o">)</span> <span class="o">+</span> <span class="n">ABASE</span><span class="o">,</span> <span class="n">x</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="4deqtask-头部出列任务">(4).deqTask 头部出列任务</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">    <span class="cm">/**
</span><span class="cm">     * Tries to take a task from the base of the queue, failing if
</span><span class="cm">     * empty or contended. Note: Specializations of this code appear
</span><span class="cm">     * in locallyDeqTask and elsewhere.
</span><span class="cm">     * 尝试从队列的底部执行任务，如果是空的或争用，则失败。注意:此代码的专门化出现在locallyDeqTask和其他地方。
</span><span class="cm">     * @return a task, or null if none or contended
</span><span class="cm">     */</span>
    <span class="kd">final</span> <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;</span> <span class="n">deqTask</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;</span> <span class="n">t</span><span class="o">;</span> <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;[]</span> <span class="n">q</span><span class="o">;</span> <span class="kt">int</span> <span class="n">b</span><span class="o">,</span> <span class="n">i</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">queueTop</span> <span class="o">!=</span> <span class="o">(</span><span class="n">b</span> <span class="o">=</span> <span class="n">queueBase</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
            <span class="o">(</span><span class="n">q</span> <span class="o">=</span> <span class="n">queue</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="c1">// must read q after b
</span><span class="c1"></span>            <span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">b</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="n">0</span> <span class="o">&amp;&amp;</span>
            <span class="o">(</span><span class="n">t</span> <span class="o">=</span> <span class="n">q</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">queueBase</span> <span class="o">==</span> <span class="n">b</span> <span class="o">&amp;&amp;</span>
            <span class="n">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapObject</span><span class="o">(</span><span class="n">q</span><span class="o">,</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">ASHIFT</span><span class="o">)</span> <span class="o">+</span> <span class="n">ABASE</span><span class="o">,</span> <span class="n">t</span><span class="o">,</span> <span class="kc">null</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">queueBase</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
            <span class="k">return</span> <span class="n">t</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="5locallydeqtask-头部出列任务">(5).locallyDeqTask 头部出列任务</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">    <span class="cm">/**
</span><span class="cm">     * Tries to take a task from the base of own queue.  Called only
</span><span class="cm">     * by this thread.
</span><span class="cm">     *尝试从自己的队列的基础上执行任务。只被这个线程调用。
</span><span class="cm">     * @return a task, or null if none
</span><span class="cm">     */</span>
    <span class="kd">final</span> <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;</span> <span class="n">locallyDeqTask</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;</span> <span class="n">t</span><span class="o">;</span> <span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">i</span><span class="o">;</span>
        <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;[]</span> <span class="n">q</span> <span class="o">=</span> <span class="n">queue</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">q</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">m</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">queueTop</span> <span class="o">!=</span> <span class="o">(</span><span class="n">b</span> <span class="o">=</span> <span class="n">queueBase</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">t</span> <span class="o">=</span> <span class="n">q</span><span class="o">[</span><span class="n">i</span> <span class="o">=</span> <span class="n">m</span> <span class="o">&amp;</span> <span class="n">b</span><span class="o">])</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span>
                    <span class="n">queueBase</span> <span class="o">==</span> <span class="n">b</span> <span class="o">&amp;&amp;</span>
                    <span class="n">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapObject</span><span class="o">(</span><span class="n">q</span><span class="o">,</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">ASHIFT</span><span class="o">)</span> <span class="o">+</span> <span class="n">ABASE</span><span class="o">,</span>
                                                <span class="n">t</span><span class="o">,</span> <span class="kc">null</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">queueBase</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
                    <span class="k">return</span> <span class="n">t</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="6poptask-尾部出列任务">(6).popTask 尾部出列任务</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">    <span class="cm">/**
</span><span class="cm">     * Returns a popped task, or null if empty.
</span><span class="cm">     * Called only by this thread.
</span><span class="cm">     * 返回一个弹出的任务，或者空的空值。只被这个线程调用。
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;</span> <span class="n">popTask</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">m</span><span class="o">;</span>
        <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;[]</span> <span class="n">q</span> <span class="o">=</span> <span class="n">queue</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">q</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">m</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">s</span><span class="o">;</span> <span class="o">(</span><span class="n">s</span> <span class="o">=</span> <span class="n">queueTop</span><span class="o">)</span> <span class="o">!=</span> <span class="n">queueBase</span><span class="o">;)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">m</span> <span class="o">&amp;</span> <span class="o">--</span><span class="n">s</span><span class="o">;</span>
                <span class="kt">long</span> <span class="n">u</span> <span class="o">=</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">ASHIFT</span><span class="o">)</span> <span class="o">+</span> <span class="n">ABASE</span><span class="o">;</span> <span class="c1">// raw offset
</span><span class="c1"></span>                <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">q</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>   <span class="c1">// lost to stealer
</span><span class="c1"></span>                    <span class="k">break</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapObject</span><span class="o">(</span><span class="n">q</span><span class="o">,</span> <span class="n">u</span><span class="o">,</span> <span class="n">t</span><span class="o">,</span> <span class="kc">null</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">queueTop</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span> <span class="c1">// or putOrderedInt
</span><span class="c1"></span>                    <span class="k">return</span> <span class="n">t</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="7unpushtask-最上面的元素是给定的任务时才会弹出">(7).unpushTask 最上面的元素是给定的任务时才会弹出</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">    <span class="cm">/**
</span><span class="cm">     * Specialized version of popTask to pop only if topmost element
</span><span class="cm">     * is the given task. Called only by this thread.
</span><span class="cm">     * 特殊版本的pop任务只有在最上面的元素是给定的任务时才会弹出。。只能由这个线程调用。
</span><span class="cm">     * @param t the task. Caller must ensure non-null.
</span><span class="cm">     */</span>
    <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">unpushTask</span><span class="o">(</span><span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;[]</span> <span class="n">q</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">s</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">q</span> <span class="o">=</span> <span class="n">queue</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">s</span> <span class="o">=</span> <span class="n">queueTop</span><span class="o">)</span> <span class="o">!=</span> <span class="n">queueBase</span> <span class="o">&amp;&amp;</span>
            <span class="n">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapObject</span>
            <span class="o">(</span><span class="n">q</span><span class="o">,</span> <span class="o">(((</span><span class="n">q</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="o">--</span><span class="n">s</span><span class="o">)</span> <span class="o">&lt;&lt;</span> <span class="n">ASHIFT</span><span class="o">)</span> <span class="o">+</span> <span class="n">ABASE</span><span class="o">,</span> <span class="n">t</span><span class="o">,</span> <span class="kc">null</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">queueTop</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span> <span class="c1">// or putOrderedInt
</span><span class="c1"></span>            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="8peektask-返回下一个任务不删除任务">(8).peekTask 返回下一个任务，不删除任务</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm">     * Returns next task, or null if empty or contended.
</span><span class="cm">     */</span>
    <span class="kd">final</span> <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;</span> <span class="n">peekTask</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">m</span><span class="o">;</span>
        <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;[]</span> <span class="n">q</span> <span class="o">=</span> <span class="n">queue</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">q</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">(</span><span class="n">m</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">locallyFifo</span> <span class="o">?</span> <span class="n">queueBase</span> <span class="o">:</span> <span class="o">(</span><span class="n">queueTop</span> <span class="o">-</span> <span class="n">1</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">q</span><span class="o">[</span><span class="n">i</span> <span class="o">&amp;</span> <span class="n">m</span><span class="o">];</span>
    <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="9-support-methods-for-forkjoinpool">(9). Support methods for ForkJoinPool</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">  <span class="cm">/**
</span><span class="cm">     * Runs the given task, plus any local tasks until queue is empty
</span><span class="cm">     * 运行给定的任务，再加上任何本地任务，直到队列为空
</span><span class="cm">     */</span>
    <span class="kd">final</span> <span class="kt">void</span> <span class="nf">execTask</span><span class="o">(</span><span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">currentSteal</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">t</span><span class="o">.</span><span class="na">doExec</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">queueTop</span> <span class="o">==</span> <span class="n">queueBase</span><span class="o">)</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">locallyFifo</span> <span class="o">?</span> <span class="n">locallyDeqTask</span><span class="o">()</span> <span class="o">:</span> <span class="n">popTask</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="o">++</span><span class="n">stealCount</span><span class="o">;</span>
        <span class="n">currentSteal</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
</span><span class="cm">     * Removes and cancels all tasks in queue.  Can be called from any
</span><span class="cm">     * thread.
</span><span class="cm">     * 删除并取消队列中的所有任务。可以从任何线程调用。
</span><span class="cm">     */</span>
    <span class="kd">final</span> <span class="kt">void</span> <span class="nf">cancelTasks</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;</span> <span class="n">cj</span> <span class="o">=</span> <span class="n">currentJoin</span><span class="o">;</span> <span class="c1">// try to cancel ongoing tasks
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">cj</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">cj</span><span class="o">.</span><span class="na">status</span> <span class="o">&gt;=</span> <span class="n">0</span><span class="o">)</span>
            <span class="n">cj</span><span class="o">.</span><span class="na">cancelIgnoringExceptions</span><span class="o">();</span>
        <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;</span> <span class="n">cs</span> <span class="o">=</span> <span class="n">currentSteal</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">cs</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">cs</span><span class="o">.</span><span class="na">status</span> <span class="o">&gt;=</span> <span class="n">0</span><span class="o">)</span>
            <span class="n">cs</span><span class="o">.</span><span class="na">cancelIgnoringExceptions</span><span class="o">();</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">queueBase</span> <span class="o">!=</span> <span class="n">queueTop</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">deqTask</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">t</span><span class="o">.</span><span class="na">cancelIgnoringExceptions</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/**
</span><span class="cm">     * Drains tasks to given collection c.
</span><span class="cm">     * 将任务分配到给定的集合c。
</span><span class="cm">     * @return the number of tasks drained
</span><span class="cm">     */</span>
    <span class="kd">final</span> <span class="kt">int</span> <span class="nf">drainTasksTo</span><span class="o">(</span><span class="n">Collection</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;&gt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">queueBase</span> <span class="o">!=</span> <span class="n">queueTop</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">deqTask</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">c</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
                <span class="o">++</span><span class="n">n</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">n</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="10-support-methods-for-forkjointask">(10). Support methods for ForkJoinTask</h4>
<ul>
<li>[1].pollTask 获取并删除本地或被窃取的任务。
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">    <span class="cm">/**
</span><span class="cm">     * Gets and removes a local or stolen task.
</span><span class="cm">     *
</span><span class="cm">     * @return a task, if available
</span><span class="cm">     */</span>
    <span class="kd">final</span> <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;</span> <span class="n">pollTask</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">ForkJoinWorkerThread</span><span class="o">[]</span> <span class="n">ws</span><span class="o">;</span>
        <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">pollLocalTask</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">(</span><span class="n">ws</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="na">workers</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">return</span> <span class="n">t</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">ws</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="c1">// cheap version of FJP.scan
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">steps</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="n">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">nextSeed</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">steps</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">ForkJoinWorkerThread</span> <span class="n">w</span> <span class="o">=</span> <span class="n">ws</span><span class="o">[(</span><span class="n">i</span><span class="o">++</span> <span class="o">+</span> <span class="n">r</span><span class="o">)</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">1</span><span class="o">)];</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">w</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">w</span><span class="o">.</span><span class="na">queueBase</span> <span class="o">!=</span> <span class="n">w</span><span class="o">.</span><span class="na">queueTop</span> <span class="o">&amp;&amp;</span> <span class="n">w</span><span class="o">.</span><span class="na">queue</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">t</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="na">deqTask</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="k">return</span> <span class="n">t</span><span class="o">;</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="cm">/**
</span><span class="cm">     * Computes next value for random victim probes and backoffs.
</span><span class="cm">     * Scans don&#39;t require a very high quality generator, but also not
</span><span class="cm">     * a crummy one.  Marsaglia xor-shift is cheap and works well
</span><span class="cm">     * enough.  Note: This is manually inlined in FJP.scan() to avoid
</span><span class="cm">     * writes inside busy loops.
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">nextSeed</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">seed</span><span class="o">;</span>
        <span class="n">r</span> <span class="o">^=</span> <span class="n">r</span> <span class="o">&lt;&lt;</span> <span class="n">13</span><span class="o">;</span>
        <span class="n">r</span> <span class="o">^=</span> <span class="n">r</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">17</span><span class="o">;</span>
        <span class="n">r</span> <span class="o">^=</span> <span class="n">r</span> <span class="o">&lt;&lt;</span> <span class="n">5</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">seed</span> <span class="o">=</span> <span class="n">r</span><span class="o">;</span>
    <span class="o">}</span>    
</code></pre></td></tr></table>
</div>
</div></li>
<li>[2].joinTask 可能运行一些任务和/或块，直到joinMe完成。
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"> <span class="cm">/**
</span><span class="cm">     * The maximum stolen-&gt;joining link depth allowed in helpJoinTask,
</span><span class="cm">     * as well as the maximum number of retries (allowing on average
</span><span class="cm">     * one staleness retry per level) per attempt to instead try
</span><span class="cm">     * compensation.  Depths for legitimate chains are unbounded, but
</span><span class="cm">     * we use a fixed constant to avoid (otherwise unchecked) cycles
</span><span class="cm">     * and bound staleness of traversal parameters at the expense of
</span><span class="cm">     * sometimes blocking when we could be helping.
</span><span class="cm">     * helpJoinTask中允许的最大stolen-&gt;joining连接深度，以及每次尝试尝试的最大重试次数(允许平均一次的跟踪重试)
</span><span class="cm">     * 以代替尝试补偿。合法链的深度是无限的，但我们使用一个固定的常量来避免（否则未检查）的周期，并限制遍历参数的陈旧性，代价是有时会阻塞我们的帮助。
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MAX_HELP</span> <span class="o">=</span> <span class="n">16</span><span class="o">;</span>
     
    <span class="cm">/**
</span><span class="cm">     * Possibly runs some tasks and/or blocks, until joinMe is done.
</span><span class="cm">     * 可能运行一些任务和/或块，直到joinMe完成。
</span><span class="cm">     * @param joinMe the task to join
</span><span class="cm">     * @return completion status on exit
</span><span class="cm">     */</span>
    <span class="kd">final</span> <span class="kt">int</span> <span class="nf">joinTask</span><span class="o">(</span><span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;</span> <span class="n">joinMe</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;</span> <span class="n">prevJoin</span> <span class="o">=</span> <span class="n">currentJoin</span><span class="o">;</span>
        <span class="n">currentJoin</span> <span class="o">=</span> <span class="n">joinMe</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">s</span><span class="o">,</span> <span class="n">retries</span> <span class="o">=</span> <span class="n">MAX_HELP</span><span class="o">;;)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">s</span> <span class="o">=</span> <span class="n">joinMe</span><span class="o">.</span><span class="na">status</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">currentJoin</span> <span class="o">=</span> <span class="n">prevJoin</span><span class="o">;</span>
                <span class="k">return</span> <span class="n">s</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">retries</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">queueTop</span> <span class="o">!=</span> <span class="n">queueBase</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(!</span><span class="n">localHelpJoinTask</span><span class="o">(</span><span class="n">joinMe</span><span class="o">))</span>
                        <span class="n">retries</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>           <span class="c1">// cannot help
</span><span class="c1"></span>                <span class="o">}</span>
                <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">retries</span> <span class="o">==</span> <span class="n">MAX_HELP</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">1</span><span class="o">)</span> <span class="o">{</span>
                    <span class="o">--</span><span class="n">retries</span><span class="o">;</span>                 <span class="c1">// check uncommon case
</span><span class="c1"></span>                    <span class="k">if</span> <span class="o">(</span><span class="n">tryDeqAndExec</span><span class="o">(</span><span class="n">joinMe</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="n">0</span><span class="o">)</span>
                        <span class="n">Thread</span><span class="o">.</span><span class="na">yield</span><span class="o">();</span>        <span class="c1">// for politeness
</span><span class="c1"></span>                <span class="o">}</span>
                <span class="k">else</span>
                    <span class="n">retries</span> <span class="o">=</span> <span class="n">helpJoinTask</span><span class="o">(</span><span class="n">joinMe</span><span class="o">)</span> <span class="o">?</span> <span class="n">MAX_HELP</span> <span class="o">:</span> <span class="n">retries</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="n">retries</span> <span class="o">=</span> <span class="n">MAX_HELP</span><span class="o">;</span>           <span class="c1">// restart if not done
</span><span class="c1"></span>                <span class="n">pool</span><span class="o">.</span><span class="na">tryAwaitJoin</span><span class="o">(</span><span class="n">joinMe</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
     
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<pre><code>/**
 * If present, pops and executes the given task, or any other
 * cancelled task
 * 如果存在，则弹出并执行给定的任务，或任何其他被取消的任务
 * @return false if any other non-cancelled task exists in local queue
 */
private boolean localHelpJoinTask(ForkJoinTask&lt;?&gt; joinMe) {
    int s, i; ForkJoinTask&lt;?&gt;[] q; ForkJoinTask&lt;?&gt; t;
    if ((s = queueTop) != queueBase &amp;&amp; (q = queue) != null &amp;&amp;
        (i = (q.length - 1) &amp; --s) &gt;= 0 &amp;&amp;
        (t = q[i]) != null) {
        if (t != joinMe &amp;&amp; t.status &gt;= 0)
            return false;
        if (UNSAFE.compareAndSwapObject
            (q, (i &lt;&lt; ASHIFT) + ABASE, t, null)) {
            queueTop = s;           // or putOrderedInt
            t.doExec();
        }
    }
    return true;
}

/**
 * Tries to locate and execute tasks for a stealer of the given
 * task, or in turn one of its stealers, Traces
 * currentSteal-&gt;currentJoin links looking for a thread working on
 * a descendant of the given task and with a non-empty queue to
 * steal back and execute tasks from.  The implementation is very
 * branchy to cope with potential inconsistencies or loops
 * encountering chains that are stale, unknown, or of length
 * greater than MAX_HELP links.  All of these cases are dealt with
 * by just retrying by caller.
 *
 * @param joinMe the task to join
 * @param canSteal true if local queue is empty
 * @return true if ran a task
 */
private boolean helpJoinTask(ForkJoinTask&lt;?&gt; joinMe) {
    boolean helped = false;
    int m = pool.scanGuard &amp; SMASK;
    ForkJoinWorkerThread[] ws = pool.workers;
    if (ws != null &amp;&amp; ws.length &gt; m &amp;&amp; joinMe.status &gt;= 0) {
        int levels = MAX_HELP;              // remaining chain length
        ForkJoinTask&lt;?&gt; task = joinMe;      // base of chain
        outer:for (ForkJoinWorkerThread thread = this;;) {
            // Try to find v, the stealer of task, by first using hint
            ForkJoinWorkerThread v = ws[thread.stealHint &amp; m];
            if (v == null || v.currentSteal != task) {
                for (int j = 0; ;) {        // search array
                    if ((v = ws[j]) != null &amp;&amp; v.currentSteal == task) {
                        thread.stealHint = j;
                        break;              // save hint for next time
                    }
                    if (++j &gt; m)
                        break outer;        // can't find stealer
                }
            }
            // Try to help v, using specialized form of deqTask
            for (;;) {
                ForkJoinTask&lt;?&gt;[] q; int b, i;
                if (joinMe.status &lt; 0)
                    break outer;
                if ((b = v.queueBase) == v.queueTop ||
                    (q = v.queue) == null ||
                    (i = (q.length-1) &amp; b) &lt; 0)
                    break;                  // empty
                long u = (i &lt;&lt; ASHIFT) + ABASE;
                ForkJoinTask&lt;?&gt; t = q[i];
                if (task.status &lt; 0)
                    break outer;            // stale
                if (t != null &amp;&amp; v.queueBase == b &amp;&amp;
                    UNSAFE.compareAndSwapObject(q, u, t, null)) {
                    v.queueBase = b + 1;
                    v.stealHint = poolIndex;
                    ForkJoinTask&lt;?&gt; ps = currentSteal;
                    currentSteal = t;
                    t.doExec();
                    currentSteal = ps;
                    helped = true;
                }
            }
            // Try to descend to find v's stealer
            ForkJoinTask&lt;?&gt; next = v.currentJoin;
            if (--levels &gt; 0 &amp;&amp; task.status &gt;= 0 &amp;&amp;
                next != null &amp;&amp; next != task) {
                task = next;
                thread = v;
            }
            else
                break;  // max levels, stale, dead-end, or cyclic
        }
    }
    return helped;
}

/**
 * Performs an uncommon case for joinTask: If task t is at base of
 * some workers queue, steals and executes it.
 *
 * @param t the task
 * @return t's status
 */
private int tryDeqAndExec(ForkJoinTask&lt;?&gt; t) {
    int m = pool.scanGuard &amp; SMASK;
    ForkJoinWorkerThread[] ws = pool.workers;
    if (ws != null &amp;&amp; ws.length &gt; m &amp;&amp; t.status &gt;= 0) {
        for (int j = 0; j &lt;= m; ++j) {
            ForkJoinTask&lt;?&gt;[] q; int b, i;
            ForkJoinWorkerThread v = ws[j];
            if (v != null &amp;&amp;
                (b = v.queueBase) != v.queueTop &amp;&amp;
                (q = v.queue) != null &amp;&amp;
                (i = (q.length - 1) &amp; b) &gt;= 0 &amp;&amp;
                q[i] ==  t) {
                long u = (i &lt;&lt; ASHIFT) + ABASE;
                if (v.queueBase == b &amp;&amp;
                    UNSAFE.compareAndSwapObject(q, u, t, null)) {
                    v.queueBase = b + 1;
                    v.stealHint = poolIndex;
                    ForkJoinTask&lt;?&gt; ps = currentSteal;
                    currentSteal = t;
                    t.doExec();
                    currentSteal = ps;
                }
                break;
            }
        }
    }
    return t.status;
}    
  ```
</code></pre>
<ul>
<li>[3].helpQuiescePool
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">    <span class="cm">/**
</span><span class="cm">     * Runs tasks until {@code pool.isQuiescent()}. We piggyback on
</span><span class="cm">     * pool&#39;s active count ctl maintenance, but rather than blocking
</span><span class="cm">     * when tasks cannot be found, we rescan until all others cannot
</span><span class="cm">     * find tasks either. The bracketing by pool quiescerCounts
</span><span class="cm">     * updates suppresses pool auto-shutdown mechanics that could
</span><span class="cm">     * otherwise prematurely terminate the pool because all threads
</span><span class="cm">     * appear to be inactive.
</span><span class="cm">     */</span>
    <span class="kd">final</span> <span class="kt">void</span> <span class="nf">helpQuiescePool</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">boolean</span> <span class="n">active</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;</span> <span class="n">ps</span> <span class="o">=</span> <span class="n">currentSteal</span><span class="o">;</span> <span class="c1">// to restore below
</span><span class="c1"></span>        <span class="n">ForkJoinPool</span> <span class="n">p</span> <span class="o">=</span> <span class="n">pool</span><span class="o">;</span>
        <span class="n">p</span><span class="o">.</span><span class="na">addQuiescerCount</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
            <span class="n">ForkJoinWorkerThread</span><span class="o">[]</span> <span class="n">ws</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">workers</span><span class="o">;</span>
            <span class="n">ForkJoinWorkerThread</span> <span class="n">v</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">queueTop</span> <span class="o">!=</span> <span class="n">queueBase</span><span class="o">)</span>
                <span class="n">v</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
            <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">ws</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">ws</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">ForkJoinWorkerThread</span> <span class="n">w</span><span class="o">;</span>
                <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">nextSeed</span><span class="o">();</span> <span class="c1">// cheap version of FJP.scan
</span><span class="c1"></span>                <span class="kt">int</span> <span class="n">steps</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="n">1</span><span class="o">;</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">steps</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">((</span><span class="n">w</span> <span class="o">=</span> <span class="n">ws</span><span class="o">[(</span><span class="n">i</span> <span class="o">+</span> <span class="n">r</span><span class="o">)</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">1</span><span class="o">)])</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span>
                        <span class="n">w</span><span class="o">.</span><span class="na">queueBase</span> <span class="o">!=</span> <span class="n">w</span><span class="o">.</span><span class="na">queueTop</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">v</span> <span class="o">=</span> <span class="n">w</span><span class="o">;</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">v</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;</span> <span class="n">t</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">active</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">active</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="n">p</span><span class="o">.</span><span class="na">addActiveCount</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">t</span> <span class="o">=</span> <span class="o">(</span><span class="n">v</span> <span class="o">!=</span> <span class="k">this</span><span class="o">)</span> <span class="o">?</span> <span class="n">v</span><span class="o">.</span><span class="na">deqTask</span><span class="o">()</span> <span class="o">:</span>
                     <span class="n">locallyFifo</span> <span class="o">?</span> <span class="n">locallyDeqTask</span><span class="o">()</span> <span class="o">:</span> <span class="n">popTask</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">currentSteal</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
                    <span class="n">t</span><span class="o">.</span><span class="na">doExec</span><span class="o">();</span>
                    <span class="n">currentSteal</span> <span class="o">=</span> <span class="n">ps</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">active</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">active</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="n">p</span><span class="o">.</span><span class="na">addActiveCount</span><span class="o">(-</span><span class="n">1</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">isQuiescent</span><span class="o">())</span> <span class="o">{</span>
                    <span class="n">p</span><span class="o">.</span><span class="na">addActiveCount</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
                    <span class="n">p</span><span class="o">.</span><span class="na">addQuiescerCount</span><span class="o">(-</span><span class="n">1</span><span class="o">);</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="4forkjoinpool-构造">4.ForkJoinPool 构造</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span><span class="lnt">233
</span><span class="lnt">234
</span><span class="lnt">235
</span><span class="lnt">236
</span><span class="lnt">237
</span><span class="lnt">238
</span><span class="lnt">239
</span><span class="lnt">240
</span><span class="lnt">241
</span><span class="lnt">242
</span><span class="lnt">243
</span><span class="lnt">244
</span><span class="lnt">245
</span><span class="lnt">246
</span><span class="lnt">247
</span><span class="lnt">248
</span><span class="lnt">249
</span><span class="lnt">250
</span><span class="lnt">251
</span><span class="lnt">252
</span><span class="lnt">253
</span><span class="lnt">254
</span><span class="lnt">255
</span><span class="lnt">256
</span><span class="lnt">257
</span><span class="lnt">258
</span><span class="lnt">259
</span><span class="lnt">260
</span><span class="lnt">261
</span><span class="lnt">262
</span><span class="lnt">263
</span><span class="lnt">264
</span><span class="lnt">265
</span><span class="lnt">266
</span><span class="lnt">267
</span><span class="lnt">268
</span><span class="lnt">269
</span><span class="lnt">270
</span><span class="lnt">271
</span><span class="lnt">272
</span><span class="lnt">273
</span><span class="lnt">274
</span><span class="lnt">275
</span><span class="lnt">276
</span><span class="lnt">277
</span><span class="lnt">278
</span><span class="lnt">279
</span><span class="lnt">280
</span><span class="lnt">281
</span><span class="lnt">282
</span><span class="lnt">283
</span><span class="lnt">284
</span><span class="lnt">285
</span><span class="lnt">286
</span><span class="lnt">287
</span><span class="lnt">288
</span><span class="lnt">289
</span><span class="lnt">290
</span><span class="lnt">291
</span><span class="lnt">292
</span><span class="lnt">293
</span><span class="lnt">294
</span><span class="lnt">295
</span><span class="lnt">296
</span><span class="lnt">297
</span><span class="lnt">298
</span><span class="lnt">299
</span><span class="lnt">300
</span><span class="lnt">301
</span><span class="lnt">302
</span><span class="lnt">303
</span><span class="lnt">304
</span><span class="lnt">305
</span><span class="lnt">306
</span><span class="lnt">307
</span><span class="lnt">308
</span><span class="lnt">309
</span><span class="lnt">310
</span><span class="lnt">311
</span><span class="lnt">312
</span><span class="lnt">313
</span><span class="lnt">314
</span><span class="lnt">315
</span><span class="lnt">316
</span><span class="lnt">317
</span><span class="lnt">318
</span><span class="lnt">319
</span><span class="lnt">320
</span><span class="lnt">321
</span><span class="lnt">322
</span><span class="lnt">323
</span><span class="lnt">324
</span><span class="lnt">325
</span><span class="lnt">326
</span><span class="lnt">327
</span><span class="lnt">328
</span><span class="lnt">329
</span><span class="lnt">330
</span><span class="lnt">331
</span><span class="lnt">332
</span><span class="lnt">333
</span><span class="lnt">334
</span><span class="lnt">335
</span><span class="lnt">336
</span><span class="lnt">337
</span><span class="lnt">338
</span><span class="lnt">339
</span><span class="lnt">340
</span><span class="lnt">341
</span><span class="lnt">342
</span><span class="lnt">343
</span><span class="lnt">344
</span><span class="lnt">345
</span><span class="lnt">346
</span><span class="lnt">347
</span><span class="lnt">348
</span><span class="lnt">349
</span><span class="lnt">350
</span><span class="lnt">351
</span><span class="lnt">352
</span><span class="lnt">353
</span><span class="lnt">354
</span><span class="lnt">355
</span><span class="lnt">356
</span><span class="lnt">357
</span><span class="lnt">358
</span><span class="lnt">359
</span><span class="lnt">360
</span><span class="lnt">361
</span><span class="lnt">362
</span><span class="lnt">363
</span><span class="lnt">364
</span><span class="lnt">365
</span><span class="lnt">366
</span><span class="lnt">367
</span><span class="lnt">368
</span><span class="lnt">369
</span><span class="lnt">370
</span><span class="lnt">371
</span><span class="lnt">372
</span><span class="lnt">373
</span><span class="lnt">374
</span><span class="lnt">375
</span><span class="lnt">376
</span><span class="lnt">377
</span><span class="lnt">378
</span><span class="lnt">379
</span><span class="lnt">380
</span><span class="lnt">381
</span><span class="lnt">382
</span><span class="lnt">383
</span><span class="lnt">384
</span><span class="lnt">385
</span><span class="lnt">386
</span><span class="lnt">387
</span><span class="lnt">388
</span><span class="lnt">389
</span><span class="lnt">390
</span><span class="lnt">391
</span><span class="lnt">392
</span><span class="lnt">393
</span><span class="lnt">394
</span><span class="lnt">395
</span><span class="lnt">396
</span><span class="lnt">397
</span><span class="lnt">398
</span><span class="lnt">399
</span><span class="lnt">400
</span><span class="lnt">401
</span><span class="lnt">402
</span><span class="lnt">403
</span><span class="lnt">404
</span><span class="lnt">405
</span><span class="lnt">406
</span><span class="lnt">407
</span><span class="lnt">408
</span><span class="lnt">409
</span><span class="lnt">410
</span><span class="lnt">411
</span><span class="lnt">412
</span><span class="lnt">413
</span><span class="lnt">414
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">    <span class="cm">/**
</span><span class="cm">     * Permission required for callers of methods that may start or
</span><span class="cm">     * kill threads.
</span><span class="cm">     * 可能启动或杀死线程的方法的调用者所需的权限。
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">RuntimePermission</span> <span class="n">modifyThreadPermission</span><span class="o">;</span>

    <span class="cm">/**
</span><span class="cm">     * If there is a security manager, makes sure caller has
</span><span class="cm">     * permission to modify threads.
</span><span class="cm">     * 如果有一个安全管理器，确保调用者有权修改线程。
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">checkPermission</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">SecurityManager</span> <span class="n">security</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">getSecurityManager</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">security</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">security</span><span class="o">.</span><span class="na">checkPermission</span><span class="o">(</span><span class="n">modifyThreadPermission</span><span class="o">);</span>
    <span class="o">}</span>
 <span class="cm">/**
</span><span class="cm">  * Generator for assigning sequence numbers as pool names.
</span><span class="cm">  * 用于将序列号分配为池名称的生成器。
</span><span class="cm">  */</span>
 <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">AtomicInteger</span> <span class="n">poolNumberGenerator</span><span class="o">;</span>

 <span class="cm">/**
</span><span class="cm">  * Generator for initial random seeds for worker victim
</span><span class="cm">  * selection. This is used only to create initial seeds. Random
</span><span class="cm">  * steals use a cheaper xorshift generator per steal attempt. We
</span><span class="cm">  * don&#39;t expect much contention on seedGenerator, so just use a
</span><span class="cm">  * plain Random.
</span><span class="cm">  * 用于工人受害者选择的初始随机种子生成器。这仅用于创建初始种子。随机窃取使用一个更便宜的xorshift发电机每偷窃企图。
</span><span class="cm">  * 我们不期望在seedGenerator上有太多的争用，所以只需使用一个普通的Random。
</span><span class="cm">  */</span>
 <span class="kd">static</span> <span class="kd">final</span> <span class="n">Random</span> <span class="n">workerSeedGenerator</span><span class="o">;</span>

 <span class="cm">/**
</span><span class="cm">  * Array holding all worker threads in the pool.  Initialized upon
</span><span class="cm">  * construction. Array size must be a power of two.  Updates and
</span><span class="cm">  * replacements are protected by scanGuard, but the array is
</span><span class="cm">  * always kept in a consistent enough state to be randomly
</span><span class="cm">  * accessed without locking by workers performing work-stealing,
</span><span class="cm">  * as well as other traversal-based methods in this class, so long
</span><span class="cm">  * as reads memory-acquire by first reading ctl. All readers must
</span><span class="cm">  * tolerate that some array slots may be null.
</span><span class="cm">  * 数组保存池中的所有工作线程。建设初始化。数组大小必须是2的幂。更新和替换是由scanGuard保护的，
</span><span class="cm">  * 但是数组始终保持一致的状态以便随机访问而不被工作人员执行工作盗取的锁定以及此类中的其他基于遍历的方法，
</span><span class="cm">  * 只要读取内存 - 通过一读ctl获取。所有读者必须容忍一些数组插槽可能为空。
</span><span class="cm">  */</span>
 <span class="n">ForkJoinWorkerThread</span><span class="o">[]</span> <span class="n">workers</span><span class="o">;</span>

 <span class="cm">/**
</span><span class="cm">  * Initial size for submission queue array. Must be a power of
</span><span class="cm">  * two.  In many applications, these always stay small so we use a
</span><span class="cm">  * small initial cap.
</span><span class="cm">  * 提交队列数组的初始大小。必须是必须是2的幂。在许多应用程序中，这些总是保持较小，所以我们使用一个小的初始上限
</span><span class="cm">  */</span>
 <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">INITIAL_QUEUE_CAPACITY</span> <span class="o">=</span> <span class="n">8</span><span class="o">;</span>

 <span class="cm">/**
</span><span class="cm">  * Maximum size for submission queue array. Must be a power of two
</span><span class="cm">  * less than or equal to 1 &lt;&lt; (31 - width of array entry) to
</span><span class="cm">  * ensure lack of index wraparound, but is capped at a lower
</span><span class="cm">  * value to help users trap runaway computations.
</span><span class="cm">  * 队列数组的最大大小。必须是小于或等于1 &lt; &lt;(31 -宽度的数组条目)的幂，以确保缺少索引wraparound，但要以较低的值限制，以帮助用户捕获失控的计算。
</span><span class="cm">  */</span>
 <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MAXIMUM_QUEUE_CAPACITY</span> <span class="o">=</span> <span class="n">1</span> <span class="o">&lt;&lt;</span> <span class="n">24</span><span class="o">;</span> <span class="c1">// 16M
</span><span class="c1"></span>
 <span class="cm">/**
</span><span class="cm">  * Array serving as submission queue. Initialized upon construction.
</span><span class="cm">  * 作为提交队列的阵列。建设初始化。
</span><span class="cm">  */</span>
 <span class="kd">private</span> <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;[]</span> <span class="n">submissionQueue</span><span class="o">;</span>

 <span class="cm">/**
</span><span class="cm">  * Lock protecting submissions array for addSubmission
</span><span class="cm">  * 锁定保护提交数组addSubmission
</span><span class="cm">  */</span>
 <span class="kd">private</span> <span class="kd">final</span> <span class="n">ReentrantLock</span> <span class="n">submissionLock</span><span class="o">;</span>

 <span class="cm">/**
</span><span class="cm">  * Condition for awaitTermination, using submissionLock for
</span><span class="cm">  * convenience.
</span><span class="cm">  * 等待终止的条件，使用提交锁定为了方便。
</span><span class="cm">  */</span>
 <span class="kd">private</span> <span class="kd">final</span> <span class="n">Condition</span> <span class="n">termination</span><span class="o">;</span>

 <span class="cm">/**
</span><span class="cm">  * Creation factory for worker threads.
</span><span class="cm">  * 工作线程的创建工厂。
</span><span class="cm">  */</span>
 <span class="kd">private</span> <span class="kd">final</span> <span class="n">ForkJoinWorkerThreadFactory</span> <span class="n">factory</span><span class="o">;</span>

 <span class="cm">/**
</span><span class="cm">  * The uncaught exception handler used when any worker abruptly
</span><span class="cm">  * terminates.
</span><span class="cm">  * 任何员工突然终止时使用的未捕获异常处理程序。
</span><span class="cm">  */</span>
 <span class="kd">final</span> <span class="n">Thread</span><span class="o">.</span><span class="na">UncaughtExceptionHandler</span> <span class="n">ueh</span><span class="o">;</span>

 <span class="cm">/**
</span><span class="cm">  * Prefix for assigning names to worker threads
</span><span class="cm">  * 前缀为工作线程分配名称
</span><span class="cm">  */</span>
 <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">workerNamePrefix</span><span class="o">;</span>

 <span class="cm">/**
</span><span class="cm">  * Sum of per-thread steal counts, updated only when threads are
</span><span class="cm">  * idle or terminating.
</span><span class="cm">  * 每线程窃取计数总和，仅在线程空闲或终止时更新。
</span><span class="cm">  */</span>
 <span class="kd">private</span> <span class="kd">volatile</span> <span class="kt">long</span> <span class="n">stealCount</span><span class="o">;</span>

 <span class="cm">/**
</span><span class="cm">  * Main pool control -- a long packed with:
</span><span class="cm">  * 主池控制 - long包装宽度：
</span><span class="cm">  * AC: Number of active running workers minus target parallelism (16 bits) 正在运行的工作人员数减去目标平行度（16位）
</span><span class="cm">  * TC: Number of total workers minus target parallelism (16bits) 总工人数减目标平行（16位）
</span><span class="cm">  * ST: true if pool is terminating (1 bit)  如果池正在终止，则为true（1位）
</span><span class="cm">  * EC: the wait count of top waiting thread (15 bits) 顶部等待线程的等待计数（15位）
</span><span class="cm">  * ID: ~poolIndex of top of Treiber stack of waiting threads (16 bits) 〜等待线程堆栈顶部的poolIndex（16位）
</span><span class="cm">  *
</span><span class="cm">  * When convenient, we can extract the upper 32 bits of counts and
</span><span class="cm">  * the lower 32 bits of queue state, u = (int)(ctl &gt;&gt;&gt; 32) and e =
</span><span class="cm">  * (int)ctl.  The ec field is never accessed alone, but always
</span><span class="cm">  * together with id and st. The offsets of counts by the target
</span><span class="cm">  * parallelism and the positionings of fields makes it possible to
</span><span class="cm">  * perform the most common checks via sign tests of fields: When
</span><span class="cm">  * ac is negative, there are not enough active workers, when tc is
</span><span class="cm">  * negative, there are not enough total workers, when id is
</span><span class="cm">  * negative, there is at least one waiting worker, and when e is
</span><span class="cm">  * negative, the pool is terminating.  To deal with these possibly
</span><span class="cm">  * negative fields, we use casts in and out of &#34;short&#34; and/or
</span><span class="cm">  * signed shifts to maintain signedness.
</span><span class="cm">  * 方便的时候，我们可以提取队列状态的高32位和低32位，u =（int）（ctl &gt;&gt;&gt; 32）和e =（int）ctl。 
</span><span class="cm">  * ec字段永远不会被单独访问，但总是与id和st一起访问。通过目标平行度和字段的定位来抵消计数，使得可以通过字段的符号测试来执行最常见的检查：
</span><span class="cm">  * 当ac为负时，没有足够的活动工人，
</span><span class="cm">  * 当tc为负时，没有足够的总数工人，
</span><span class="cm">  * 当id为负值时，至少有一个等待工人，
</span><span class="cm">  * 当e为负值时，池正在终止。
</span><span class="cm">  * 为了处理这些可能出现的负面情况，我们使用&#34;short&#34;和/或有符号转换来保持签名。
</span><span class="cm">  */</span>
 <span class="kd">volatile</span> <span class="kt">long</span> <span class="n">ctl</span><span class="o">;</span>

 <span class="c1">// bit positions/shifts for fields
</span><span class="c1"></span> <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span>  <span class="n">AC_SHIFT</span>   <span class="o">=</span> <span class="n">48</span><span class="o">;</span>
 <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span>  <span class="n">TC_SHIFT</span>   <span class="o">=</span> <span class="n">32</span><span class="o">;</span>
 <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span>  <span class="n">ST_SHIFT</span>   <span class="o">=</span> <span class="n">31</span><span class="o">;</span>
 <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span>  <span class="n">EC_SHIFT</span>   <span class="o">=</span> <span class="n">16</span><span class="o">;</span>

 <span class="c1">// bounds
</span><span class="c1"></span> <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span>  <span class="n">MAX_ID</span>     <span class="o">=</span> <span class="n">0x7fff</span><span class="o">;</span>  <span class="c1">// max poolIndex    0111 1111 1111 1111
</span><span class="c1"></span> <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span>  <span class="n">SMASK</span>      <span class="o">=</span> <span class="n">0xffff</span><span class="o">;</span>  <span class="c1">// mask short bits  1111 1111 1111 1111
</span><span class="c1"></span> <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span>  <span class="n">SHORT_SIGN</span> <span class="o">=</span> <span class="n">1</span> <span class="o">&lt;&lt;</span> <span class="n">15</span><span class="o">;</span> <span class="c1">//  1000 0000 0000 0000
</span><span class="c1"></span> <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span>  <span class="n">INT_SIGN</span>   <span class="o">=</span> <span class="n">1</span> <span class="o">&lt;&lt;</span> <span class="n">31</span><span class="o">;</span> <span class="c1">//  1000 0000 0000 0000 0000 0000 0000 0000
</span><span class="c1"></span>
 <span class="c1">// masks
</span><span class="c1"></span> <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">STOP_BIT</span>   <span class="o">=</span> <span class="n">0x0001L</span> <span class="o">&lt;&lt;</span> <span class="n">ST_SHIFT</span><span class="o">;</span><span class="c1">//         1000 0000 0000 0000 0000 0000 0000 0000
</span><span class="c1"></span> <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">AC_MASK</span>    <span class="o">=</span> <span class="o">((</span><span class="kt">long</span><span class="o">)</span><span class="n">SMASK</span><span class="o">)</span> <span class="o">&lt;&lt;</span> <span class="n">AC_SHIFT</span><span class="o">;</span>
 <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">TC_MASK</span>    <span class="o">=</span> <span class="o">((</span><span class="kt">long</span><span class="o">)</span><span class="n">SMASK</span><span class="o">)</span> <span class="o">&lt;&lt;</span> <span class="n">TC_SHIFT</span><span class="o">;</span>

 <span class="c1">// units for incrementing and decrementing 单位递增和递减
</span><span class="c1"></span> <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">TC_UNIT</span>    <span class="o">=</span> <span class="n">1L</span> <span class="o">&lt;&lt;</span> <span class="n">TC_SHIFT</span><span class="o">;</span>
 <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">AC_UNIT</span>    <span class="o">=</span> <span class="n">1L</span> <span class="o">&lt;&lt;</span> <span class="n">AC_SHIFT</span><span class="o">;</span>

 <span class="c1">// masks and units for dealing with u = (int)(ctl &gt;&gt;&gt; 32)
</span><span class="c1"></span> <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span>  <span class="n">UAC_SHIFT</span>  <span class="o">=</span> <span class="n">AC_SHIFT</span> <span class="o">-</span> <span class="n">32</span><span class="o">;</span> <span class="c1">//16
</span><span class="c1"></span> <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span>  <span class="n">UTC_SHIFT</span>  <span class="o">=</span> <span class="n">TC_SHIFT</span> <span class="o">-</span> <span class="n">32</span><span class="o">;</span> <span class="c1">//0 
</span><span class="c1"></span> <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span>  <span class="n">UAC_MASK</span>   <span class="o">=</span> <span class="n">SMASK</span> <span class="o">&lt;&lt;</span> <span class="n">UAC_SHIFT</span><span class="o">;</span> 
 <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span>  <span class="n">UTC_MASK</span>   <span class="o">=</span> <span class="n">SMASK</span> <span class="o">&lt;&lt;</span> <span class="n">UTC_SHIFT</span><span class="o">;</span>
 <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span>  <span class="n">UAC_UNIT</span>   <span class="o">=</span> <span class="n">1</span> <span class="o">&lt;&lt;</span> <span class="n">UAC_SHIFT</span><span class="o">;</span>
 <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span>  <span class="n">UTC_UNIT</span>   <span class="o">=</span> <span class="n">1</span> <span class="o">&lt;&lt;</span> <span class="n">UTC_SHIFT</span><span class="o">;</span>

 <span class="c1">// masks and units for dealing with e = (int)ctl
</span><span class="c1"></span> <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span>  <span class="n">E_MASK</span>     <span class="o">=</span> <span class="n">0x7fffffff</span><span class="o">;</span> <span class="c1">// no STOP_BIT  0111 1111 1111 1111 1111 1111 1111 1111
</span><span class="c1"></span> <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span>  <span class="n">EC_UNIT</span>    <span class="o">=</span> <span class="n">1</span> <span class="o">&lt;&lt;</span> <span class="n">EC_SHIFT</span><span class="o">;</span>

 <span class="cm">/**
</span><span class="cm">  * The target parallelism level.
</span><span class="cm">  * 目标平行水平。
</span><span class="cm">  */</span>
 <span class="kd">final</span> <span class="kt">int</span> <span class="n">parallelism</span><span class="o">;</span>

 <span class="cm">/**
</span><span class="cm">  * Index (mod submission queue length) of next element to take
</span><span class="cm">  * from submission queue. Usage is identical to that for
</span><span class="cm">  * per-worker queues -- see ForkJoinWorkerThread internal
</span><span class="cm">  * documentation.
</span><span class="cm">  * 从提交队列中取下一个元素的索引（mod submission queue length）。用法与每个工作者队列的用法相同 - 请参阅ForkJoinWorkerThread内部文档。
</span><span class="cm">  */</span>
 <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">queueBase</span><span class="o">;</span>

 <span class="cm">/**
</span><span class="cm">  * Index (mod submission queue length) of next element to add
</span><span class="cm">  * in submission queue. Usage is identical to that for
</span><span class="cm">  * per-worker queues -- see ForkJoinWorkerThread internal
</span><span class="cm">  * documentation.
</span><span class="cm">  * 在提交队列中添加的下一个元素的索引（mod submission queue length）。用法与每个工作者队列的用法相同 - 请参阅ForkJoinWorkerThread内部*文档。
</span><span class="cm">  */</span>
 <span class="kt">int</span> <span class="n">queueTop</span><span class="o">;</span>

 <span class="cm">/**
</span><span class="cm">  * True when shutdown() has been called.
</span><span class="cm">  * 当shutdown（）被调用时为真。
</span><span class="cm">  */</span>
 <span class="kd">volatile</span> <span class="kt">boolean</span> <span class="n">shutdown</span><span class="o">;</span>

 <span class="cm">/**
</span><span class="cm">  * True if use local fifo, not default lifo, for local polling
</span><span class="cm">  * Read by, and replicated by ForkJoinWorkerThreads
</span><span class="cm">  * 如果使用local fifo，而不是默认的lifo，则为真本地轮询读取，并由ForkJoinWorkerThreads复制
</span><span class="cm">  */</span>
 <span class="kd">final</span> <span class="kt">boolean</span> <span class="n">locallyFifo</span><span class="o">;</span>

 <span class="cm">/**
</span><span class="cm">  * The number of threads in ForkJoinWorkerThreads.helpQuiescePool.
</span><span class="cm">  * When non-zero, suppresses automatic shutdown when active
</span><span class="cm">  * counts become zero.
</span><span class="cm">  * ForkJoinWorkerThreads.helpQuiescePool中的线程数。 当非零时，当活动计数变为零时禁止自动关闭。
</span><span class="cm">  */</span>
 <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">quiescerCount</span><span class="o">;</span>

 <span class="cm">/**
</span><span class="cm">  * The number of threads blocked in join.
</span><span class="cm">  * join中阻塞的线程数量。
</span><span class="cm">  */</span>
 <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">blockedCount</span><span class="o">;</span>

 <span class="cm">/**
</span><span class="cm">  * Counter for worker Thread names (unrelated to their poolIndex)
</span><span class="cm">  * 计数器的工作线程名称（与他们的poolIndex无关）
</span><span class="cm">  */</span>
 <span class="kd">private</span> <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">nextWorkerNumber</span><span class="o">;</span>

 <span class="cm">/**
</span><span class="cm">  * The index for the next created worker. Accessed under scanGuard.
</span><span class="cm">  * 下一个创建的工人的索引。在scanGuard下访问。
</span><span class="cm">  */</span>
 <span class="kd">private</span> <span class="kt">int</span> <span class="n">nextWorkerIndex</span><span class="o">;</span>

 <span class="cm">/**
</span><span class="cm">  * SeqLock and index masking for updates to workers array.  Locked
</span><span class="cm">  * when SG_UNIT is set. Unlocking clears bit by adding
</span><span class="cm">  * SG_UNIT. Staleness of read-only operations can be checked by
</span><span class="cm">  * comparing scanGuard to value before the reads. The low 16 bits
</span><span class="cm">  * (i.e, anding with SMASK) hold (the smallest power of two
</span><span class="cm">  * covering all worker indices, minus one, and is used to avoid
</span><span class="cm">  * dealing with large numbers of null slots when the workers array
</span><span class="cm">  * is overallocated.
</span><span class="cm">  * SeqLock和索引屏蔽更新工人数组。
</span><span class="cm">  * 当SG_UNIT被设置时锁定。解锁通过添加SG_UNIT来清除位。
</span><span class="cm">  * 通过比较scanGuard和read之前的值，可以检查只读操作的过时性。
</span><span class="cm">  * 低16位（即和SMASK）保持不变（两个覆盖所有工人指数的最小幂，减1），用于避免在工人数组过度时处理大量的空位。
</span><span class="cm">  */</span>
 <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">scanGuard</span><span class="o">;</span>

 <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">SG_UNIT</span> <span class="o">=</span> <span class="n">1</span> <span class="o">&lt;&lt;</span> <span class="n">16</span><span class="o">;</span>

 <span class="cm">/**
</span><span class="cm">  * The wakeup interval (in nanoseconds) for a worker waiting for a
</span><span class="cm">  * task when the pool is quiescent to instead try to shrink the
</span><span class="cm">  * number of workers.  The exact value does not matter too
</span><span class="cm">  * much. It must be short enough to release resources during
</span><span class="cm">  * sustained periods of idleness, but not so short that threads
</span><span class="cm">  * are continually re-created.
</span><span class="cm">  * 当池静止时，等待任务的工作人员的唤醒间隔（以纳秒为单位）代替尝试缩小工作人员数量。
</span><span class="cm">  * 确切的价值并不重要。它必须足够短以便在闲置时间内释放资源，但不能太短以致线程不断重新创建。
</span><span class="cm">  */</span>
 <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">SHRINK_RATE</span> <span class="o">=</span>
     <span class="n">4L</span> <span class="o">*</span> <span class="n">1000L</span> <span class="o">*</span> <span class="n">1000L</span> <span class="o">*</span> <span class="n">1000L</span><span class="o">;</span> <span class="c1">// 4 seconds
</span><span class="c1"></span> <span class="c1">// Constructors
</span><span class="c1"></span>
    <span class="cm">/**
</span><span class="cm">     * Creates a {@code ForkJoinPool} with parallelism equal to {@link
</span><span class="cm">     * java.lang.Runtime#availableProcessors}, using the {@linkplain
</span><span class="cm">     * #defaultForkJoinWorkerThreadFactory default thread factory},
</span><span class="cm">     * no UncaughtExceptionHandler, and non-async LIFO processing mode.
</span><span class="cm">     *
</span><span class="cm">     * @throws SecurityException if a security manager exists and
</span><span class="cm">     *         the caller is not permitted to modify threads
</span><span class="cm">     *         because it does not hold {@link
</span><span class="cm">     *         java.lang.RuntimePermission}{@code (&#34;modifyThread&#34;)}
</span><span class="cm">     */</span>
    <span class="kd">public</span> <span class="nf">ForkJoinPool</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">(</span><span class="n">Runtime</span><span class="o">.</span><span class="na">getRuntime</span><span class="o">().</span><span class="na">availableProcessors</span><span class="o">(),</span>
             <span class="n">defaultForkJoinWorkerThreadFactory</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
</span><span class="cm">     * Creates a {@code ForkJoinPool} with the indicated parallelism
</span><span class="cm">     * level, the {@linkplain
</span><span class="cm">     * #defaultForkJoinWorkerThreadFactory default thread factory},
</span><span class="cm">     * no UncaughtExceptionHandler, and non-async LIFO processing mode.
</span><span class="cm">     *
</span><span class="cm">     * @param parallelism the parallelism level
</span><span class="cm">     * @throws IllegalArgumentException if parallelism less than or
</span><span class="cm">     *         equal to zero, or greater than implementation limit
</span><span class="cm">     * @throws SecurityException if a security manager exists and
</span><span class="cm">     *         the caller is not permitted to modify threads
</span><span class="cm">     *         because it does not hold {@link
</span><span class="cm">     *         java.lang.RuntimePermission}{@code (&#34;modifyThread&#34;)}
</span><span class="cm">     */</span>
    <span class="kd">public</span> <span class="nf">ForkJoinPool</span><span class="o">(</span><span class="kt">int</span> <span class="n">parallelism</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">(</span><span class="n">parallelism</span><span class="o">,</span> <span class="n">defaultForkJoinWorkerThreadFactory</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
</span><span class="cm">     * Creates a {@code ForkJoinPool} with the given parameters.
</span><span class="cm">     *
</span><span class="cm">     * @param parallelism the parallelism level. For default value,
</span><span class="cm">     * use {@link java.lang.Runtime#availableProcessors}.
</span><span class="cm">     * @param factory the factory for creating new threads. For default value,
</span><span class="cm">     * use {@link #defaultForkJoinWorkerThreadFactory}.
</span><span class="cm">     * @param handler the handler for internal worker threads that
</span><span class="cm">     * terminate due to unrecoverable errors encountered while executing
</span><span class="cm">     * tasks. For default value, use {@code null}.
</span><span class="cm">     * @param asyncMode if true,
</span><span class="cm">     * establishes local first-in-first-out scheduling mode for forked
</span><span class="cm">     * tasks that are never joined. This mode may be more appropriate
</span><span class="cm">     * than default locally stack-based mode in applications in which
</span><span class="cm">     * worker threads only process event-style asynchronous tasks.
</span><span class="cm">     * For default value, use {@code false}.
</span><span class="cm">     * @throws IllegalArgumentException if parallelism less than or
</span><span class="cm">     *         equal to zero, or greater than implementation limit
</span><span class="cm">     * @throws NullPointerException if the factory is null
</span><span class="cm">     * @throws SecurityException if a security manager exists and
</span><span class="cm">     *         the caller is not permitted to modify threads
</span><span class="cm">     *         because it does not hold {@link
</span><span class="cm">     *         java.lang.RuntimePermission}{@code (&#34;modifyThread&#34;)}
</span><span class="cm">     */</span>
    <span class="kd">public</span> <span class="nf">ForkJoinPool</span><span class="o">(</span><span class="kt">int</span> <span class="n">parallelism</span><span class="o">,</span>
                        <span class="n">ForkJoinWorkerThreadFactory</span> <span class="n">factory</span><span class="o">,</span>
                        <span class="n">Thread</span><span class="o">.</span><span class="na">UncaughtExceptionHandler</span> <span class="n">handler</span><span class="o">,</span>
                        <span class="kt">boolean</span> <span class="n">asyncMode</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">checkPermission</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">factory</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">NullPointerException</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">parallelism</span> <span class="o">&lt;=</span> <span class="n">0</span> <span class="o">||</span> <span class="n">parallelism</span> <span class="o">&gt;</span> <span class="n">MAX_ID</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">();</span>
        <span class="k">this</span><span class="o">.</span><span class="na">parallelism</span> <span class="o">=</span> <span class="n">parallelism</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">factory</span> <span class="o">=</span> <span class="n">factory</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">ueh</span> <span class="o">=</span> <span class="n">handler</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">locallyFifo</span> <span class="o">=</span> <span class="n">asyncMode</span><span class="o">;</span><span class="c1">//设置是否为异步模式。
</span><span class="c1"></span>       <span class="cm">/* 
</span><span class="cm">     * 参考我们之前介绍的ctl的内容，由于ctl中的AC或者TC都要减去parallelism
</span><span class="cm">     */</span>          
        <span class="kt">long</span> <span class="n">np</span> <span class="o">=</span> <span class="o">(</span><span class="kt">long</span><span class="o">)(-</span><span class="n">parallelism</span><span class="o">);</span> <span class="c1">// offset ctl counts
</span><span class="c1"></span>        <span class="k">this</span><span class="o">.</span><span class="na">ctl</span> <span class="o">=</span> <span class="o">((</span><span class="n">np</span> <span class="o">&lt;&lt;</span> <span class="n">AC_SHIFT</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">AC_MASK</span><span class="o">)</span> <span class="o">|</span> <span class="o">((</span><span class="n">np</span> <span class="o">&lt;&lt;</span> <span class="n">TC_SHIFT</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">TC_MASK</span><span class="o">);</span>
        <span class="c1">//初始化提交任务队列。
</span><span class="c1"></span>        <span class="k">this</span><span class="o">.</span><span class="na">submissionQueue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;[</span><span class="n">INITIAL_QUEUE_CAPACITY</span><span class="o">];</span>
        <span class="c1">// initialize workers array with room for 2*parallelism if possible
</span><span class="c1"></span>         <span class="cm">/* 
</span><span class="cm">     * 这里需要根据并行度来算出工作线程数组的大小。 
</span><span class="cm">     * 由于数组大小必须的2的幂，这里的算法是算出比 
</span><span class="cm">     * parallelism的2倍大的最小的2的幂，但不能超过 
</span><span class="cm">     * MAX_ID + 1(1 &lt;&lt; 16)的数作为工作线程数组大小 
</span><span class="cm">     */</span>  
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">parallelism</span> <span class="o">&lt;&lt;</span> <span class="n">1</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="n">MAX_ID</span><span class="o">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">MAX_ID</span><span class="o">;</span>
        <span class="k">else</span> <span class="o">{</span> <span class="c1">// See Hackers Delight, sec 3.2, where n &lt; (1 &lt;&lt; 16)
</span><span class="c1"></span>            <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">1</span><span class="o">;</span> <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">2</span><span class="o">;</span> <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">4</span><span class="o">;</span> <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">8</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">workers</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ForkJoinWorkerThread</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="n">1</span><span class="o">];</span>
        <span class="k">this</span><span class="o">.</span><span class="na">submissionLock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReentrantLock</span><span class="o">();</span>
        <span class="k">this</span><span class="o">.</span><span class="na">termination</span> <span class="o">=</span> <span class="n">submissionLock</span><span class="o">.</span><span class="na">newCondition</span><span class="o">();</span>
        <span class="n">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="o">(</span><span class="s">&#34;ForkJoinPool-&#34;</span><span class="o">);</span>
        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">poolNumberGenerator</span><span class="o">.</span><span class="na">incrementAndGet</span><span class="o">());</span>
        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">&#34;-worker-&#34;</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">workerNamePrefix</span> <span class="o">=</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
    
   <span class="c1">// Unsafe mechanics
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">sun</span><span class="o">.</span><span class="na">misc</span><span class="o">.</span><span class="na">Unsafe</span> <span class="n">UNSAFE</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">ctlOffset</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">stealCountOffset</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">blockedCountOffset</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">quiescerCountOffset</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">scanGuardOffset</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">nextWorkerNumberOffset</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">ABASE</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">ASHIFT</span><span class="o">;</span>

    <span class="kd">static</span> <span class="o">{</span>
        <span class="n">poolNumberGenerator</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicInteger</span><span class="o">();</span>
        <span class="n">workerSeedGenerator</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Random</span><span class="o">();</span>
        <span class="n">modifyThreadPermission</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RuntimePermission</span><span class="o">(</span><span class="s">&#34;modifyThread&#34;</span><span class="o">);</span>
        <span class="n">defaultForkJoinWorkerThreadFactory</span> <span class="o">=</span>
            <span class="k">new</span> <span class="n">DefaultForkJoinWorkerThreadFactory</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">s</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">UNSAFE</span> <span class="o">=</span> <span class="n">sun</span><span class="o">.</span><span class="na">misc</span><span class="o">.</span><span class="na">Unsafe</span><span class="o">.</span><span class="na">getUnsafe</span><span class="o">();</span>
            <span class="n">Class</span> <span class="n">k</span> <span class="o">=</span> <span class="n">ForkJoinPool</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
            <span class="n">ctlOffset</span> <span class="o">=</span> <span class="n">UNSAFE</span><span class="o">.</span><span class="na">objectFieldOffset</span>
                <span class="o">(</span><span class="n">k</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">&#34;ctl&#34;</span><span class="o">));</span>
            <span class="n">stealCountOffset</span> <span class="o">=</span> <span class="n">UNSAFE</span><span class="o">.</span><span class="na">objectFieldOffset</span>
                <span class="o">(</span><span class="n">k</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">&#34;stealCount&#34;</span><span class="o">));</span>
            <span class="n">blockedCountOffset</span> <span class="o">=</span> <span class="n">UNSAFE</span><span class="o">.</span><span class="na">objectFieldOffset</span>
                <span class="o">(</span><span class="n">k</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">&#34;blockedCount&#34;</span><span class="o">));</span>
            <span class="n">quiescerCountOffset</span> <span class="o">=</span> <span class="n">UNSAFE</span><span class="o">.</span><span class="na">objectFieldOffset</span>
                <span class="o">(</span><span class="n">k</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">&#34;quiescerCount&#34;</span><span class="o">));</span>
            <span class="n">scanGuardOffset</span> <span class="o">=</span> <span class="n">UNSAFE</span><span class="o">.</span><span class="na">objectFieldOffset</span>
                <span class="o">(</span><span class="n">k</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">&#34;scanGuard&#34;</span><span class="o">));</span>
            <span class="n">nextWorkerNumberOffset</span> <span class="o">=</span> <span class="n">UNSAFE</span><span class="o">.</span><span class="na">objectFieldOffset</span>
                <span class="o">(</span><span class="n">k</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">&#34;nextWorkerNumber&#34;</span><span class="o">));</span>
            <span class="n">Class</span> <span class="n">a</span> <span class="o">=</span> <span class="n">ForkJoinTask</span><span class="o">[].</span><span class="na">class</span><span class="o">;</span>
            <span class="n">ABASE</span> <span class="o">=</span> <span class="n">UNSAFE</span><span class="o">.</span><span class="na">arrayBaseOffset</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">UNSAFE</span><span class="o">.</span><span class="na">arrayIndexScale</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">Error</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">s</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">s</span><span class="o">-</span><span class="n">1</span><span class="o">))</span> <span class="o">!=</span> <span class="n">0</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">Error</span><span class="o">(</span><span class="s">&#34;data type scale not a power of two&#34;</span><span class="o">);</span>
        <span class="n">ASHIFT</span> <span class="o">=</span> <span class="n">31</span> <span class="o">-</span> <span class="n">Integer</span><span class="o">.</span><span class="na">numberOfLeadingZeros</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>    
<span class="o">}</span>     
</code></pre></td></tr></table>
</div>
</div><h3 id="5forkjoinpoolexecute-执行任务">5.ForkJoinPool.execute 执行任务</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">    <span class="cm">/**
</span><span class="cm">     * Arranges for (asynchronous) execution of the given task.
</span><span class="cm">     * 安排（异步）执行给定的任务。
</span><span class="cm">     * @param task the task
</span><span class="cm">     * @throws NullPointerException if the task is null
</span><span class="cm">     * @throws RejectedExecutionException if the task cannot be
</span><span class="cm">     *         scheduled for execution
</span><span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;</span> <span class="n">task</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">task</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">NullPointerException</span><span class="o">();</span>
        <span class="n">forkOrSubmit</span><span class="o">(</span><span class="n">task</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="cm">/**
</span><span class="cm">     * Unless terminating, forks task if within an ongoing FJ
</span><span class="cm">     * computation in the current pool, else submits as external task.
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">forkOrSubmit</span><span class="o">(</span><span class="n">ForkJoinTask</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">task</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ForkJoinWorkerThread</span> <span class="n">w</span><span class="o">;</span>
        <span class="n">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">shutdown</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">RejectedExecutionException</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">t</span> <span class="k">instanceof</span> <span class="n">ForkJoinWorkerThread</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
            <span class="o">(</span><span class="n">w</span> <span class="o">=</span> <span class="o">(</span><span class="n">ForkJoinWorkerThread</span><span class="o">)</span><span class="n">t</span><span class="o">).</span><span class="na">pool</span> <span class="o">==</span> <span class="k">this</span><span class="o">)</span>
            <span class="n">w</span><span class="o">.</span><span class="na">pushTask</span><span class="o">(</span><span class="n">task</span><span class="o">);</span>
        <span class="k">else</span>
            <span class="n">addSubmission</span><span class="o">(</span><span class="n">task</span><span class="o">);</span>
    <span class="o">}</span>    
</code></pre></td></tr></table>
</div>
</div><p>addSubmission 将提交的任务排入submissionQueue。除了使用submissionLock之外，和ForkJoinWorkerThread.pushTask一样。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">    <span class="cm">/**
</span><span class="cm">     * Enqueues the given task in the submissionQueue.  Same idea as
</span><span class="cm">     * ForkJoinWorkerThread.pushTask except for use of submissionLock.
</span><span class="cm">     *  将提交的任务排入submissionQueue。除了使用submissionLock之外，和ForkJoinWorkerThread.pushTask一样。
</span><span class="cm">     * @param t the task
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">addSubmission</span><span class="o">(</span><span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">ReentrantLock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">submissionLock</span><span class="o">;</span>
        <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;[]</span> <span class="n">q</span><span class="o">;</span> <span class="kt">int</span> <span class="n">s</span><span class="o">,</span> <span class="n">m</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">q</span> <span class="o">=</span> <span class="n">submissionQueue</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>    <span class="c1">// ignore if queue removed
</span><span class="c1"></span>                <span class="kt">long</span> <span class="n">u</span> <span class="o">=</span> <span class="o">(((</span><span class="n">s</span> <span class="o">=</span> <span class="n">queueTop</span><span class="o">)</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">m</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="n">1</span><span class="o">))</span> <span class="o">&lt;&lt;</span> <span class="n">ASHIFT</span><span class="o">)+</span><span class="n">ABASE</span><span class="o">;</span>
                <span class="n">UNSAFE</span><span class="o">.</span><span class="na">putOrderedObject</span><span class="o">(</span><span class="n">q</span><span class="o">,</span> <span class="n">u</span><span class="o">,</span> <span class="n">t</span><span class="o">);</span>
                <span class="n">queueTop</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">-</span> <span class="n">queueBase</span> <span class="o">==</span> <span class="n">m</span><span class="o">)</span> <span class="c1">//扩容
</span><span class="c1"></span>                    <span class="n">growSubmissionQueue</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="n">signalWork</span><span class="o">();</span>
    <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>growSubmissionQueue扩容</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">    <span class="cm">/**
</span><span class="cm">     * Creates or doubles submissionQueue array.
</span><span class="cm">     * Basically identical to ForkJoinWorkerThread version.
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">growSubmissionQueue</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;[]</span> <span class="n">oldQ</span> <span class="o">=</span> <span class="n">submissionQueue</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">oldQ</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">oldQ</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;&lt;</span> <span class="n">1</span> <span class="o">:</span> <span class="n">INITIAL_QUEUE_CAPACITY</span><span class="o">;</span> <span class="c1">//2倍扩容
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">MAXIMUM_QUEUE_CAPACITY</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">RejectedExecutionException</span><span class="o">(</span><span class="s">&#34;Queue capacity exceeded&#34;</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">INITIAL_QUEUE_CAPACITY</span><span class="o">)</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">INITIAL_QUEUE_CAPACITY</span><span class="o">;</span>
        <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;[]</span> <span class="n">q</span> <span class="o">=</span> <span class="n">submissionQueue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;[</span><span class="n">size</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">top</span> <span class="o">=</span> <span class="n">queueTop</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">oldMask</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">oldQ</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">oldMask</span> <span class="o">=</span> <span class="n">oldQ</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">queueBase</span><span class="o">;</span> <span class="n">b</span> <span class="o">!=</span> <span class="n">top</span><span class="o">;</span> <span class="o">++</span><span class="n">b</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">long</span> <span class="n">u</span> <span class="o">=</span> <span class="o">((</span><span class="n">b</span> <span class="o">&amp;</span> <span class="n">oldMask</span><span class="o">)</span> <span class="o">&lt;&lt;</span> <span class="n">ASHIFT</span><span class="o">)</span> <span class="o">+</span> <span class="n">ABASE</span><span class="o">;</span>
                <span class="n">Object</span> <span class="n">x</span> <span class="o">=</span> <span class="n">UNSAFE</span><span class="o">.</span><span class="na">getObjectVolatile</span><span class="o">(</span><span class="n">oldQ</span><span class="o">,</span> <span class="n">u</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapObject</span><span class="o">(</span><span class="n">oldQ</span><span class="o">,</span> <span class="n">u</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="kc">null</span><span class="o">))</span>
                    <span class="n">UNSAFE</span><span class="o">.</span><span class="na">putObjectVolatile</span>
                        <span class="o">(</span><span class="n">q</span><span class="o">,</span> <span class="o">((</span><span class="n">b</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="o">)</span> <span class="o">&lt;&lt;</span> <span class="n">ASHIFT</span><span class="o">)</span> <span class="o">+</span> <span class="n">ABASE</span><span class="o">,</span> <span class="n">x</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>signalWork 唤醒或创建一个工作</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">  <span class="cm">/**
</span><span class="cm">     * Wakes up or creates a worker.
</span><span class="cm">     */</span>
    <span class="kd">final</span> <span class="kt">void</span> <span class="nf">signalWork</span><span class="o">()</span> <span class="o">{</span>
        <span class="cm">/*
</span><span class="cm">         * The while condition is true if: (there is are too few total
</span><span class="cm">         * workers OR there is at least one waiter) AND (there are too
</span><span class="cm">         * few active workers OR the pool is terminating).  The value
</span><span class="cm">         * of e distinguishes the remaining cases: zero (no waiters)
</span><span class="cm">         * for create, negative if terminating (in which case do
</span><span class="cm">         * nothing), else release a waiter. The secondary checks for
</span><span class="cm">         * release (non-null array etc) can fail if the pool begins
</span><span class="cm">         * terminating after the test, and don&#39;t impose any added cost
</span><span class="cm">         * because JVMs must perform null and bounds checks anyway.
</span><span class="cm">         * 
</span><span class="cm">         * 如果满足以下条件，则条件成立：（总人数太少，或者至少有一个服务员）和（活动人员太少或游泳池正在终止）。
</span><span class="cm">          * e的价值区分其余的情况：零（无服务员）创造，否定如果终止（在这种情况下什么都不做），否则释放一个服务员。
</span><span class="cm">          * 如果池在测试之后开始终止，那么释放次数检查（非空数组等）可能会失败，因为JVM必须执行空值和边界检查，所以不会增加任何额外的开销。
</span><span class="cm">         */</span>
        <span class="kt">long</span> <span class="n">c</span><span class="o">;</span> <span class="kt">int</span> <span class="n">e</span><span class="o">,</span> <span class="n">u</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">((((</span><span class="n">e</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="n">c</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">))</span> <span class="o">|</span> <span class="o">(</span><span class="n">u</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="n">c</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">32</span><span class="o">)))</span> <span class="o">&amp;</span>
                <span class="o">(</span><span class="n">INT_SIGN</span><span class="o">|</span><span class="n">SHORT_SIGN</span><span class="o">))</span> <span class="o">==</span> <span class="o">(</span><span class="n">INT_SIGN</span><span class="o">|</span><span class="n">SHORT_SIGN</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">e</span> <span class="o">&gt;=</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>                         <span class="c1">// release a waiting worker 释放一名等待工作人员
</span><span class="c1"></span>                <span class="kt">int</span> <span class="n">i</span><span class="o">;</span> <span class="n">ForkJoinWorkerThread</span> <span class="n">w</span><span class="o">;</span> <span class="n">ForkJoinWorkerThread</span><span class="o">[]</span> <span class="n">ws</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">ws</span> <span class="o">=</span> <span class="n">workers</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span>
                    <span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="o">~</span><span class="n">e</span> <span class="o">&amp;</span> <span class="n">SMASK</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="n">ws</span><span class="o">.</span><span class="na">length</span> <span class="o">||</span>
                    <span class="o">(</span><span class="n">w</span> <span class="o">=</span> <span class="n">ws</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="kt">long</span> <span class="n">nc</span> <span class="o">=</span> <span class="o">(((</span><span class="kt">long</span><span class="o">)(</span><span class="n">w</span><span class="o">.</span><span class="na">nextWait</span> <span class="o">&amp;</span> <span class="n">E_MASK</span><span class="o">))</span> <span class="o">|</span>
                           <span class="o">((</span><span class="kt">long</span><span class="o">)(</span><span class="n">u</span> <span class="o">+</span> <span class="n">UAC_UNIT</span><span class="o">)</span> <span class="o">&lt;&lt;</span> <span class="n">32</span><span class="o">));</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">w</span><span class="o">.</span><span class="na">eventCount</span> <span class="o">==</span> <span class="n">e</span> <span class="o">&amp;&amp;</span>
                    <span class="n">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapLong</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">ctlOffset</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">nc</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">w</span><span class="o">.</span><span class="na">eventCount</span> <span class="o">=</span> <span class="o">(</span><span class="n">e</span> <span class="o">+</span> <span class="n">EC_UNIT</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">E_MASK</span><span class="o">;</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">w</span><span class="o">.</span><span class="na">parked</span><span class="o">)</span>
                        <span class="n">UNSAFE</span><span class="o">.</span><span class="na">unpark</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapLong</span>
                     <span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">ctlOffset</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span>
                      <span class="o">(</span><span class="kt">long</span><span class="o">)(((</span><span class="n">u</span> <span class="o">+</span> <span class="n">UTC_UNIT</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">UTC_MASK</span><span class="o">)</span> <span class="o">|</span>
                             <span class="o">((</span><span class="n">u</span> <span class="o">+</span> <span class="n">UAC_UNIT</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">UAC_MASK</span><span class="o">))</span> <span class="o">&lt;&lt;</span> <span class="n">32</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">addWorker</span><span class="o">();</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
 <span class="cm">/**
</span><span class="cm">     * Tries to create and start a worker; minimally rolls back counts
</span><span class="cm">     * on failure.
</span><span class="cm">     * 尝试创建和启动一个工人;最低限度地回滚失败的计数。
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">addWorker</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">Throwable</span> <span class="n">ex</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">ForkJoinWorkerThread</span> <span class="n">t</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">newThread</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Throwable</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">ex</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>  <span class="c1">// null or exceptional factory return
</span><span class="c1"></span>            <span class="kt">long</span> <span class="n">c</span><span class="o">;</span>       <span class="c1">// adjust counts
</span><span class="c1"></span>            <span class="k">do</span> <span class="o">{}</span> <span class="k">while</span> <span class="o">(!</span><span class="n">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapLong</span>
                         <span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">ctlOffset</span><span class="o">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">,</span>
                          <span class="o">(((</span><span class="n">c</span> <span class="o">-</span> <span class="n">AC_UNIT</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">AC_MASK</span><span class="o">)</span> <span class="o">|</span>
                           <span class="o">((</span><span class="n">c</span> <span class="o">-</span> <span class="n">TC_UNIT</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">TC_MASK</span><span class="o">)</span> <span class="o">|</span>
                           <span class="o">(</span><span class="n">c</span> <span class="o">&amp;</span> <span class="o">~(</span><span class="n">AC_MASK</span><span class="o">|</span><span class="n">TC_MASK</span><span class="o">)))));</span>
            <span class="c1">// Propagate exception if originating from an external caller
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(!</span><span class="n">tryTerminate</span><span class="o">(</span><span class="kc">false</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">ex</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span>
                <span class="o">!(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">()</span> <span class="k">instanceof</span> <span class="n">ForkJoinWorkerThread</span><span class="o">))</span>
                <span class="n">UNSAFE</span><span class="o">.</span><span class="na">throwException</span><span class="o">(</span><span class="n">ex</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">else</span>
            <span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
  
</code></pre></td></tr></table>
</div>
</div><p>创建ForkJoinWorkerThread构造调用pool.registerWorker,返回poolIndex</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">    <span class="cm">/**
</span><span class="cm">     * Callback from ForkJoinWorkerThread constructor to
</span><span class="cm">     * determine its poolIndex and record in workers array.
</span><span class="cm">     * 从ForkJoinWorkerThread构造函数中调用，以确定它的poolIndex和记录在workers数组中。
</span><span class="cm">     * @param w the worker
</span><span class="cm">     * @return the worker&#39;s pool index
</span><span class="cm">     */</span>
    <span class="kd">final</span> <span class="kt">int</span> <span class="nf">registerWorker</span><span class="o">(</span><span class="n">ForkJoinWorkerThread</span> <span class="n">w</span><span class="o">)</span> <span class="o">{</span>
        <span class="cm">/*
</span><span class="cm">         * In the typical case, a new worker acquires the lock, uses
</span><span class="cm">         * next available index and returns quickly.  Since we should
</span><span class="cm">         * not block callers (ultimately from signalWork or
</span><span class="cm">         * tryPreBlock) waiting for the lock needed to do this, we
</span><span class="cm">         * instead help release other workers while waiting for the
</span><span class="cm">         * lock.
</span><span class="cm">         * 在典型情况下，新员工获得锁定，使用下一个可用索引并快速返回。
</span><span class="cm">         * 由于我们不应该阻止呼叫者（最终来自signalWork或tryPreBlock）等待锁定所需的锁定，而是在等待锁定时帮助释放其他员工。
</span><span class="cm">         */</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">g</span><span class="o">;;)</span> <span class="o">{</span>
            <span class="n">ForkJoinWorkerThread</span><span class="o">[]</span> <span class="n">ws</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(((</span><span class="n">g</span> <span class="o">=</span> <span class="n">scanGuard</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">SG_UNIT</span><span class="o">)</span> <span class="o">==</span> <span class="n">0</span> <span class="o">&amp;&amp;</span>
                <span class="n">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapInt</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">scanGuardOffset</span><span class="o">,</span>
                                         <span class="n">g</span><span class="o">,</span> <span class="n">g</span> <span class="o">|</span> <span class="n">SG_UNIT</span><span class="o">))</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">nextWorkerIndex</span><span class="o">;</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">((</span><span class="n">ws</span> <span class="o">=</span> <span class="n">workers</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// ignore on shutdown
</span><span class="c1"></span>                        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">ws</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="n">0</span> <span class="o">||</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">||</span> <span class="n">ws</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                            <span class="k">for</span> <span class="o">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">ws</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="o">++</span><span class="n">k</span><span class="o">)</span>
                                <span class="o">;</span>
                            <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="n">n</span><span class="o">)</span>  <span class="c1">// 扩容
</span><span class="c1"></span>                                <span class="n">ws</span> <span class="o">=</span> <span class="n">workers</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="n">ws</span><span class="o">,</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="n">1</span><span class="o">);</span>
                        <span class="o">}</span>
                        <span class="n">ws</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">w</span><span class="o">;</span>
                        <span class="n">nextWorkerIndex</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
                        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">g</span> <span class="o">&amp;</span> <span class="n">SMASK</span><span class="o">;</span>
                        <span class="n">g</span> <span class="o">=</span> <span class="o">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="n">m</span><span class="o">)</span> <span class="o">?</span> <span class="o">((</span><span class="n">m</span> <span class="o">&lt;&lt;</span> <span class="n">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">SMASK</span> <span class="o">:</span> <span class="n">g</span> <span class="o">+</span> <span class="o">(</span><span class="n">SG_UNIT</span><span class="o">&lt;&lt;</span><span class="n">1</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
                    <span class="n">scanGuard</span> <span class="o">=</span> <span class="n">g</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">return</span> <span class="n">k</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="k">if</span> <span class="o">((</span><span class="n">ws</span> <span class="o">=</span> <span class="n">workers</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// help release others 帮助释放其他人
</span><span class="c1"></span>                <span class="k">for</span> <span class="o">(</span><span class="n">ForkJoinWorkerThread</span> <span class="n">u</span> <span class="o">:</span> <span class="n">ws</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">u</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">u</span><span class="o">.</span><span class="na">queueBase</span> <span class="o">!=</span> <span class="n">u</span><span class="o">.</span><span class="na">queueTop</span><span class="o">)</span> <span class="o">{</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">tryReleaseWaiter</span><span class="o">())</span>
                            <span class="k">break</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

</code></pre></td></tr></table>
</div>
</div><p>tryReleaseWaiter 释放一个工作线程</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">      <span class="cm">/**
</span><span class="cm">       * Variant of signalWork to help release waiters on rescans.
</span><span class="cm">       * Tries once to release a waiter if active count &lt; 0.
</span><span class="cm">       * 
</span><span class="cm">       * 信号的变化，以帮助释放重新扫描的工作线程。尝试一次释放一个工作线程，如果积极计数&lt;0。
</span><span class="cm">       * @return false if failed due to contention, else true
</span><span class="cm">       */</span>
      <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">tryReleaseWaiter</span><span class="o">()</span> <span class="o">{</span>
          <span class="kt">long</span> <span class="n">c</span><span class="o">;</span> <span class="kt">int</span> <span class="n">e</span><span class="o">,</span> <span class="n">i</span><span class="o">;</span> <span class="n">ForkJoinWorkerThread</span> <span class="n">w</span><span class="o">;</span> <span class="n">ForkJoinWorkerThread</span><span class="o">[]</span> <span class="n">ws</span><span class="o">;</span>
          <span class="k">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="n">c</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">))</span> <span class="o">&gt;</span> <span class="n">0</span> <span class="o">&amp;&amp;</span>  <span class="c1">//如果有等待线程
</span><span class="c1"></span>              <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="n">c</span> <span class="o">&gt;&gt;</span> <span class="n">AC_SHIFT</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">0</span> <span class="o">&amp;&amp;</span>  <span class="c1">//且当前活动线程数小于CPU核数
</span><span class="c1"></span>              <span class="o">(</span><span class="n">ws</span> <span class="o">=</span> <span class="n">workers</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span>
              <span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="o">~</span><span class="n">e</span> <span class="o">&amp;</span> <span class="n">SMASK</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">ws</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span>    <span class="c1">//检测控制信息中等待的工作线程的ID信息的合法性。
</span><span class="c1"></span>              <span class="o">(</span><span class="n">w</span> <span class="o">=</span> <span class="n">ws</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
              <span class="kt">long</span> <span class="n">nc</span> <span class="o">=</span> <span class="o">((</span><span class="kt">long</span><span class="o">)(</span><span class="n">w</span><span class="o">.</span><span class="na">nextWait</span> <span class="o">&amp;</span> <span class="n">E_MASK</span><span class="o">)</span> <span class="o">|</span>
                         <span class="o">((</span><span class="n">c</span> <span class="o">+</span> <span class="n">AC_UNIT</span><span class="o">)</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">AC_MASK</span><span class="o">|</span><span class="n">TC_MASK</span><span class="o">)));</span> <span class="c1">//尝试调整控制信息，增加活动工作线程计数，将Treiber stack下一个等待线程的ID信息设置到ctl
</span><span class="c1"></span>              <span class="k">if</span> <span class="o">(</span><span class="n">w</span><span class="o">.</span><span class="na">eventCount</span> <span class="o">!=</span> <span class="n">e</span> <span class="o">||</span>
                  <span class="o">!</span><span class="n">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapLong</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">ctlOffset</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">nc</span><span class="o">))</span> 
                  <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
              <span class="n">w</span><span class="o">.</span><span class="na">eventCount</span> <span class="o">=</span> <span class="o">(</span><span class="n">e</span> <span class="o">+</span> <span class="n">EC_UNIT</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">E_MASK</span><span class="o">;</span> <span class="c1">//累加w的eventCount
</span><span class="c1"></span>              <span class="k">if</span> <span class="o">(</span><span class="n">w</span><span class="o">.</span><span class="na">parked</span><span class="o">)</span>
                  <span class="n">UNSAFE</span><span class="o">.</span><span class="na">unpark</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>  <span class="c1">//唤醒w
</span><span class="c1"></span>          <span class="o">}</span>
          <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
      <span class="o">}</span>  
</code></pre></td></tr></table>
</div>
</div><p>ForkJoinWorkerThread.run执行pool.work</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">    <span class="cm">/**
</span><span class="cm">     * Top-level loop for worker threads: On each step: if the
</span><span class="cm">     * previous step swept through all queues and found no tasks, or
</span><span class="cm">     * there are excess threads, then possibly blocks. Otherwise,
</span><span class="cm">     * scans for and, if found, executes a task. Returns when pool
</span><span class="cm">     * and/or worker terminate.
</span><span class="cm">     *  工作线程的顶级循环：在每一步：如果上一步扫过所有队列，没有找到任务，或者有多余的线程，则可能会阻塞。
</span><span class="cm">     *  否则，扫描，如果找到，执行任务。当池和/或工人终止时返回。
</span><span class="cm">     * @param w the worker
</span><span class="cm">     */</span>
    <span class="kd">final</span> <span class="kt">void</span> <span class="nf">work</span><span class="o">(</span><span class="n">ForkJoinWorkerThread</span> <span class="n">w</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">boolean</span> <span class="n">swept</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>                <span class="c1">// true on empty scans
</span><span class="c1"></span>        <span class="kt">long</span> <span class="n">c</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">w</span><span class="o">.</span><span class="na">terminate</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="n">c</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">a</span><span class="o">;</span>                            <span class="c1">// active count
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(!</span><span class="n">swept</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">a</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="n">c</span> <span class="o">&gt;&gt;</span> <span class="n">AC_SHIFT</span><span class="o">))</span> <span class="o">&lt;=</span> <span class="n">0</span><span class="o">)</span>
                <span class="n">swept</span> <span class="o">=</span> <span class="n">scan</span><span class="o">(</span><span class="n">w</span><span class="o">,</span> <span class="n">a</span><span class="o">);</span>
            <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">tryAwaitWork</span><span class="o">(</span><span class="n">w</span><span class="o">,</span> <span class="n">c</span><span class="o">))</span>
                <span class="n">swept</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>scan 扫描任务</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">   <span class="c1">// Scanning for tasks
</span><span class="c1"></span>
    <span class="cm">/**
</span><span class="cm">     * Scans for and, if found, executes one task. Scans start at a
</span><span class="cm">     * random index of workers array, and randomly select the first
</span><span class="cm">     * (2*#workers)-1 probes, and then, if all empty, resort to 2
</span><span class="cm">     * circular sweeps, which is necessary to check quiescence. and
</span><span class="cm">     * taking a submission only if no stealable tasks were found.  The
</span><span class="cm">     * steal code inside the loop is a specialized form of
</span><span class="cm">     * ForkJoinWorkerThread.deqTask, followed bookkeeping to support
</span><span class="cm">     * helpJoinTask and signal propagation. The code for submission
</span><span class="cm">     * queues is almost identical. On each steal, the worker completes
</span><span class="cm">     * not only the task, but also all local tasks that this task may
</span><span class="cm">     * have generated. On detecting staleness or contention when
</span><span class="cm">     * trying to take a task, this method returns without finishing
</span><span class="cm">     * sweep, which allows global state rechecks before retry.
</span><span class="cm">     * 扫描，如果找到，执行一项任务。扫描开始于工作人员数组的随机索引，随机选择第一个（2*#workers）-1探针，
</span><span class="cm">     * 然后如果全部为空，则求助于2个循环扫描，这是检查静止所必需的。
</span><span class="cm">     * 只有在没有找到任何可拆卸的任务的情况下才提交。
</span><span class="cm">     * 循环内的窃取代码是ForkJoinWorkerThread.deqTask的一种特殊形式，
</span><span class="cm">     * 遵循簿记来支持helpJoinTask和信号传播。提交队列的代码几乎是相同的。
</span><span class="cm">     * 在每次偷窃时，工作者不仅完成任务，而且完成该任务可能已经产生的所有本地任务。
</span><span class="cm">     * 在尝试执行任务时检测陈旧性或争用时，此方法返回而不完成扫描，这允许在重试之前进行全局状态重新检查。
</span><span class="cm">     * @param w the worker
</span><span class="cm">     * @param a the number of active workers
</span><span class="cm">     * @return true if swept all queues without finding a task
</span><span class="cm">     */</span>
        <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">scan</span><span class="o">(</span><span class="n">ForkJoinWorkerThread</span> <span class="n">w</span><span class="o">,</span> <span class="kt">int</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">g</span> <span class="o">=</span> <span class="n">scanGuard</span><span class="o">;</span> 
            <span class="cm">/*
</span><span class="cm">             * 如果当前只有一个工作线程，将m设置为0，避免没用的扫描。
</span><span class="cm">             * 否则获取guard值。
</span><span class="cm">             */</span>
            <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="o">(</span><span class="n">parallelism</span> <span class="o">==</span> <span class="n">1</span> <span class="o">-</span> <span class="n">a</span> <span class="o">&amp;&amp;</span> <span class="n">blockedCount</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">?</span> <span class="n">0</span> <span class="o">:</span> <span class="n">g</span> <span class="o">&amp;</span> <span class="n">SMASK</span><span class="o">;</span>
            <span class="n">ForkJoinWorkerThread</span><span class="o">[]</span> <span class="n">ws</span> <span class="o">=</span> <span class="n">workers</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">ws</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">ws</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="o">)</span>         <span class="c1">// 过期检测
</span><span class="c1"></span>                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="na">seed</span><span class="o">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">r</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="o">-(</span><span class="n">m</span> <span class="o">+</span> <span class="n">m</span><span class="o">);</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">m</span> <span class="o">+</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;</span> <span class="n">t</span><span class="o">;</span> <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;[]</span> <span class="n">q</span><span class="o">;</span> <span class="kt">int</span> <span class="n">b</span><span class="o">,</span> <span class="n">i</span><span class="o">;</span>
                <span class="c1">//随机选出一个牺牲者(工作线程)。
</span><span class="c1"></span>                <span class="n">ForkJoinWorkerThread</span> <span class="n">v</span> <span class="o">=</span> <span class="n">ws</span><span class="o">[</span><span class="n">k</span> <span class="o">&amp;</span> <span class="n">m</span><span class="o">];</span>
                <span class="c1">//一系列检查...
</span><span class="c1"></span>                <span class="k">if</span> <span class="o">(</span><span class="n">v</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">b</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="na">queueBase</span><span class="o">)</span> <span class="o">!=</span> <span class="n">v</span><span class="o">.</span><span class="na">queueTop</span> <span class="o">&amp;&amp;</span>
                    <span class="o">(</span><span class="n">q</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="na">queue</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">b</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">//如果这个牺牲者的任务队列中还有任务，尝试窃取这个任务。
</span><span class="c1"></span>                    <span class="kt">long</span> <span class="n">u</span> <span class="o">=</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">ASHIFT</span><span class="o">)</span> <span class="o">+</span> <span class="n">ABASE</span><span class="o">;</span>
                    <span class="k">if</span> <span class="o">((</span><span class="n">t</span> <span class="o">=</span> <span class="n">q</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">v</span><span class="o">.</span><span class="na">queueBase</span> <span class="o">==</span> <span class="n">b</span> <span class="o">&amp;&amp;</span>
                        <span class="n">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapObject</span><span class="o">(</span><span class="n">q</span><span class="o">,</span> <span class="n">u</span><span class="o">,</span> <span class="n">t</span><span class="o">,</span> <span class="kc">null</span><span class="o">))</span> <span class="o">{</span>
                        <span class="c1">//窃取成功后，调整queueBase
</span><span class="c1"></span>                        <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="o">(</span><span class="n">v</span><span class="o">.</span><span class="na">queueBase</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">1</span><span class="o">)</span> <span class="o">-</span> <span class="n">v</span><span class="o">.</span><span class="na">queueTop</span><span class="o">;</span>
                        <span class="c1">//将牺牲者的stealHint设置为当前工作线程在pool中的下标。
</span><span class="c1"></span>                        <span class="n">v</span><span class="o">.</span><span class="na">stealHint</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="na">poolIndex</span><span class="o">;</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">d</span> <span class="o">!=</span> <span class="n">0</span><span class="o">)</span>
                            <span class="n">signalWork</span><span class="o">();</span>             <span class="c1">// 如果牺牲者的任务队列还有任务，继续唤醒(或创建)线程。
</span><span class="c1"></span>                        <span class="n">w</span><span class="o">.</span><span class="na">execTask</span><span class="o">(</span><span class="n">t</span><span class="o">);</span> <span class="c1">//执行窃取的任务。
</span><span class="c1"></span>                    <span class="o">}</span>
                    <span class="c1">//计算出下一个随机种子。
</span><span class="c1"></span>                    <span class="n">r</span> <span class="o">^=</span> <span class="n">r</span> <span class="o">&lt;&lt;</span> <span class="n">13</span><span class="o">;</span> <span class="n">r</span> <span class="o">^=</span> <span class="n">r</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">17</span><span class="o">;</span> <span class="n">w</span><span class="o">.</span><span class="na">seed</span> <span class="o">=</span> <span class="n">r</span> <span class="o">^</span> <span class="o">(</span><span class="n">r</span> <span class="o">&lt;&lt;</span> <span class="n">5</span><span class="o">);</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>                     <span class="c1">// 返回false，表示不是一个空扫描。
</span><span class="c1"></span>                <span class="o">}</span>
                <span class="c1">//前2*m次，随机扫描。
</span><span class="c1"></span>                <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>                     <span class="c1">// xorshift
</span><span class="c1"></span>                    <span class="n">r</span> <span class="o">^=</span> <span class="n">r</span> <span class="o">&lt;&lt;</span> <span class="n">13</span><span class="o">;</span> <span class="n">r</span> <span class="o">^=</span> <span class="n">r</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">17</span><span class="o">;</span> <span class="n">k</span> <span class="o">=</span> <span class="n">r</span> <span class="o">^=</span> <span class="n">r</span> <span class="o">&lt;&lt;</span> <span class="n">5</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="c1">//后2*m次，顺序扫描。
</span><span class="c1"></span>                <span class="k">else</span>
                    <span class="o">++</span><span class="n">k</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">scanGuard</span> <span class="o">!=</span> <span class="n">g</span><span class="o">)</span>                       <span class="c1">// staleness check
</span><span class="c1"></span>                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">else</span> <span class="o">{</span>                                   
                <span class="c1">//如果扫描完毕后没找到可窃取的任务，那么从Pool的提交任务队列中取一个任务来执行。
</span><span class="c1"></span>                <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;</span> <span class="n">t</span><span class="o">;</span> <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;[]</span> <span class="n">q</span><span class="o">;</span> <span class="kt">int</span> <span class="n">b</span><span class="o">,</span> <span class="n">i</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">b</span> <span class="o">=</span> <span class="n">queueBase</span><span class="o">)</span> <span class="o">!=</span> <span class="n">queueTop</span> <span class="o">&amp;&amp;</span>
                    <span class="o">(</span><span class="n">q</span> <span class="o">=</span> <span class="n">submissionQueue</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span>
                    <span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">b</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="kt">long</span> <span class="n">u</span> <span class="o">=</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">ASHIFT</span><span class="o">)</span> <span class="o">+</span> <span class="n">ABASE</span><span class="o">;</span>
                    <span class="k">if</span> <span class="o">((</span><span class="n">t</span> <span class="o">=</span> <span class="n">q</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">queueBase</span> <span class="o">==</span> <span class="n">b</span> <span class="o">&amp;&amp;</span>
                        <span class="n">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapObject</span><span class="o">(</span><span class="n">q</span><span class="o">,</span> <span class="n">u</span><span class="o">,</span> <span class="n">t</span><span class="o">,</span> <span class="kc">null</span><span class="o">))</span> <span class="o">{</span>
                        <span class="n">queueBase</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
                        <span class="n">w</span><span class="o">.</span><span class="na">execTask</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
                    <span class="o">}</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>                         <span class="c1">// 如果所有的队列(工作线程的任务队列和pool的任务队列)都是空的，返回true。
</span><span class="c1"></span>            <span class="o">}</span>
        <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">  <span class="cm">/**
</span><span class="cm">     * Tries to enqueue worker w in wait queue and await change in
</span><span class="cm">     * worker&#39;s eventCount.  If the pool is quiescent and there is
</span><span class="cm">     * more than one worker, possibly terminates worker upon exit.
</span><span class="cm">     * Otherwise, before blocking, rescans queues to avoid missed
</span><span class="cm">     * signals.  Upon finding work, releases at least one worker
</span><span class="cm">     * (which may be the current worker). Rescans restart upon
</span><span class="cm">     * detected staleness or failure to release due to
</span><span class="cm">     * contention. Note the unusual conventions about Thread.interrupt
</span><span class="cm">     * here and elsewhere: Because interrupts are used solely to alert
</span><span class="cm">     * threads to check termination, which is checked here anyway, we
</span><span class="cm">     * clear status (using Thread.interrupted) before any call to
</span><span class="cm">     * park, so that park does not immediately return due to status
</span><span class="cm">     * being set via some other unrelated call to interrupt in user
</span><span class="cm">     * code.
</span><span class="cm">     * 试图让工人排队，等待工人的事件计数。如果泳池静止，并且有多名工人，可能会在退出时终止工人。
</span><span class="cm">     * 否则，在阻塞之前，重新排队以避免错过信号。在找到工作时，至少释放一名工人（可能是当前工人）。
</span><span class="cm">      * Rescans在检测到过时或由于争用而无法释放时重新启动。注意这里和别处有关Thread.interrupt的不寻常约定：
</span><span class="cm">      * 由于中断仅用于提示线程检查终止，无论如何在这里检查终止，所以我们在任何调用停止之前清除状态（使用Thread.interrupted），
</span><span class="cm">      * 所以park立即返回由于状态被设置通过其他不相关的调用中断用户代码。
</span><span class="cm">     * @param w the calling worker
</span><span class="cm">     * @param c the ctl value on entry
</span><span class="cm">     * @return true if waited or another thread was released upon enq
</span><span class="cm">     */</span>
       <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">tryAwaitWork</span><span class="o">(</span><span class="n">ForkJoinWorkerThread</span> <span class="n">w</span><span class="o">,</span> <span class="kt">long</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
           <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="na">eventCount</span><span class="o">;</span>
           <span class="c1">//w的nextWait保存的是等待之前Pool的控制信息。
</span><span class="c1"></span>           <span class="n">w</span><span class="o">.</span><span class="na">nextWait</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">c</span><span class="o">;</span>
           <span class="c1">//这里是将当前线程的ID信息(下标取反)记录到Pool控制信息上
</span><span class="c1"></span>           <span class="c1">//同时将控制信息上的活动工作线程计数减1。
</span><span class="c1"></span>           <span class="kt">long</span> <span class="n">nc</span> <span class="o">=</span> <span class="o">(</span><span class="kt">long</span><span class="o">)(</span><span class="n">v</span> <span class="o">&amp;</span> <span class="n">E_MASK</span><span class="o">)</span> <span class="o">|</span> <span class="o">((</span><span class="n">c</span> <span class="o">-</span> <span class="n">AC_UNIT</span><span class="o">)</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">AC_MASK</span><span class="o">|</span><span class="n">TC_MASK</span><span class="o">));</span>
           <span class="k">if</span> <span class="o">(</span><span class="n">ctl</span> <span class="o">!=</span> <span class="n">c</span> <span class="o">||</span> <span class="o">!</span><span class="n">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapLong</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">ctlOffset</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">nc</span><span class="o">))</span> <span class="o">{</span>
               <span class="kt">long</span> <span class="n">d</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">;</span> 
               <span class="c1">// 如果和另外的一个窃取线程竞争并失败，这里返回true，work方法中会继续扫描。
</span><span class="c1"></span>               <span class="k">return</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">d</span> <span class="o">!=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">c</span> <span class="o">&amp;&amp;</span> <span class="o">((</span><span class="n">d</span> <span class="o">-</span> <span class="n">c</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">AC_MASK</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="n">0L</span><span class="o">;</span>
           <span class="o">}</span>
           <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">sc</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="na">stealCount</span><span class="o">;</span> <span class="n">sc</span> <span class="o">!=</span> <span class="n">0</span><span class="o">;)</span> <span class="o">{</span>   
               <span class="c1">//将工作线程上的stealCount原子累加到Pool的stealCount上面。
</span><span class="c1"></span>               <span class="kt">long</span> <span class="n">s</span> <span class="o">=</span> <span class="n">stealCount</span><span class="o">;</span>
               <span class="k">if</span> <span class="o">(</span><span class="n">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapLong</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">stealCountOffset</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">s</span> <span class="o">+</span> <span class="n">sc</span><span class="o">))</span>
                   <span class="n">sc</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="na">stealCount</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
               <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">w</span><span class="o">.</span><span class="na">eventCount</span> <span class="o">!=</span> <span class="n">v</span><span class="o">)</span>
                   <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>                      <span class="c1">//如果eventCount发生变化，重试。 
</span><span class="c1"></span>           <span class="o">}</span>
           <span class="k">if</span> <span class="o">((!</span><span class="n">shutdown</span> <span class="o">||</span> <span class="o">!</span><span class="n">tryTerminate</span><span class="o">(</span><span class="kc">false</span><span class="o">))</span> <span class="o">&amp;&amp;</span>
               <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">c</span> <span class="o">!=</span> <span class="n">0</span> <span class="o">&amp;&amp;</span> <span class="n">parallelism</span> <span class="o">+</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="n">nc</span> <span class="o">&gt;&gt;</span> <span class="n">AC_SHIFT</span><span class="o">)</span> <span class="o">==</span> <span class="n">0</span> <span class="o">&amp;&amp;</span>
               <span class="n">blockedCount</span> <span class="o">==</span> <span class="n">0</span> <span class="o">&amp;&amp;</span> <span class="n">quiescerCount</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span>
               <span class="c1">//如果满足上面的条件，说明当前Pool休眠了，需要调用下idleAwaitWork进行处理。
</span><span class="c1"></span>               <span class="c1">//上面的条件是：Pool未关闭 且 有工作线程 且 活动的工作线程数量等于cpu核心数量
</span><span class="c1"></span>               <span class="c1">//且没有工作线程在合并过程中阻塞 且 没有工作线程休眠。 
</span><span class="c1"></span>               <span class="n">idleAwaitWork</span><span class="o">(</span><span class="n">w</span><span class="o">,</span> <span class="n">nc</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>           <span class="c1">// quiescent
</span><span class="c1"></span>           <span class="k">for</span> <span class="o">(</span><span class="kt">boolean</span> <span class="n">rescanned</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;;)</span> <span class="o">{</span>
               <span class="k">if</span> <span class="o">(</span><span class="n">w</span><span class="o">.</span><span class="na">eventCount</span> <span class="o">!=</span> <span class="n">v</span><span class="o">)</span>
                   <span class="k">return</span> <span class="kc">true</span><span class="o">;</span> <span class="c1">//如果eventCount发生变化，重试。
</span><span class="c1"></span>               <span class="k">if</span> <span class="o">(!</span><span class="n">rescanned</span><span class="o">)</span> <span class="o">{</span>
                   <span class="kt">int</span> <span class="n">g</span> <span class="o">=</span> <span class="n">scanGuard</span><span class="o">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">g</span> <span class="o">&amp;</span> <span class="n">SMASK</span><span class="o">;</span>
                   <span class="n">ForkJoinWorkerThread</span><span class="o">[]</span> <span class="n">ws</span> <span class="o">=</span> <span class="n">workers</span><span class="o">;</span>
                   <span class="k">if</span> <span class="o">(</span><span class="n">ws</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">ws</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
                       <span class="n">rescanned</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                       <span class="c1">//这里再重新扫描一下，如果从其他工作线程任务队列里找到任务，尝试唤醒等待的工作线程。
</span><span class="c1"></span>                       <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                           <span class="n">ForkJoinWorkerThread</span> <span class="n">u</span> <span class="o">=</span> <span class="n">ws</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                           <span class="k">if</span> <span class="o">(</span><span class="n">u</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                               <span class="k">if</span> <span class="o">(</span><span class="n">u</span><span class="o">.</span><span class="na">queueBase</span> <span class="o">!=</span> <span class="n">u</span><span class="o">.</span><span class="na">queueTop</span> <span class="o">&amp;&amp;</span>
                                   <span class="o">!</span><span class="n">tryReleaseWaiter</span><span class="o">())</span>
                                   <span class="n">rescanned</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">// 发生竞争，再次扫描。
</span><span class="c1"></span>                               <span class="k">if</span> <span class="o">(</span><span class="n">w</span><span class="o">.</span><span class="na">eventCount</span> <span class="o">!=</span> <span class="n">v</span><span class="o">)</span>
                                   <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                           <span class="o">}</span>
                       <span class="o">}</span>
                   <span class="o">}</span>
                   <span class="k">if</span> <span class="o">(</span><span class="n">scanGuard</span> <span class="o">!=</span> <span class="n">g</span> <span class="o">||</span>              <span class="c1">// scanGuard发生变化
</span><span class="c1"></span>                       <span class="o">(</span><span class="n">queueBase</span> <span class="o">!=</span> <span class="n">queueTop</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">tryReleaseWaiter</span><span class="o">()))</span> <span class="c1">//或者从Pool任务队列中找到任务
</span><span class="c1"></span>                       <span class="n">rescanned</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">//再次扫描
</span><span class="c1"></span>                   <span class="k">if</span> <span class="o">(!</span><span class="n">rescanned</span><span class="o">)</span>
                       <span class="n">Thread</span><span class="o">.</span><span class="na">yield</span><span class="o">();</span>                <span class="c1">// 出让cpu，减少竞争。
</span><span class="c1"></span>                   <span class="k">else</span>
                       <span class="n">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">();</span>          <span class="c1">// park前清除中断标记。
</span><span class="c1"></span>               <span class="o">}</span>
               <span class="k">else</span> <span class="o">{</span>
                   <span class="n">w</span><span class="o">.</span><span class="na">parked</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>                   <span class="c1">// 设置park标记
</span><span class="c1"></span>                   <span class="k">if</span> <span class="o">(</span><span class="n">w</span><span class="o">.</span><span class="na">eventCount</span> <span class="o">!=</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>           <span class="c1">//再检测一下。
</span><span class="c1"></span>                       <span class="n">w</span><span class="o">.</span><span class="na">parked</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                       <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                   <span class="o">}</span>
                   <span class="n">LockSupport</span><span class="o">.</span><span class="na">park</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
                   <span class="n">rescanned</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="na">parked</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
               <span class="o">}</span>
           <span class="o">}</span>
       <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>等待</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">    <span class="cm">/**
</span><span class="cm">     * Possibly blocks waiting for the given task to complete, or
</span><span class="cm">     * cancels the task if terminating.  Fails to wait if contended.
</span><span class="cm">     *
</span><span class="cm">     * @param joinMe the task
</span><span class="cm">     */</span>
    <span class="kd">final</span> <span class="kt">void</span> <span class="nf">tryAwaitJoin</span><span class="o">(</span><span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;</span> <span class="n">joinMe</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">s</span><span class="o">;</span>
        <span class="n">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">();</span> <span class="c1">// clear interrupts before checking termination
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">joinMe</span><span class="o">.</span><span class="na">status</span> <span class="o">&gt;=</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">tryPreBlock</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">joinMe</span><span class="o">.</span><span class="na">tryAwaitDone</span><span class="o">(</span><span class="n">0L</span><span class="o">);</span>
                <span class="n">postBlock</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="k">if</span> <span class="o">((</span><span class="n">ctl</span> <span class="o">&amp;</span> <span class="n">STOP_BIT</span><span class="o">)</span> <span class="o">!=</span> <span class="n">0L</span><span class="o">)</span>
                <span class="n">joinMe</span><span class="o">.</span><span class="na">cancelIgnoringExceptions</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="cm">/**
</span><span class="cm">     * Tries to increment blockedCount, decrement active count
</span><span class="cm">     * (sometimes implicitly) and possibly release or create a
</span><span class="cm">     * compensating worker in preparation for blocking. Fails
</span><span class="cm">     * on contention or termination.
</span><span class="cm">     *
</span><span class="cm">     * @return true if the caller can block, else should recheck and retry
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">tryPreBlock</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">blockedCount</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapInt</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">blockedCountOffset</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">b</span> <span class="o">+</span> <span class="n">1</span><span class="o">))</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">pc</span> <span class="o">=</span> <span class="n">parallelism</span><span class="o">;</span>
            <span class="k">do</span> <span class="o">{</span>
                <span class="n">ForkJoinWorkerThread</span><span class="o">[]</span> <span class="n">ws</span><span class="o">;</span> <span class="n">ForkJoinWorkerThread</span> <span class="n">w</span><span class="o">;</span>
                <span class="kt">int</span> <span class="n">e</span><span class="o">,</span> <span class="n">ac</span><span class="o">,</span> <span class="n">tc</span><span class="o">,</span> <span class="n">rc</span><span class="o">,</span> <span class="n">i</span><span class="o">;</span>
                <span class="kt">long</span> <span class="n">c</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">;</span>
                <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="n">c</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">32</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">c</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
                                                 <span class="c1">// skip -- terminating
</span><span class="c1"></span>                <span class="o">}</span>
                <span class="k">else</span> <span class="k">if</span> <span class="o">((</span><span class="n">ac</span> <span class="o">=</span> <span class="o">(</span><span class="n">u</span> <span class="o">&gt;&gt;</span> <span class="n">UAC_SHIFT</span><span class="o">))</span> <span class="o">&lt;=</span> <span class="n">0</span> <span class="o">&amp;&amp;</span> <span class="n">e</span> <span class="o">!=</span> <span class="n">0</span> <span class="o">&amp;&amp;</span>
                         <span class="o">(</span><span class="n">ws</span> <span class="o">=</span> <span class="n">workers</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span>
                         <span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="o">~</span><span class="n">e</span> <span class="o">&amp;</span> <span class="n">SMASK</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">ws</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span>
                         <span class="o">(</span><span class="n">w</span> <span class="o">=</span> <span class="n">ws</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="kt">long</span> <span class="n">nc</span> <span class="o">=</span> <span class="o">((</span><span class="kt">long</span><span class="o">)(</span><span class="n">w</span><span class="o">.</span><span class="na">nextWait</span> <span class="o">&amp;</span> <span class="n">E_MASK</span><span class="o">)</span> <span class="o">|</span>
                               <span class="o">(</span><span class="n">c</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">AC_MASK</span><span class="o">|</span><span class="n">TC_MASK</span><span class="o">)));</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">w</span><span class="o">.</span><span class="na">eventCount</span> <span class="o">==</span> <span class="n">e</span> <span class="o">&amp;&amp;</span>
                        <span class="n">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapLong</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">ctlOffset</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">nc</span><span class="o">))</span> <span class="o">{</span>
                        <span class="n">w</span><span class="o">.</span><span class="na">eventCount</span> <span class="o">=</span> <span class="o">(</span><span class="n">e</span> <span class="o">+</span> <span class="n">EC_UNIT</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">E_MASK</span><span class="o">;</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">w</span><span class="o">.</span><span class="na">parked</span><span class="o">)</span>
                            <span class="n">UNSAFE</span><span class="o">.</span><span class="na">unpark</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>
                        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>             <span class="c1">// release an idle worker
</span><span class="c1"></span>                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="k">else</span> <span class="k">if</span> <span class="o">((</span><span class="n">tc</span> <span class="o">=</span> <span class="o">(</span><span class="kt">short</span><span class="o">)(</span><span class="n">u</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">UTC_SHIFT</span><span class="o">))</span> <span class="o">&gt;=</span> <span class="n">0</span> <span class="o">&amp;&amp;</span> <span class="n">ac</span> <span class="o">+</span> <span class="n">pc</span> <span class="o">&gt;</span> <span class="n">1</span><span class="o">)</span> <span class="o">{</span>
                    <span class="kt">long</span> <span class="n">nc</span> <span class="o">=</span> <span class="o">((</span><span class="n">c</span> <span class="o">-</span> <span class="n">AC_UNIT</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">AC_MASK</span><span class="o">)</span> <span class="o">|</span> <span class="o">(</span><span class="n">c</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">AC_MASK</span><span class="o">);</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapLong</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">ctlOffset</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">nc</span><span class="o">))</span>
                        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>             <span class="c1">// no compensation needed
</span><span class="c1"></span>                <span class="o">}</span>
                <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">tc</span> <span class="o">+</span> <span class="n">pc</span> <span class="o">&lt;</span> <span class="n">MAX_ID</span><span class="o">)</span> <span class="o">{</span>
                    <span class="kt">long</span> <span class="n">nc</span> <span class="o">=</span> <span class="o">((</span><span class="n">c</span> <span class="o">+</span> <span class="n">TC_UNIT</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">TC_MASK</span><span class="o">)</span> <span class="o">|</span> <span class="o">(</span><span class="n">c</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">TC_MASK</span><span class="o">);</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapLong</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">ctlOffset</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">nc</span><span class="o">))</span> <span class="o">{</span>
                        <span class="n">addWorker</span><span class="o">();</span>
                        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>            <span class="c1">// create a replacement
</span><span class="c1"></span>                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="c1">// try to back out on any failure and let caller retry
</span><span class="c1"></span>            <span class="o">}</span> <span class="k">while</span> <span class="o">(!</span><span class="n">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapInt</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">blockedCountOffset</span><span class="o">,</span>
                                               <span class="n">b</span> <span class="o">=</span> <span class="n">blockedCount</span><span class="o">,</span> <span class="n">b</span> <span class="o">-</span> <span class="n">1</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="cm">/**
</span><span class="cm">     * Decrements blockedCount and increments active count
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">postBlock</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">c</span><span class="o">;</span>
        <span class="k">do</span> <span class="o">{}</span> <span class="k">while</span> <span class="o">(!</span><span class="n">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapLong</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">ctlOffset</span><span class="o">,</span>  <span class="c1">// no mask
</span><span class="c1"></span>                                                <span class="n">c</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">,</span> <span class="n">c</span> <span class="o">+</span> <span class="n">AC_UNIT</span><span class="o">));</span>
        <span class="kt">int</span> <span class="n">b</span><span class="o">;</span>
        <span class="k">do</span> <span class="o">{}</span> <span class="k">while</span> <span class="o">(!</span><span class="n">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapInt</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">blockedCountOffset</span><span class="o">,</span>
                                               <span class="n">b</span> <span class="o">=</span> <span class="n">blockedCount</span><span class="o">,</span> <span class="n">b</span> <span class="o">-</span> <span class="n">1</span><span class="o">));</span>
    <span class="o">}</span>    
</code></pre></td></tr></table>
</div>
</div><h2 id="一forkjointask源码分析">一、ForkJoinTask源码分析</h2>
<p>ForkJoinTask抽象类实现Future接口</p>
<p><img src="/concurrent//FutrureMethod.png" alt=""></p>
<h3 id="1forkjointask构造">1.ForkJoinTask构造</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">ForkJoinTask</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">Future</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;,</span> <span class="n">Serializable</span> <span class="o">{</span>

    <span class="cm">/*
</span><span class="cm">     * See the internal documentation of class ForkJoinPool for a
</span><span class="cm">     * general implementation overview.  ForkJoinTasks are mainly
</span><span class="cm">     * responsible for maintaining their &#34;status&#34; field amidst relays
</span><span class="cm">     * to methods in ForkJoinWorkerThread and ForkJoinPool. The
</span><span class="cm">     * methods of this class are more-or-less layered into (1) basic
</span><span class="cm">     * status maintenance (2) execution and awaiting completion (3)
</span><span class="cm">     * user-level methods that additionally report results. This is
</span><span class="cm">     * sometimes hard to see because this file orders exported methods
</span><span class="cm">     * in a way that flows well in javadocs.
</span><span class="cm">     * 请参阅ForkJoinPool类的内部文档以获取常规实施概述。
</span><span class="cm">      * ForkJoinTasks主要负责在中继到ForkJoinWorkerThread和ForkJoinPool中的方法中维护其&#34;status&#34;字段。这个类的方法或多或少分为
</span><span class="cm">      * （1）基本状态维护
</span><span class="cm">      * （2）执行和等待完成
</span><span class="cm">      * （3）用户级方法，另外报告结果。
</span><span class="cm">      * 有时候很难看到这个文件，因为这个文件在javadoc中以一种流畅的方式命令导出的方法。
</span><span class="cm">     */</span>

    <span class="cm">/*
</span><span class="cm">     * The status field holds run control status bits packed into a
</span><span class="cm">     * single int to minimize footprint and to ensure atomicity (via
</span><span class="cm">     * CAS).  Status is initially zero, and takes on nonnegative
</span><span class="cm">     * values until completed, upon which status holds value
</span><span class="cm">     * NORMAL, CANCELLED, or EXCEPTIONAL. Tasks undergoing blocking
</span><span class="cm">     * waits by other threads have the SIGNAL bit set.  Completion of
</span><span class="cm">     * a stolen task with SIGNAL set awakens any waiters via
</span><span class="cm">     * notifyAll. Even though suboptimal for some purposes, we use
</span><span class="cm">     * basic builtin wait/notify to take advantage of &#34;monitor
</span><span class="cm">     * inflation&#34; in JVMs that we would otherwise need to emulate to
</span><span class="cm">     * avoid adding further per-task bookkeeping overhead.  We want
</span><span class="cm">     * these monitors to be &#34;fat&#34;, i.e., not use biasing or thin-lock
</span><span class="cm">     * techniques, so use some odd coding idioms that tend to avoid
</span><span class="cm">     * them.
</span><span class="cm">     * 
</span><span class="cm">     * 状态字段将运行控制状态位保存在一个int中，以最小化占用空间并确保原子性（通过CAS）。状态初始为零，并且在完成之前呈现非负值，
</span><span class="cm">     * 状态保持NORMAL，CANCELED或EXCEPTIONAL值。由其他线程阻塞等待的任务将设置SIGNAL位。通过SIGNAL设置完成被盗任务，
</span><span class="cm">     * 通过notifyAll唤醒任何服务员。尽管对于某些目的而言是次优的，但是我们使用基本的内建等待/通知来利用JVM中的&#34;监视器通货膨胀&#34;，
</span><span class="cm">     * 否则我们需要模拟它们以避免增加每个任务的簿记开销。我们希望这些监视器是&#34;fat&#34;的，即不使用偏置或薄锁技术，所以使用一些奇怪的编码习惯用法来避免它们。
</span><span class="cm">     * 
</span><span class="cm">     */</span>

    <span class="cm">/** The run status of this task */</span>
    <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">status</span><span class="o">;</span> <span class="c1">// accessed directly by pool and workers
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">NORMAL</span>      <span class="o">=</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">CANCELLED</span>   <span class="o">=</span> <span class="o">-</span><span class="n">2</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">EXCEPTIONAL</span> <span class="o">=</span> <span class="o">-</span><span class="n">3</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">SIGNAL</span>      <span class="o">=</span>  <span class="n">1</span><span class="o">;</span>
    
        <span class="cm">/**
</span><span class="cm">         * Marks completion and wakes up threads waiting to join this task,
</span><span class="cm">         * also clearing signal request bits.
</span><span class="cm">         *
</span><span class="cm">         * @param completion one of NORMAL, CANCELLED, EXCEPTIONAL
</span><span class="cm">         * @return completion status on exit
</span><span class="cm">         */</span>
        <span class="kd">private</span> <span class="kt">int</span> <span class="nf">setCompletion</span><span class="o">(</span><span class="kt">int</span> <span class="n">completion</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">s</span><span class="o">;;)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">s</span> <span class="o">=</span> <span class="n">status</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span>
                    <span class="k">return</span> <span class="n">s</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapInt</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">statusOffset</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">completion</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">!=</span> <span class="n">0</span><span class="o">)</span>
                        <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span> <span class="n">notifyAll</span><span class="o">();</span> <span class="o">}</span>
                    <span class="k">return</span> <span class="n">completion</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    
 <span class="o">}</span>   
    
    
</code></pre></td></tr></table>
</div>
</div><h3 id="2-exceptionnode-异常节点">2. ExceptionNode 异常节点</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">    <span class="cm">/**
</span><span class="cm">     * Key-value nodes for exception table.  The chained hash table
</span><span class="cm">     * uses identity comparisons, full locking, and weak references
</span><span class="cm">     * for keys. The table has a fixed capacity because it only
</span><span class="cm">     * maintains task exceptions long enough for joiners to access
</span><span class="cm">     * them, so should never become very large for sustained
</span><span class="cm">     * periods. However, since we do not know when the last joiner
</span><span class="cm">     * completes, we must use weak references and expunge them. We do
</span><span class="cm">     * so on each operation (hence full locking). Also, some thread in
</span><span class="cm">     * any ForkJoinPool will call helpExpungeStaleExceptions when its
</span><span class="cm">     * pool becomes isQuiescent.
</span><span class="cm">     * 异常表的键值节点。链式哈希表使用标识比较，完全锁定和对引用的弱引用。
</span><span class="cm">     * 该表具有固定的容量，因为它只保留足够长的任务异常来访问它们，所以永远不会变得非常大。
</span><span class="cm">     * 但是，由于我们不知道最后一个细木工何时完成，所以我们必须使用弱引用并将其删除。我们这样做每个操作（因此完全锁定）。
</span><span class="cm">     * 而且，任何ForkJoinPool中的某个线程在其池变为isQuiescent时将调用helpExpungeStaleExceptions。
</span><span class="cm">     */</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">ExceptionNode</span> <span class="kd">extends</span> <span class="n">WeakReference</span><span class="o">&lt;</span><span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;&gt;</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">Throwable</span> <span class="n">ex</span><span class="o">;</span>
        <span class="n">ExceptionNode</span> <span class="n">next</span><span class="o">;</span>
        <span class="kd">final</span> <span class="kt">long</span> <span class="n">thrower</span><span class="o">;</span>  <span class="c1">// use id not ref to avoid weak cycles 使用id不能避免弱循环
</span><span class="c1"></span>        <span class="kd">final</span> <span class="kt">int</span> <span class="n">hashCode</span><span class="o">;</span>  <span class="c1">// store task hashCode before weak ref disappears 在弱ref消失之前存储任务哈希代码
</span><span class="c1"></span>        <span class="n">ExceptionNode</span><span class="o">(</span><span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;</span> <span class="n">task</span><span class="o">,</span> <span class="n">Throwable</span> <span class="n">ex</span><span class="o">,</span> <span class="n">ExceptionNode</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">super</span><span class="o">(</span><span class="n">task</span><span class="o">,</span> <span class="n">exceptionTableRefQueue</span><span class="o">);</span>
            <span class="k">this</span><span class="o">.</span><span class="na">ex</span> <span class="o">=</span> <span class="n">ex</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">thrower</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getId</span><span class="o">();</span>
            <span class="k">this</span><span class="o">.</span><span class="na">hashCode</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">identityHashCode</span><span class="o">(</span><span class="n">task</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="3-doexec-执行">3. doExec 执行</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">    <span class="cm">/**
</span><span class="cm">     * Primary execution method for stolen tasks. Unless done, calls
</span><span class="cm">     * exec and records status if completed, but doesn&#39;t wait for
</span><span class="cm">     * completion otherwise.
</span><span class="cm">     * 被偷任务的主要执行方法。除非已经完成，否则调用exec和记录状态(如果完成了)，但不等待其他的完成。
</span><span class="cm">     */</span>
    <span class="kd">final</span> <span class="kt">void</span> <span class="nf">doExec</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">status</span> <span class="o">&gt;=</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">boolean</span> <span class="n">completed</span><span class="o">;</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">completed</span> <span class="o">=</span> <span class="n">exec</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Throwable</span> <span class="n">rex</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">setExceptionalCompletion</span><span class="o">(</span><span class="n">rex</span><span class="o">);</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">completed</span><span class="o">)</span>
                <span class="n">setCompletion</span><span class="o">(</span><span class="n">NORMAL</span><span class="o">);</span> <span class="c1">// must be outside try block
</span><span class="c1"></span>        <span class="o">}</span>
    <span class="o">}</span>
    
     <span class="cm">/**
</span><span class="cm">      * Immediately performs the base action of this task.  This method
</span><span class="cm">      * is designed to support extensions, and should not in general be
</span><span class="cm">      * called otherwise. The return value controls whether this task
</span><span class="cm">      * is considered to be done normally. It may return false in
</span><span class="cm">      * asynchronous actions that require explicit invocations of
</span><span class="cm">      * {@link #complete} to become joinable. It may also throw an
</span><span class="cm">      * (unchecked) exception to indicate abnormal exit.
</span><span class="cm">      *
</span><span class="cm">      * @return {@code true} if completed normally
</span><span class="cm">      */</span>
     <span class="kd">protected</span> <span class="kd">abstract</span> <span class="kt">boolean</span> <span class="nf">exec</span><span class="o">();</span>   
     
    <span class="cm">/**
</span><span class="cm">     * Records exception and sets exceptional completion.
</span><span class="cm">     *
</span><span class="cm">     * @return status on exit
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">setExceptionalCompletion</span><span class="o">(</span><span class="n">Throwable</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">identityHashCode</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
        <span class="kd">final</span> <span class="n">ReentrantLock</span> <span class="n">lock</span> <span class="o">=</span> <span class="n">exceptionTableLock</span><span class="o">;</span>
        <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">expungeStaleExceptions</span><span class="o">();</span>
            <span class="n">ExceptionNode</span><span class="o">[]</span> <span class="n">t</span> <span class="o">=</span> <span class="n">exceptionTable</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">h</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">);</span>
            <span class="k">for</span> <span class="o">(</span><span class="n">ExceptionNode</span> <span class="n">e</span> <span class="o">=</span> <span class="n">t</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> <span class="o">;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">t</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ExceptionNode</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">ex</span><span class="o">,</span> <span class="n">t</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">get</span><span class="o">()</span> <span class="o">==</span> <span class="k">this</span><span class="o">)</span> <span class="c1">// already present
</span><span class="c1"></span>                    <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">setCompletion</span><span class="o">(</span><span class="n">EXCEPTIONAL</span><span class="o">);</span>
    <span class="o">}</span>
    

  <span class="cm">/**
</span><span class="cm">   * Poll stale refs and remove them. Call only while holding lock.
</span><span class="cm">   */</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">expungeStaleExceptions</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">for</span> <span class="o">(</span><span class="n">Object</span> <span class="n">x</span><span class="o">;</span> <span class="o">(</span><span class="n">x</span> <span class="o">=</span> <span class="n">exceptionTableRefQueue</span><span class="o">.</span><span class="na">poll</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;)</span> <span class="o">{</span>
          <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="k">instanceof</span> <span class="n">ExceptionNode</span><span class="o">)</span> <span class="o">{</span>
              <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;</span> <span class="n">key</span> <span class="o">=</span> <span class="o">((</span><span class="n">ExceptionNode</span><span class="o">)</span><span class="n">x</span><span class="o">).</span><span class="na">get</span><span class="o">();</span>
              <span class="n">ExceptionNode</span><span class="o">[]</span> <span class="n">t</span> <span class="o">=</span> <span class="n">exceptionTable</span><span class="o">;</span>
              <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">identityHashCode</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">);</span>
              <span class="n">ExceptionNode</span> <span class="n">e</span> <span class="o">=</span> <span class="n">t</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
              <span class="n">ExceptionNode</span> <span class="n">pred</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
              <span class="k">while</span> <span class="o">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                  <span class="n">ExceptionNode</span> <span class="n">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                  <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">==</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
                      <span class="k">if</span> <span class="o">(</span><span class="n">pred</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                          <span class="n">t</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
                      <span class="k">else</span>
                          <span class="n">pred</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
                      <span class="k">break</span><span class="o">;</span>
                  <span class="o">}</span>
                  <span class="n">pred</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                  <span class="n">e</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
              <span class="o">}</span>
          <span class="o">}</span>
      <span class="o">}</span>
  <span class="o">}</span>    
     
</code></pre></td></tr></table>
</div>
</div><h3 id="4-fork-执行">4. fork 执行</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">    <span class="cm">/**
</span><span class="cm">     * Arranges to asynchronously execute this task.  While it is not
</span><span class="cm">     * necessarily enforced, it is a usage error to fork a task more
</span><span class="cm">     * than once unless it has completed and been reinitialized.
</span><span class="cm">     * Subsequent modifications to the state of this task or any data
</span><span class="cm">     * it operates on are not necessarily consistently observable by
</span><span class="cm">     * any thread other than the one executing it unless preceded by a
</span><span class="cm">     * call to {@link #join} or related methods, or a call to {@link
</span><span class="cm">     * #isDone} returning {@code true}.
</span><span class="cm">     *
</span><span class="cm">     * &lt;p&gt;This method may be invoked only from within {@code
</span><span class="cm">     * ForkJoinPool} computations (as may be determined using method
</span><span class="cm">     * {@link #inForkJoinPool}).  Attempts to invoke in other contexts
</span><span class="cm">     * result in exceptions or errors, possibly including {@code
</span><span class="cm">     * ClassCastException}.
</span><span class="cm">     *
</span><span class="cm">     * @return {@code this}, to simplify usage
</span><span class="cm">     */</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="n">ForkJoinTask</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="nf">fork</span><span class="o">()</span> <span class="o">{</span>
        <span class="o">((</span><span class="n">ForkJoinWorkerThread</span><span class="o">)</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">())</span>
            <span class="o">.</span><span class="na">pushTask</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="5-join-执行">5. join 执行</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">
  <span class="cm">/**
</span><span class="cm">   * Returns the result of the computation when it {@link #isDone is
</span><span class="cm">   * done}.  This method differs from {@link #get()} in that
</span><span class="cm">   * abnormal completion results in {@code RuntimeException} or
</span><span class="cm">   * {@code Error}, not {@code ExecutionException}, and that
</span><span class="cm">   * interrupts of the calling thread do &lt;em&gt;not&lt;/em&gt; cause the
</span><span class="cm">   * method to abruptly return by throwing {@code
</span><span class="cm">   * InterruptedException}.
</span><span class="cm">   *
</span><span class="cm">   * @return the computed result
</span><span class="cm">   */</span>
  <span class="kd">public</span> <span class="kd">final</span> <span class="n">V</span> <span class="nf">join</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">doJoin</span><span class="o">()</span> <span class="o">!=</span> <span class="n">NORMAL</span><span class="o">)</span>
          <span class="k">return</span> <span class="n">reportResult</span><span class="o">();</span>
      <span class="k">else</span>
          <span class="k">return</span> <span class="n">getRawResult</span><span class="o">();</span><span class="c1">//返回结果
</span><span class="c1"></span>  <span class="o">}</span>
  

  <span class="cm">/**
</span><span class="cm">   * Primary mechanics for join, get, quietlyJoin.
</span><span class="cm">   * 主要机制join, get, quietlyJoin.
</span><span class="cm">   * @return status upon completion
</span><span class="cm">   */</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="nf">doJoin</span><span class="o">()</span> <span class="o">{</span>
      <span class="n">Thread</span> <span class="n">t</span><span class="o">;</span> <span class="n">ForkJoinWorkerThread</span> <span class="n">w</span><span class="o">;</span> <span class="kt">int</span> <span class="n">s</span><span class="o">;</span> <span class="kt">boolean</span> <span class="n">completed</span><span class="o">;</span>
      <span class="k">if</span> <span class="o">((</span><span class="n">t</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">())</span> <span class="k">instanceof</span> <span class="n">ForkJoinWorkerThread</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">if</span> <span class="o">((</span><span class="n">s</span> <span class="o">=</span> <span class="n">status</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span>
              <span class="k">return</span> <span class="n">s</span><span class="o">;</span>
          <span class="k">if</span> <span class="o">((</span><span class="n">w</span> <span class="o">=</span> <span class="o">(</span><span class="n">ForkJoinWorkerThread</span><span class="o">)</span><span class="n">t</span><span class="o">).</span><span class="na">unpushTask</span><span class="o">(</span><span class="k">this</span><span class="o">))</span> <span class="o">{</span>
              <span class="k">try</span> <span class="o">{</span>
                  <span class="n">completed</span> <span class="o">=</span> <span class="n">exec</span><span class="o">();</span>
              <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Throwable</span> <span class="n">rex</span><span class="o">)</span> <span class="o">{</span>
                  <span class="k">return</span> <span class="n">setExceptionalCompletion</span><span class="o">(</span><span class="n">rex</span><span class="o">);</span>
              <span class="o">}</span>
              <span class="k">if</span> <span class="o">(</span><span class="n">completed</span><span class="o">)</span>
                  <span class="k">return</span> <span class="n">setCompletion</span><span class="o">(</span><span class="n">NORMAL</span><span class="o">);</span>
          <span class="o">}</span>
          <span class="k">return</span> <span class="n">w</span><span class="o">.</span><span class="na">joinTask</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
      <span class="o">}</span>
      <span class="k">else</span>
          <span class="k">return</span> <span class="n">externalAwaitDone</span><span class="o">();</span>
  <span class="o">}</span> 
  

  <span class="cm">/**
</span><span class="cm">   * Blocks a non-worker-thread until completion.
</span><span class="cm">   * @return status upon completion
</span><span class="cm">   */</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="nf">externalAwaitDone</span><span class="o">()</span> <span class="o">{</span>
      <span class="kt">int</span> <span class="n">s</span><span class="o">;</span>
      <span class="k">if</span> <span class="o">((</span><span class="n">s</span> <span class="o">=</span> <span class="n">status</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
          <span class="kt">boolean</span> <span class="n">interrupted</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
          <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
              <span class="k">while</span> <span class="o">((</span><span class="n">s</span> <span class="o">=</span> <span class="n">status</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
                  <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span>
                      <span class="n">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapInt</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">statusOffset</span><span class="o">,</span>
                                               <span class="n">0</span><span class="o">,</span> <span class="n">SIGNAL</span><span class="o">);</span>
                  <span class="k">else</span> <span class="o">{</span>
                      <span class="k">try</span> <span class="o">{</span>
                          <span class="n">wait</span><span class="o">();</span>
                      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">ie</span><span class="o">)</span> <span class="o">{</span>
                          <span class="n">interrupted</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                      <span class="o">}</span>
                  <span class="o">}</span>
              <span class="o">}</span>
          <span class="o">}</span>
          <span class="k">if</span> <span class="o">(</span><span class="n">interrupted</span><span class="o">)</span>
              <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">interrupt</span><span class="o">();</span>
      <span class="o">}</span>
      <span class="k">return</span> <span class="n">s</span><span class="o">;</span>
  <span class="o">}</span>
    <span class="cm">/**
</span><span class="cm">     * Report the result of invoke or join; called only upon
</span><span class="cm">     * non-normal return of internal versions.
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="n">V</span> <span class="nf">reportResult</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">s</span><span class="o">;</span> <span class="n">Throwable</span> <span class="n">ex</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">s</span> <span class="o">=</span> <span class="n">status</span><span class="o">)</span> <span class="o">==</span> <span class="n">CANCELLED</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">CancellationException</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">EXCEPTIONAL</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">ex</span> <span class="o">=</span> <span class="n">getThrowableException</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">UNSAFE</span><span class="o">.</span><span class="na">throwException</span><span class="o">(</span><span class="n">ex</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">getRawResult</span><span class="o">();</span>
    <span class="o">}</span>

  <span class="cm">/**
</span><span class="cm">   * Tries to block a worker thread until completed or timed out.
</span><span class="cm">   * Uses Object.wait time argument conventions.
</span><span class="cm">   * May fail on contention or interrupt.
</span><span class="cm">   *
</span><span class="cm">   * @param millis if &gt; 0, wait time.
</span><span class="cm">   */</span>
  <span class="kd">final</span> <span class="kt">void</span> <span class="nf">tryAwaitDone</span><span class="o">(</span><span class="kt">long</span> <span class="n">millis</span><span class="o">)</span> <span class="o">{</span>
      <span class="kt">int</span> <span class="n">s</span><span class="o">;</span>
      <span class="k">try</span> <span class="o">{</span>
          <span class="k">if</span> <span class="o">(((</span><span class="n">s</span> <span class="o">=</span> <span class="n">status</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">0</span> <span class="o">||</span>
               <span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">0</span> <span class="o">&amp;&amp;</span>
                <span class="n">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapInt</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">statusOffset</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">SIGNAL</span><span class="o">)))</span> <span class="o">&amp;&amp;</span>
              <span class="n">status</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
              <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
                  <span class="k">if</span> <span class="o">(</span><span class="n">status</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span>
                      <span class="n">wait</span><span class="o">(</span><span class="n">millis</span><span class="o">);</span>
              <span class="o">}</span>
          <span class="o">}</span>
      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">ie</span><span class="o">)</span> <span class="o">{</span>
          <span class="c1">// caller must check termination
</span><span class="c1"></span>      <span class="o">}</span>
  <span class="o">}</span>
  
</code></pre></td></tr></table>
</div>
</div>
  </div>

  <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">BirdGod</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2017-05-03 19:11
        
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a target="_blank" rel="license noopener" href="https://github.com/birdgodtech/blog/master/LICENSE">MIT</a></span>
  </p>
</div>
<footer class="post-footer">
    <div class="post-tags">
      <a href="/tags/ForkJoin/">ForkJoin</a>
      </div>
    <nav class="post-nav" style="height: 27px">
      <a class="prev" href="/post/concurrent/16.StampedLock/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">StamppedLock</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
      <a class="next" href="/post/concurrent/14.ScheduledThreadPoolExecutor%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">
        <span class="next-text nav-default">ThreadPoolExecutor</span>
        <span class="next-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav>
  </footer>
  <script src="https://utteranc.es/client.js"
          repo="birdgodtech/birdgodtech.github.io"
          issue-term="pathname"
          theme="github-light"
          crossorigin="anonymous"
          async>
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterance.</a></noscript>
</article>
            </div>
            

        </div>
    </main>

    <footer id="footer" class="footer">
        <div class="social-links">
  <a href="mailto:birdgodtech@163.com" class="iconfont icon-email" title="email" rel="noopener" target="_blank" data-title="email"> </a>
  <a href="https://github.com/birdgodtech" class="iconfont icon-github" title="github" rel="noopener" target="_blank" data-title="github"> </a>
  <a href="https://birdgodtech.github.io/index.xml" type="application/rss+xml" rel="noopener" target="_blank" class="iconfont icon-rss" title="rss"></a>


</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 -
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> 本站总访问量 <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次 </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> 本站总访客数 <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 人 </span>
  </div>

  <span class="copyright-year">
    &copy;
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">BirdGod</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
    </div>
</div>

  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.min.js" integrity="sha256-jwCP0NAdCBloaIWTWHmW4i3snUNMHUNO+jr9rYd2iOI=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.locales.min.js" integrity="sha256-ZwofwC1Lf/faQCzN7nZtfijVV6hSwxjQMwXL4gn9qU8=" crossorigin="anonymous"></script>
  <script><!-- NOTE: timeago.js uses the language code format like "zh_CN" (underscore and case sensitive) -->
    var languageCode = "zh-CN".replace(/-/g, '_').replace(/_(.*)/, function ($0, $1) {return $0.replace($1, $1.toUpperCase());});
    timeago().render(document.querySelectorAll('.timeago'), languageCode);
    timeago.cancel();  
  </script>
<script type="text/javascript" src="/dist/even.47f727f4.min.js"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-84813914-2', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>







</body>
</html>
